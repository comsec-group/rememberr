[
    {
        "title": "Some Data Cache Tag Eviction Errors Are Reported As Snoop Errors",
        "problem": "In some cases, the machine check error code on a data cache (DC) tag array parity error erroneously classifies an eviction error as a snoop error. The common cases of cache line replacements and external probes are classified correctly (as eviction and snoop respectively). The erroneous cases occur when a tag error is detected during a DC eviction that was generated by a hardware prefetch, a cache line state change operation, or a number of other internal microarchitectural events. In such cases, the error code logged in the DC Machine Check Status register (MC0_STATUS, MSR0000_0401) erroneously indicates a snoop error.",
        "implication": "Internally detected DC tag errors may be reported to software as having been detected by snoops. Depending upon machine check software architecture, the system response to such errors may be broader than necessary.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "57"
    },
    {
        "title": "Single Machine Check Error May Report Overflow",
        "problem": "A single parity error encountered in the data cache tag array may incorrectly report the detection of multiple errors, as indicated by the overflow bit of the DC Machine Check Status register (bit 62 of MSR0000_0401).",
        "implication": "System software may be informed of a machine check overflow when only a single error was actually encountered.",
        "workaround": "Do not rely on the state of the OVER bit in the DC Machine Check Status register.",
        "status": "No",
        "errnum": "60"
    },
    {
        "title": "Long Mode CALLF or JMPF May Fail To Signal GP When Callgate Descriptor is Beyond GDT/LDT Limit",
        "problem": "If the target selector of a far call or far jump (CALLF or JMPF) instruction references a 16-byte long mode system descriptor where any of the last 8 bytes are beyond the GDT or LDT limit, the processor fails to report a General Protection fault.",
        "implication": "None expected, since the operating system typically aligns the GDT/LDT limit such that all descriptors are legal. However, in the case of erroneous operating system code, the above described GP fault will not be signaled, resulting in unpredictable system failure.",
        "workaround": "None required, it is anticipated that long mode operating system code will ensure the GDT and LDT limits are set high enough to cover the larger (16-byte) long mode system descriptors.",
        "status": "No",
        "errnum": "77"
    },
    {
        "title": "Default RdPtrInit Value Does Not Provide Sufficient Timing Margin",
        "problem": "Insufficient separation of the read pointer and write pointer in the synchronization FIFO can lead to setup violations in the transmit FIFO.",
        "implication": "The setup violations may lead to data corruption.",
        "workaround": "BIOS should program F2x[1, 0]78[3:0] (RdPtrInit) to 5h.",
        "status": "Yes",
        "errnum": "178"
    },
    {
        "title": "A DIV Instruction Followed Closely By Other Divide Instructions May Yield Incorrect Results",
        "problem": "A DIV instruction with a dividend less than 64 that is followed in close proximity by a DIV, IDIV, or AAM instruction may produce incorrect results.",
        "implication": "Possible data corruption.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "244"
    },
    {
        "title": "Breakpoint Due to An Instruction That Has an Interrupt Shadow May Be Delivered to the Hypervisor",
        "problem": "A #DB exception occurring in guest mode may be delivered in the host context under the following conditions: \u2022 A trap-type #DB exception is generated in guest mode during execution of an instruction with an interrupt shadow, and \u2022 The instruction that generated the exception is immediately followed by an instruction resulting in #VMEXIT.",
        "implication": "Unpredictable results due to an unexpected #DB exception.",
        "workaround": "The hypervisor should have a valid interrupt gate in the IDT of the #DB handler entry and the handler must be able to determine that this event has occurred. If the event is detected, the handler should execute an IRET back to the hypervisor; one method that could be used to evaluate for this condition is to compare the RIP pushed on the stack to the RIP of the instruction following VMRUN, if they are equivalent then this event has occurred.",
        "status": "Yes",
        "errnum": "246"
    },
    {
        "title": "INVLPGA of A Guest Page May Not Invalidate Splintered Pages",
        "problem": "When an address mapped by a guest uses a larger page size than the host, the TLB entry created uses the size of the smaller page; this is referred to as page splintering. TLB entries that are the result of page splintering may not be invalidated when the large page is invalidated in the guest using INVLPGA.",
        "implication": "Unpredictable system behavior may result due to inconsistent entries in the TLB.",
        "workaround": "The hypervisor should always intercept INVLPGA instructions. On returning to the guest from the INVLPGA intercept the hypervisor should set TLB_Control = 1 in the VMCB to ensure correctness.",
        "status": "Yes",
        "errnum": "248"
    },
    {
        "title": "Internal Resource Livelock Involving Cached TLB Reload",
        "problem": "Under a highly specific and detailed set of conditions, an internal resource livelock may occur between a TLB reload and other cached operations.",
        "implication": "The system may hang.",
        "workaround": "BIOS should set MSRC001_1023[21] to 1b.",
        "status": "Yes",
        "errnum": "254"
    },
    {
        "title": "REP MOVS Instruction May Corrupt Source Address",
        "problem": "The processor may corrupt the source address for REP MOVS instructions using 16- or 32-bit addressing when a fault occurs on the first iteration and ECX is greater than 255 and EDI equals 0.",
        "implication": "Unpredictable system behavior.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "260"
    },
    {
        "title": "Processor May Stall Entering Stop-Grant Due to Pending Data Cache Scrub",
        "problem": "The processor may stall if a correctable error is identified by the data cache scrubber within a small window of time before the processor enters a stop-grant state when another scrub is pending.",
        "implication": "The system may hang.",
        "workaround": "BIOS should set MSRC001_1022[24].",
        "status": "No",
        "errnum": "261"
    },
    {
        "title": "Incompatibility With Some DIMMs Due to DQS Duty Cycle Distortion",
        "problem": "Some DIMMs exhibit a duty cycle distortion on the first DQS pulse of an incoming read request which may cause the processor's DRAM interface to miss a beat of data in a read burst.",
        "implication": "Undefined system behavior due to incorrect read data.",
        "workaround": "If the memory is DDR2-533 or DDR2-667 or DDR3-667 write 00000800h to F2x[1,0]9C_xD040F30, else write 00000000h to F2x[1,0]9C_xD040F30. The write of 00000000h to F2x[1, 0]9C_xD040F30 is not necessary if BIOS can not change the memory clock speed without a cold reset or if BIOS does not support the above mentioned memory configurations. When exiting from the S4 or S5 state, apply this workaround prior to setting DRAM Configuration Low Register[InitDram] (F2x[1,0]90[0]). In addition, for the above mentioned memory configurations, BIOS should set the DRAM read DQS timing control loop range to 32 during DQS position training. When exiting from the S3 state, apply this workaround prior to setting DRAM Configuration Low Register[ExitSelfRef] (F2x[1,0]90[1]).",
        "status": "No",
        "errnum": "263"
    },
    {
        "title": "Incorrect DRAM Data Masks Asserted When DRAM Controller Data Interleaving Is Enabled",
        "problem": "The processor may incorrectly assert the DRAM data masks for writes less than a cache line when DRAM controller data interleaving is enabled.",
        "implication": "Data corruption.",
        "workaround": "BIOS should set MSRC001_001F[36] (DisDatMsk) to 1b when F2x110[5] (DctDatIntLv) is set to 1b.",
        "status": "Yes",
        "errnum": "264"
    },
    {
        "title": "ITT Specification Exceeded During Power-Up Sequencing",
        "problem": "Processor current consumption may exceed the ITT maximum specified for C0/S0 operation if the VTT voltage regulator is enabled before the VDDIO voltage regulator and the VDDIO regulator enables a low resistance path to VSS while VTT - VDDIO > 400 mV.",
        "implication": "The VTT voltage regulator may shut down if ITT exceeds the platform design limit.",
        "workaround": "None required if either of the following are true: \u2022 The VTT regulator is enabled at the same time or after the VDDIO regulator. \u2022 The VDDIO regulator does not enable a low resistance path to VSS while VTT - VDDIO > 400 mV. For affected systems, the VTT voltage regulator should be enabled at the same time or after the VDDIO voltage regulator during power-up power sequencing. Existing specifications limiting the VDDIO to VTT relationship must be maintained.",
        "status": "No",
        "errnum": "269"
    },
    {
        "title": "Lane Select Function Is Not Available for Link BIST on 8-Bit HyperTransport\u2122 Links In Ganged Mode",
        "problem": "The link BIST engine incorrectly initiates tests on sublink 1 rather than sublink 0 under the following conditions: \u2022 The HyperTransport\u2122 link is configured as an 8-bit link in ganged mode, \u2022 LaneSel[1], F0x[18C:170][13], is set to 1b, \u2022 BistEn, F0x[18C:170][10], is set to 1b, and \u2022 BIST is initiated by assertion of warm reset or a LDTSTOP_L disconnect.",
        "implication": "No impact to normal operational mode; however, the lane select function is not available for testing asymmetric links or isolation of errors to the uplink or downlink on symmetric links.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "273"
    },
    {
        "title": "IDDIO Specification Exceeded During Power-Up Sequencing",
        "problem": "Processor current consumption may exceed the IDDIO maximum specified for C0/S0 operation during power-up sequencing.",
        "implication": "None expected if the VDDIO voltage regulator is sourced by a RUN (running) plane from the power supply during power-up sequencing. Otherwise, during power-up sequencing the VDDIO voltage regulator may shut down if IDDIO exceeds the platform budget or the power supply may shut down if the SUS (suspend) rail current capacity is exceeded.",
        "workaround": "Three options exist to ensure the VDDIO voltage regulator is sourced with sufficient current during processor power-up sequencing: 1. Enable the VDDIO voltage regulator after POWER_GOOD is asserted from the high-current (RUN) source rail. 2. Provide a path for a high-current (RUN) rail to source current to the VDDIO voltage regulator prior to POWER_GOOD assertion from the high-current (RUN) rail. This solution assumes the high-current (RUN) rail is enabled early enough relative to enabling the VDDIO voltage regulator. 3. Choose a power supply with increased capacity for the rail sourcing the VDDIO voltage regulator during power-up sequencing. The capacity required is system specific and should allocate 7 A per processor in the power budget. The following is an example of a supply current capacity calculation assuming a 5 V suspend rail and 3 W rest of system power for a single-processor system. Other platform-specific factors such as power supply or regulator efficiencies should also be considered. \u2022 Rest of system (non-processor) power = 3 W \u2022 Processor power = 7 A/processor * 1 processor * 1.8 V = 12.6 W \u2022 Source rail capacity = (rest of system power + processor power) / source rail voltage; (3 W + 12.6 W) / 5 V = 3.12 A",
        "status": "Yes",
        "errnum": "274"
    },
    {
        "title": "Incorrect Memory Controller Operation In Ganged Mode",
        "problem": "The DRAM controller 0 (DCT0) and DRAM controller 1 (DCT1) refresh counters may not be initialized to the same value using hardware controlled DRAM initialization when operating in ganged mode.",
        "implication": "Incorrect memory controller operation.",
        "workaround": "BIOS should apply the following workaround prior to DRAM training when using hardware- controlled DRAM initialization and F2x110[4] (DctGangEn) is set to 1b. 1. Disable automatic refresh cycles by setting F2x8C[18] (DisAutoRefresh) to 1b. 2. Begin DRAM initialization by setting F2x90[0] to 1b. 3. Poll F2x90[0] until it reads 0b then wait at least 50 microseconds. 4. Enable automatic refresh cycles by clearing F2x8C[18] (DisAutoRefresh) to 0b. 5. Disable automatic refresh cycles by setting F2x8C[18] (DisAutoRefresh) to 1b. 6. Enable automatic refresh cycles by clearing F2x8C[18] (DisAutoRefresh) to 0b. 7. Begin DRAM training. In addition, when resuming from S3, BIOS should apply the following workaround. 1. Disable automatic refresh cycles by setting F2x8C[18] (DisAutoRefresh) to 1b. 2. Initiate exit from self-refresh by setting F2x90[1] to 1b. 3. Poll F2x90[1] until it reads 0b then wait at least 50 microseconds. 4. Enable automatic refresh cycles by clearing F2x8C[18] (DisAutoRefresh) to 0b. 5. Disable automatic refresh cycles by setting F2x8C[18] (DisAutoRefresh) to 1b. 6. Enable automatic refresh cycles by clearing F2x8C[18] (DisAutoRefresh) to 0b.",
        "status": "Yes",
        "errnum": "278"
    },
    {
        "title": "HyperTransport\u2122 Link RTT and RON Specification Violations",
        "problem": "The RTT and RON specifications for the HyperTransport\u2122 link may be violated on some processor revisions.",
        "implication": "These violations do not result in any other HyperTransport\u2122 link electrical specification violations. There are no known functional failures related to this problem.",
        "workaround": "None required.",
        "status": "Yes",
        "errnum": "279"
    },
    {
        "title": "Time Stamp Counter May Yield An Incorrect Value",
        "problem": "Reads of the time stamp counter may yield an inconsistent result.",
        "implication": "Undefined behavior for software that relies on a continuously increasing time stamp counter value.",
        "workaround": "Contact your AMD representative for information on a BIOS upgrade.",
        "status": "Yes",
        "errnum": "280"
    },
    {
        "title": "Memory Instability After PWROK Assertion",
        "problem": "The DRAM DQS DLL may not lock properly after PWROK is asserted.",
        "implication": "The system may have degraded memory margins leading to unreliable DRAM signaling. In some circumstances, this may cause BIOS to degrade the memory speed.",
        "workaround": "During DRAM controller (DCT) initialization, system software should perform the following workaround to every enabled DCT in the system: 1. Perform a dummy DRAM read to any address on any DIMM attached to the DCT. 2. Write 0000_8000h to register F2x[1, 0]9C_xD080F0C. 3. Wait at least 300 nanoseconds. 4. Write 0000_0000h to register F2x[1, 0]9C_xD080F0C. 5. Wait at least 2 microseconds. When exiting from the S4 or S5 state, apply the workaround immediately prior to the Receiver Enable Training. During resume from the S3 state, apply the workaround after F2x[1, 0]90[ExitSelfRef] has been cleared and prior to restoring the F2x[1, 0]9C registers.",
        "status": "Yes",
        "errnum": "293"
    },
    {
        "title": "DRAM Phy Configuration Access Failures",
        "problem": "Under a highly specific set of asynchronous timing conditions established during cold boot (S5 to S0 transition) or resume (S4 or S3 to S0 transition), the skew between the DRAM controllers (DCTs) and DRAM phy may lead to unreliable communication for DRAM phy configuration accesses.",
        "implication": "The system may hang during DRAM configuration accesses when using DCT link ganged mode ([DRAM Controller Select Low Register] F2x110[DctGangEn] = 1b), or fail DRAM training in link ganged mode or in link unganged mode.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "295"
    },
    {
        "title": "Single Machine Check Error May Report Overflow",
        "problem": "A single tag snoop parity error encountered in the instruction cache tag array may incorrectly report the detection of multiple errors, as indicated by the overflow bit of the IC Machine Check Status register (MSR0000_0405[62]).",
        "implication": "System software may be informed of a machine check overflow when only a single error was actually encountered.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "297"
    },
    {
        "title": "L2 Eviction May Occur During Processor Operation To Set Accessed or Dirty Bit",
        "problem": "The processor operation to change the accessed or dirty bits of a page translation table entry in the L2 from 0b to 1b may not be atomic. A small window of time exists where other cached operations may cause the stale page translation table entry to be installed in the L3 before the modified copy is returned to the L2. In addition, if a probe for this cache line occurs during this window of time, the processor may not set the accessed or dirty bit and may corrupt data for an unrelated cached operation.",
        "implication": "One or more of the following events may occur: \u2022 Machine check for an L3 protocol error. The MC4 status register (MSR0000_0410) is B2000000_000B0C0Fh or BA000000_000B0C0Fh. The MC4 address register (MSR0000_0412) is 26h. \u2022 Loss of coherency on a cache line containing a page translation table entry. \u2022 Data corruption.",
        "workaround": "BIOS should set MSRC001_0015[3] (HWCR[TlbCacheDis]) to 1b and MSRC001_1023[1] to 1b. In a multiprocessor platform, the workaround above should be applied to all processors regardless of revision when an affected processor is present.",
        "status": "Yes",
        "errnum": "298"
    },
    {
        "title": "Hardware Memory Clear Is Not Supported After Software DRAM Initialization",
        "problem": "When using software-controlled DRAM device initialization using EnDramInit (F2x[1, 0]7C DRAM Initialization Register[31]), hardware memory clear using MemClrInit (F2x110 DRAM Controller Select Low Register[3]) does not function.",
        "implication": "After BIOS sets MemClrInit (F2x110[3]), the hardware will not clear memory and will not set MemCleared (F2x110[10]). The BIOS will hang waiting for the operation to complete.",
        "workaround": "BIOS should use hardware initialization of DRAM using InitDram (F2x[1, 0]90 DRAM Configuration Low Register[0]). If BIOS uses software initialization, alternative methods to initialize ECC must be used.",
        "status": "Yes",
        "errnum": "300"
    },
    {
        "title": "Performance Counters Do Not Accurately Count MFENCE or SFENCE Instructions",
        "problem": "MFENCE and SFENCE instructions are not accurately counted by the performance monitor when MSRC001_000[3:0][7:0] (EventSelect) is 1D4h, or 1D5h.",
        "implication": "Performance monitoring software will not be able to count MFENCE and SFENCE instructions.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "301"
    },
    {
        "title": "MWAIT Power Savings May Not Be Realized when Two or More Cores Monitor the Same Address",
        "problem": "Execution of the MONITOR instruction may cause another core to exit the monitor event pending state.",
        "implication": "No functional impact; however, the power savings associated with the MWAIT instruction may not be realized.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "302"
    },
    {
        "title": "Processor Stall in C1 Low Power State",
        "problem": "Under a highly specific set of internal timing conditions, an L3 eviction may stall for a processor core that has entered the C1 (halt) state. If the processor core has already entered the low power state and the CpuPrbEn bit in the C1 SMAF is 0b (F3x84[24]), the stall persists until the processor core comes out of the low power state.",
        "implication": "The system may hang.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "308"
    },
    {
        "title": "Processor Core May Execute Incorrect Instructions on Concurrent L2 and Northbridge Response",
        "problem": "Under a specific set of internal timing conditions, an instruction fetch may receive responses from the L2 and the northbridge concurrently. When this occurs, the processor core may execute incorrect instructions.",
        "implication": "Unpredictable system behavior.",
        "workaround": "BIOS should set MSRC001_1023[23].",
        "status": "Yes",
        "errnum": "309"
    },
    {
        "title": "CVTSD2SS and CVTPD2PS Instructions May Not Round to Zero",
        "problem": "The Convert Scalar Double-Precision Floating-Point to Scalar Single-Precision Floating-Point (CVTSD2SS) and Convert Packed Double-Precision Floating-Point to Packed Single-Precision Floating-Point (CVTPD2PS) instructions do not round to zero when the Flush to Zero and Underflow Mask bits (MXCSR bits 15 and 11) are set to 1b and the double-precision operand is less than the smallest single-precision normal number.",
        "implication": "The conversion result will yield the smallest single-precision normalized number rather than zero. It is not expected that this will result in any anomalous software behavior since enabling flush to zero provides less precise results.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "312"
    },
    {
        "title": "FST and FSTP Instructions May Calculate Operand Address in Incorrect Mode",
        "problem": "A Floating-Point Store Stack Top (FST or FSTP) instruction in 64-bit mode that is followed shortly by an instruction that changes to compatibility mode may incorrectly calculate the operand address using compatibility mode. Also, an FST or FSTP instruction in compatibility mode that is followed shortly by an instruction that changes to 64-bit mode may incorrectly calculate the operand address using 64-bit mode. The incorrect mode for address calculation is only used under highly specific internal timing conditions and when the Underflow Mask bit (FCW bit 4) is set and the data to be stored by the FST or FSTP instruction is a denormalized (tiny) number.",
        "implication": "The processor may store to an incorrect address. This may cause an unexpected page fault or unpredictable system behavior. This sequence has not been observed in any production software.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "315"
    },
    {
        "title": "Inaccurate Temperature Measurement",
        "problem": "The internal thermal sensor used for CurTmp (F3xA4[31:21]), hardware thermal control (HTC), software thermal control (STC) thermal zone, and the sideband temperature sensor interface (SB-TSI) may report inconsistent values. For CPUID Fn0000_0001_EAX[7:4] (Model) 4 and higher, this temperature inconsistency will occur only on AM2r2, Fr2, Fr5 and Fr6 package processors",
        "implication": "HTC, STC thermal zone, and SB-TSI do not provide reliable thermal protection. This does not affect THERMTRIP or the use of the STC-active state using StcPstateLimit or StcPstateEn (F3x68[30:28, 5]).",
        "workaround": "None. Platforms that accept AM2r2, Fr2 (1207), Fr5 (1207) or Fr6 (1207) package processors should be designed with conventional thermal control and throttling methods or utilize PROCHOT_L functionality based on temperature measurements from an analog thermal diode (THERMDA/THERMDC). These systems should not rely on the HTC features, STC thermal zone features, or use SB-TSI. When (((CPUID Fn8000_0001_EBX[PkgType, bits 31:28] == 1 (AM2r2 or AM3)) && (F2x[1, 0]94[Ddr3Mode, bit 8] == 0)) || (CPUID Fn8000_0001_EBX[31:28] == 0 (F (1207)))), software should not modify HtcTmpLmt (F3x64[22:16]), utilize the value from CurTmp, or enable any of the STC thermal zone features by setting StcThrottEn, StcApcTmpLoEn, StcApcTmpHiEn, StcSbcTmpLoEn, or StcSpcTmpHiEn (F3x68[4,3:0]).",
        "status": "Yes",
        "errnum": "319"
    },
    {
        "title": "Address and Command Fine Delay Values May Be Incorrect",
        "problem": "The DRAM phy uses the memory speed at the time of DRAM initialization or self-refresh exit to adjust the fine delay values based on internal DLL settings. Data written to fine delay registers prior to DRAM initialization or self-refresh exit may be adjusted incorrectly. No effect is observed for all fine delays except those in the DRAM Address/Command Timing Control Register at F2x[1,0]9C_x04; these are written after DRAM initialization. However, F2x[1,0]9C_x04 may be written before DRAM initialization or self-refresh exit and may result in an incorrect adjustment. This erratum only affects MEMCLK frequencies of 400 MHz and higher.",
        "implication": "The system may have degraded memory margins leading to unreliable DRAM signaling.",
        "workaround": "The following workaround should be applied by BIOS prior to writing F2x[1,0]9C_x04 during DRAM controller (DCT) initialization and during the S3 resume sequence: 1. Write 00000000h to F2x[1,0]9C_xD08E000. 2. In unganged mode (DRAM Controller Select Low Register [DctGangEn] (F2x110[4]) = 0b), if DRAM Configuration Register[MemClkFreq] (F2x[1,0]94[2:0]) is greater than or equal to 011b, write 00000080h to F2x[1,0]9C_xD02E001, else write 00000090h to F2x[1,0]9C_xD02E001. 3. In ganged mode (DRAM Controller Select Low Register [DctGangEn] (F2x110[4]) = 1b), if DRAM Configuration Register[MemClkFreq] (F2x94[2:0]) is greater than or equal to 011b, write 00000080h to F2x9C_xD02E001 and F2x19C_xD02E001, else write 00000090h to F2x9C_xD02E001 and F2x19C_xD02E001. The write of 00000090h to F2x[1,0]9C_xD02E001 is not necessary if BIOS can not change the memory clock speed without a cold reset.",
        "status": "No",
        "errnum": "322"
    },
    {
        "title": "Misaligned Load Operation May Cause Processor Core Hang",
        "problem": "Under a highly specific set of internal timing conditions, load operations with a misaligned operand may hang. Any instruction loading data from memory without a LOCK prefix where the first byte and the last byte are in separate octal words may cause the condition mentioned above.",
        "implication": "Processor core hang.",
        "workaround": "BIOS should clear MSRC001_1022[43:42].",
        "status": "Yes",
        "errnum": "326"
    },
    {
        "title": "HyperTransport\u2122 Link RTT Specification Violation",
        "problem": "The RTT specification for the HyperTransport\u2122 link may be violated on some processor revisions.",
        "implication": "These violations do not result in any other HyperTransport\u2122 link electrical specification violations. There are no known functional failures related to this problem.",
        "workaround": "BIOS should set the Link Phy Impedance Register[RttCtl] (F4x1[9C, 94, 8C, 84]_x[D0, C0][31:29]) to 010b and Link Phy Impedance Register[RttIndex] (F4x1[9C, 94, 8C, 84]_x[D0, C0][20:16]) to 00100b.",
        "status": "No",
        "errnum": "327"
    },
    {
        "title": "BIST May Report Failures on Initial Powerup",
        "problem": "When BIST is run after initial powerup, a non-zero (i.e., failing) value may be erroneously reported in EAX. Subsequent BIST runs (induced by warm resets) are not affected by this erratum, and accurately report pass/fail as determined by the presence or absence of detectable defects in the structures tested.",
        "implication": "The processor may incorrectly represent itself as being defective on initial powerup. The system response to this is system software dependent.",
        "workaround": "On initial powerup, system software should disregard the BIST result in EAX.",
        "status": "Yes",
        "errnum": "328"
    },
    {
        "title": "Instruction-Based Sampling May Be Inaccurate",
        "problem": "The processor may experience sampling inaccuracies when Instruction-Based Sampling (IBS) is enabled in the following cases: \u2022 The IBS may not tag an operation when the current counter in IBS Execution Control Register[IbsOpCurCnt] (MSRC001_1033[51:32]) reaches the value in IBS Fetch Control Register[IbsOpMaxCnt] (MSRC001_1030[15:0], resulting in a missed sample. When this occurs, the IBS counter rolls over without an interrupt. \u2022 The selection of instructions for IBS may be significantly skewed due to effects of instruction cache misses and branch prediction. As a result, certain instructions may be tagged less frequently than other instructions even when executed in the same code block.",
        "implication": "Inaccuracies in performance monitoring software may be experienced. Despite this erratum, IBS can be used effectively for identifying performance issues associated with specific instructions. The sampling bias makes IBS less effective for measuring statistical distribution of operations and events across a large code sequence on affected processor revisions.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "336"
    },
    {
        "title": "CPU Instruction-Based Sampling Fields May Be Inaccurate",
        "problem": "The processor may experience sampling inaccuracies when Instruction-Based Sampling (IBS) is enabled in the following fields: \u2022 IBS Op Data Register[IbsCompToRetCtr] (MSRC001_1035[15:0]) may be incorrect for floating-point instructions, when IBS Op Data 3 Register[IbsStOp] (MSRC001_1037[1]) is set, or when IBS Op Data 3 Register[IbsLdOp] (MSRC001_1037[0]) is set. \u2022 IBS Op Data 3 Register[IbsDcMissLat] (MSRC001_1037[47:32]) may be incorrect if the processor tags a load instruction for IBS and the data for a retired store operation is in the process of being written to the data cache. As a result, IbsDcMissLat may start counting early when the load instruction is tagged and may be non-zero on a data cache hit. \u2022 IBS Op Data 3 Register[IbsDcStToLdFwd, IbsDcL2TlbHit2M, IbsDcL2TlbMiss] (MSRC001_1037[11, 6, 3]) may be incorrect when IBS Op Data 3 Register[IbsDcStBnkCon] (bit 10) or IBS Op Data 3 Register[IbsDcLdBnkCon] (bit 9) are set. \u2022 IBS Op Data 3 Register[IbsLdOp, IbsStOp] (MSRC001_1037[1:0]) may be set incorrectly for non load/store instructions that are tagged for IBS. Other fields in MSRC001_1037 may also be set based on an unrelated instruction. This occurs when a load/store instruction is tagged and then a branch misprediction causes it to be canceled. When a new instruction is tagged for IBS, it may trigger incorrect information if the same buffers are used for both instructions. This typically would not result in a statistically significant number of incorrect samples. \u2022 IBS Op Logical Address Register (MSRC001_1034) may not point to the sampled instruction when highly specific conditions are met for the sampled and surrounding instructions. In these cases, the address reported may be 16 bytes past the sampled instruction and may not point to the beginning of an actual instruction.",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "337"
    },
    {
        "title": "Northbridge Instruction-Based Sampling Fields May Be Inaccurate",
        "problem": "The IBS Op Data 2 Register[NbIbsReqDstProc] (MSRC001_1036[4]) may be incorrect when the northbridge is performing back-to-back operations while an instruction tagged for Instruction-Based Sampling (IBS) is executed and IBS Op Data 2 Register[NbIbsReqSrc] (MSRC001_1036[2:0]) is 011b or 111b. This typically would not result in a statistically significant number of incorrect samples.",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "338"
    },
    {
        "title": "APIC Timer Rollover May Be Delayed",
        "problem": "The APIC timer does not immediately rollover when it transitions to zero and Timer Local Vector Table Entry[Mode] (APIC320[17]) is configured to run in periodic mode. In addition, when Timer Local Vector Table Entry[Mask] (APIC320[16]) is configured to generate an interrupt, the interrupt is also delayed whether configured for periodic or one-shot mode. The per rollover error that may be observed is between 35 and 90 ns.",
        "implication": "None expected. The standard use of the APIC timer and the level of accuracy required does not make the error significant.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "339"
    },
    {
        "title": "SMIs That Are Not Intercepted May Disable Interrupts",
        "problem": "During a resume from SMM that is due to an unintercepted SMI from a SVM guest context, the processor core does not restore the correct effective interrupt flag (IF) if the guest VMCB V_INTR_MASKING bit (offset 060h bit 24) is 1b. Under these circumstances, the effective interrupt flag may be zero. SMIs are not intercepted if VMCB offset 00Ch bit 2 is 0b or HWCR[SmmLock] (MSRC001_0015[0]) is 1b.",
        "implication": "The guest context may run with interrupts disabled until the next guest intercept. The hypervisor may not be able to regain control and the system may hang.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "342"
    },
    {
        "title": "Eviction May Occur When Using L2 Cache as General Storage During Boot",
        "problem": "When system software is using the L2 cache as general storage before memory initialization, the processor may determine during speculative execution that data destined for the instruction cache is dirty. The processor will then evict these cache lines, resulting in lost data.",
        "implication": "System software using L2 cache as general storage before memory initialization may experience unpredictable system behavior.",
        "workaround": "System software should set MSRC001_102A[35] to 1b prior to using L2 cache as general storage during boot. System software should clear MSRC001_102A[35] to 0b after the L2 cache is no longer used as general storage.",
        "status": "No",
        "errnum": "343"
    },
    {
        "title": "Intermittent HyperTransport\u2122 Link Training Failures",
        "problem": "The HyperTransport\u2122 link training may fail at speeds greater than 2.0 GT/s.",
        "implication": "When exiting from S3, S4 or S5 state, the system may hang when a reset or LDTSTOP is applied and the link speed is greater than 2.0 GT/s. In addition, when F0x[18C:170][Ls2En] is set the system may hang exiting from LS2 link power state if the link speed is greater than 2.0 GT/s.",
        "workaround": "System software should set bit 6 of F4x1[9C, 94, 8C, 84]_x[78:70, 68:60]. The bits should be set before the link frequency is changed from the cold reset value.",
        "status": "No",
        "errnum": "344"
    },
    {
        "title": "System May Hang if Core Frequency is Even Divisor of Northbridge Clock",
        "problem": "When one processor core is operating at a clock frequency that is higher than the northbridge clock frequency, and another processor core is operating at a clock frequency that is an even divisor of the northbridge clock frequency, the northbridge may fail to complete a cache probe.",
        "implication": "System hang.",
        "workaround": "System software should set F3x188[22] to 1b.",
        "status": "Yes",
        "errnum": "346"
    },
    {
        "title": "Processor On-die Termination Resistance is Higher than Specification",
        "problem": "The actual processor on-die termination resistance for DDR2 mode differs from the values specified for F2x[1, 0]9C_x00[29:28] (ProcOdt) in the BIOS and Kernel Developer\u2019s Guide (BKDG) for AMD Family 10h Processors, order# 31116 as shown in the table below: ProcOdt Specification in DDR2 mode Silicon Implementation 00b 300 ohms +/- 20% 480 ohms +/- 20% 01b 150 ohms +/- 20% 240 ohms +/- 20% 10b 75 ohms +/- 20% 120 ohms +/- 20% 11b Reserved Reserved",
        "implication": "Increased ODT resistance may affect DDR2 memory margins.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "348"
    },
    {
        "title": "DRAM May Fail Training on Cold Reset",
        "problem": "The DRAM DQS DLL may not lock after PWROK is asserted, resulting in a DRAM training failure.",
        "implication": "The system may fail to boot.",
        "workaround": "During DRAM controller (DCT) initialization, system software should perform the following workaround to every enabled DCT in the system: 1. Perform a dummy DRAM read to any address on any DIMM attached to the DCT. 2. Write 0000_8000h to register F2x[1, 0]9C_xD080F0C. 3. Wait at least 300 nanoseconds. 4. Write 0000_0000h to register F2x[1, 0]9C_xD080F0C. 5. Wait at least 2 microseconds. When exiting from the S4 or S5 state, apply the workaround immediately prior to the Receiver Enable Training. During resume from the S3 state, apply the workaround after F2x[1, 0]90[ExitSelfRef] has been cleared and prior to restoring the F2x[1, 0]9C registers.",
        "status": "No",
        "errnum": "350"
    },
    {
        "title": "HyperTransport\u2122 Technology LS2 Low-Power Mode May Not Function Correctly",
        "problem": "The HyperTransport\u2122 technology LS2 low-power state may not function correctly in all systems.",
        "implication": "System hang or video distortion due to excessive latency.",
        "workaround": "System software should program the Link Extended Control Registers[LS2En] (F0x[18C:170][8]) to 0b for all links. This allows the LS1 low-power state to be used as an alternative to LS2. System software should also program Link Global Extended Control Register[ForceFullT0] (F0x16C[15:13]) to 000b.",
        "status": "Yes",
        "errnum": "351"
    },
    {
        "title": "SYSCALL Instruction May Execute Incorrectly Due to Breakpoint",
        "problem": "A SYSCALL instruction executes incorrectly and an incorrect debug exception is taken when all of the following conditions are satisfied: \u2022 An enabled instruction breakpoint address matches the RIP of the SYSCALL instruction. \u2022 The processor is in 64-bit mode or compatibility mode. \u2022 The instruction would not generate any other exception. \u2022 SYSCALL Flag Mask Register[16] (MSRC000_0084[16]) is set to 1b. \u2022 rFLAGS.RF is set to 1b.",
        "implication": "None expected during normal operation. Kernel debuggers may observe unpredictable system behavior.",
        "workaround": "Operating system software should clear SYSCALL Flag Mask Register[16] (MSRC000_0084[16]) to 0b during initialization.",
        "status": "Yes",
        "errnum": "352"
    },
    {
        "title": "SYSRET Instruction May Execute Incorrectly Due to Breakpoint",
        "problem": "A SYSRET instruction executes incorrectly and an incorrect debug exception is taken when all of the following conditions are satisfied: \u2022 An enabled instruction breakpoint address matches the RIP of the SYSRET instruction. \u2022 The processor is in 64-bit mode or compatibility mode. \u2022 The instruction would not generate any other exception. \u2022 R11[16] is cleared to 0b. \u2022 rFLAGS.RF is set to 1b.",
        "implication": "None expected during normal operation. Kernel debuggers may observe unpredictable system behavior.",
        "workaround": "Software should set R11[16] to 1b before executing the SYSRET instruction in 64-bit mode.",
        "status": "Yes",
        "errnum": "353"
    },
    {
        "title": "HyperTransport\u2122 Link Training Failure",
        "problem": "Some processors may fail HyperTransport\u2122 link training at speeds greater than 2.0 GT/s. The link training failure may be intermittent.",
        "implication": "When exiting from S3, S4 or S5 state, the system may hang when a reset or LDTSTOP is applied and the link speed is greater than 2.0 GT/s. In addition, when F0x[18C:170][Ls2En] is set the system may hang exiting from LS2 link power state if the link speed is greater than 2.0 GT/s.",
        "workaround": "System software should set bit 6 of F4x1[9C,94,8C,84]_x[58:50, 48:40] for all links. The bits should be set before the link frequency is changed from the cold reset value.",
        "status": "Yes",
        "errnum": "354"
    },
    {
        "title": "DRAM Read Errors May Occur at Memory Speeds Higher than DDR2-800",
        "problem": "The processor DRAM interface may miss a beat of data under conditions of back-to-back read bursts to the same chip select using DDR2-1066 memory speed, resulting in incorrect data read by the DRAM interface until a processor reset occurs. This issue is sensitive to processor VDDIO and VTT voltage settings.",
        "implication": "Undefined system behavior that usually results in a system hang due to a triple fault.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "355"
    },
    {
        "title": "MEMCLK is Not Provided for Minimum Specified Time Before CKE Assertion",
        "problem": "During hardware DDR2 device initialization, the processor does not provide a running MEMCLK for the specified minimum time of 200 microseconds before CKE is asserted.",
        "implication": "No adverse effects have been observed. The processor does not initiate a DRAM access for over 200 microseconds from the start of MEMCLK and the assertion of CKE. If a DDR2 DIMM is sensitive to this issue, the system may fail to boot.",
        "workaround": "None required.",
        "status": "Yes",
        "errnum": "359"
    },
    {
        "title": "DRAM CKE and Address Drive Strength Values May Be Incorrect",
        "problem": "The processor does not correctly assign DRAM Output Driver Compensation Control Register[CkeDrvStren] (F2x[1,0]9C_x00[1:0]) and DRAM Output Driver Compensation Control Register[AddrCmdDrvStren] (F2x[1,0]9C_x00[9:8]) to the specified DRAM pins. Differences from the specified assignments are shown in the following table; other assignments are not affected: Missing Assigned DRAM Register Field Extra Assigned DRAM Pins Pins CkeDrvStren DRAM address pins 1, 2 and 3 CKE AddrCmdDrvStren CKE DRAM address pins 1, 2 and 3 This erratum applies only when programming two different settings to the CkeDrvStren and AddrCmdDrvStren register fields. Functionality is correct when the two register fields are programmed to identical values.",
        "implication": "Pin drive strengths that differ from those expected may affect memory margins.",
        "workaround": "No workaround required for system designers using AMD recommended values in these fields. With the AMD recommended values, the erratum does not apply to any settings in 1T timing mode. A workaround is not necessary in 2T timing mode as the impact of this erratum to overall memory margins is minimal.",
        "status": "No",
        "errnum": "360"
    },
    {
        "title": "Breakpoint Due to an Instruction That Has an Interrupt Shadow May Be Lost",
        "problem": "A #DB exception occurring in guest mode may be discarded under the following conditions: \u2022 A trap-type #DB exception is generated in guest mode during execution of an instruction with an interrupt shadow, and \u2022 The instruction that generated the exception is immediately followed by an instruction resulting in #VMEXIT.",
        "implication": "None expected under normal conditions. Debug exceptions may not be received for programs running under a hypervisor.",
        "workaround": "None.",
        "status": "No",
        "errnum": "361"
    },
    {
        "title": "Illegal Packet on HyperTransport\u2122 Link May Prevent Warm Reset",
        "problem": "The processor may fail to drive external pins to their reset pattern when warm reset is asserted, and may fail to restart after warm reset is subsequently deasserted, when both of the following conditions are satisfied: \u2022 The processor has received an illegal packet from a non-coherent HyperTransport\u2122 link with a specific encoding only used on coherent links. This packet may be detected near a warm reset as the processor may sample packets on the link for a brief time after warm reset is asserted. On some platforms, the conditions under which the processor may receive an illegal packet near a warm reset may not be observed. If link retry mode is enabled, this erratum applies only if the incoming illegal packet contains a valid CRC. \u2022 One or more processor cores is in the C1 halt state with clocks ramped down. If C1 ACPI Power State Control Registers [CpuPrbEn] (F3x84[24]) = 1b, clocks are considered as ramped down for a processor core in the C1 halt state for any valid setting of F3x84[31:29] (ClkDivisor) other than 000b.",
        "implication": "System hang during a warm reset. This erratum does not impact cold reset or INIT.",
        "workaround": "None required for platforms that do not observe this issue. For other platforms, platform BIOS should set a global SMI trap on any write to a port that could cause warm reset to assert, and then execute the write from within the SMI handler. This ensures that no cores have clocks ramped down when warm reset is asserted. This workaround is not effective for warm resets that are initiated without a software write to a port that can be trapped.",
        "status": "Yes",
        "errnum": "362"
    },
    {
        "title": "DRAM Read Errors May Occur at DDR2-800 Memory Speeds With Higher Read DQS Delays",
        "problem": "The processor DRAM interface may miss a beat of data under conditions of back-to-back read bursts to the same chip select using DDR2-800 memory speeds, resulting in incorrect data read by the DRAM interface until a processor reset occurs. This issue is sensitive to higher levels of jitter on the read DQS inputs from DRAM in combination with higher settings of DRAM Read DQS Timing Control [High:Low] Registers[RdDqsTimeByte][7:0] at offsets F2x[1, 0]9C_x[3:0]0[6:5].",
        "implication": "For systems without ECC, undefined system behavior that usually results in a system hang due to a triple fault. Systems with ECC enabled may experience repeated multiple-bit ECC errors.",
        "workaround": "If the system DRAM speed is DDR2-800, system software should constrain the settings of F2x[1, 0]9C_x[3:0]0[6:5][RdDqsTimeByte][7:0] obtained from DRAM training to values of 0Ch or less. Implementation of this workaround may have a nominal effect on DDR2-800 memory margins.",
        "status": "Yes",
        "errnum": "370"
    },
    {
        "title": "Processor Read That Matches The Address of an Earlier Uncompleted Write May Be Incorrect",
        "problem": "Under highly specific and detailed internal timing conditions, processor data for a read may be corrupted when a read occurs that matches the address of an earlier uncompleted write or L3 eviction. This erratum applies only when both of the following conditions are satisfied on any processor node: \u2022 DRAM controllers are in DCT link unganged mode ([DRAM Controller Select Low Register] F2x110[DctGangEn] = 0b). \u2022 The northbridge current operating frequency (COF) is less than 3 times the memory clock frequency.",
        "implication": "Unpredictable system behavior.",
        "workaround": "On systems supporting DDR3-1333 or northbridge P-state 1, and using DCT link unganged mode, system software should set MSRC001_001F[52:51] to 11b.",
        "status": "No",
        "errnum": "372"
    },
    {
        "title": "Processor Write to APIC Task Priority Register May Cause Error Status Bit to Set",
        "problem": "The processor may set Error Status Register[Send Accept Error] (APIC280[2]) after a write to a Task Priority Register (APIC080). This can occur only if a write to APIC080 follows a write to an Interrupt Command Register (APIC3[1, 0]0) that triggers an interprocessor interrupt (IPI). This erratum does not apply if the IPI message type set on APIC3[1, 0]0[10:8] is 011b (remote read), or if an L3 cache is present.",
        "implication": "Software may observe and report a false APIC error.",
        "workaround": "If an L3 cache is not present as indicated by CPUID Fn8000_0006_EDX[L3Size] (CPUID Fn8000_0006_EDX[31:18]) being equal to zero, system software should set MSRC001_001F[57] to 1b.",
        "status": "No",
        "errnum": "373"
    },
    {
        "title": "Processor Read From L3 Cache May Return Stale Data",
        "problem": "Under highly specific and detailed internal timing conditions, a processor read from the L3 cache may return stale data.",
        "implication": "Unpredictable system behavior due to incorrect read data.",
        "workaround": "System software should set F3x1B8[18] to 1b.",
        "status": "Yes",
        "errnum": "374"
    },
    {
        "title": "Processor May Operate at Reduced Frequency",
        "problem": "When Product Information Register F3x1FC[31] is set, the reset values of the P-State Registers (MSRC001_00[68:64]) are not compliant with prior algorithms used to specify the P-state frequencies. Only one P-state register has bit 63 (PstateEn) set and the CPU frequency specified by this P-State register is below the maximum operating frequency for the processor.",
        "implication": "AM3 package processors may experience performance degradation when installed in an AM2r2 or AM3 platform.",
        "workaround": "For AM3 package processors, when F3x1FC[31] is not set, the system designer must consult the AMD Family 10h Desktop Processor Power and Thermal Datasheet, order #43375 for correct single- plane TDP values. On AM2r2 and AM3 platforms, if F3x1FC[31] is set BIOS must follow the updated algorithm to write MSRC001_00[68:64] with corrected values, as documented in revision 3.23 or later versions of the BIOS and Kernel Developer\u2019s Guide (BKDG) for AMD Family 10h Processors, order# 31116. This updated algorithm is applicable only to AM2r2 and AM3 platforms, and is incompatible with AM2 platforms.",
        "status": "No",
        "errnum": "378"
    },
    {
        "title": "DDR3-1333 Configurations with Two DIMMs per Channel May Experience Unreliable Operation",
        "problem": "In systems with more than one DDR3-1333 unbuffered DIMM on a channel, the processor memory subsystem may exhibit unreliable operation over the allowable VDDIO voltage range. This erratum does not apply to DDR3-1333 configurations when only one DIMM per channel is populated.",
        "implication": "Memory system failure leading to unpredictable system behavior.",
        "workaround": "In a configuration where two unbuffered DDR3-1333 DIMMs are populated on one channel, BIOS should derate DDR3-1333 system memory to 533 MHz operation (DDR3-1066) by setting the DRAM Configuration High Register[MemClkFreq] (F2x[1, 0]94[2:0]) to 100b and adjusting memory subsystem timing parameters accordingly.",
        "status": "Yes",
        "errnum": "379"
    },
    {
        "title": "L3 Cache Index Disable Cannot Be Modified After L3 Cache is Enabled",
        "problem": "The processor does not support the disabling of L3 indices using the L3 Cache Index Disable Registers (F3x[1C0, 1BC]) after the cache subsystem has been enabled (CR0[CD] = 0b).",
        "implication": "If software modifies F3x[1C0, 1BC] after the L3 cache has been enabled using CR0[CD], unpredictable system behavior may result.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "382"
    },
    {
        "title": "CPU Core May Machine Check When System Software Changes Page Tables Dynamically",
        "problem": "If system software performs uncommon methods to change the page size of an active page table that is valid, the CPU core may, under a highly specific and detailed set of conditions, form duplicate TLB entries for a single linear address. The CPU core will machine check if this page is then accessed prior to it being invalidated from the TLB.",
        "implication": "Uncorrectable machine check exception for an L1 TLB Multimatch error. The MC0_STATUS register (MSR0000_0401) is B6000000_00010015h. Bit 62 (error overflow) of MC0_STATUS may or may not be set.",
        "workaround": "Affected software must ensure that page sizes are only increased or decreased after the entry is invalidated and flushed out of all TLBs. When flushing multiple entries from the TLB, software may wish to use a single MOV CR3 value to invalidate the TLB instead of repetitive INVLPG instructions. Additionally, hypervisors should ensure that the effects of a nested paging guest that exposes the condition is limited to the guest virtual machine with the following steps: 1. During hypervisor initialization, the hypervisor should set MSRC001_1022[47]. 2. The hypervisor should intercept machine-check exceptions (#MC) by setting VMCB offset 08h bit 12h. 3. When a VM_EXIT occurs with exit code 52h, the hypervisor must perform all the functions of a #MC exception handler. At a minimum, the hypervisor must clear MCi_STATUS registers and clear MCG_STAT[MCIP] (MSR0000_017A[2]). Failure to do so will result in a system shutdown in the event of a second machine check. 4. During the above process, the hypervisor should inspect the contents of MSR0000_0401 for the exact signature described in the Potential Effect on System. If the signature exists, then the hypervisor should abort the guest. 5. The hypervisor should flush the TLB. 6. The hypervisor should then resume operation.",
        "status": "No",
        "errnum": "383"
    },
    {
        "title": "DRAM Prefetch May Cause System Hang When Probe Filter is Enabled",
        "problem": "When the processor is accessing memory with the probe filter and DRAM prefetch enabled, a DRAM prefetch may not complete.",
        "implication": "System hang.",
        "workaround": "System software should set the Memory Controller Configuration High[PrefIoDis, PrefCpuDis] (F2x11C[13:12] = 11b) if probe filter is enabled.",
        "status": "Yes",
        "errnum": "384"
    },
    {
        "title": "Processor May Report Incorrect Address For an L3 Cache Error Machine Check",
        "problem": "The processor may report an incorrect address at NB Machine Check Address Register MSR0000_0412 when executing a machine check for an L3 cache error. In addition, when disabling an L3 cache index by writing to L3 Cache Index Disable Registers F3x[1C0, 1BC] [Index], the processor may not disable the intended L3 cache index.",
        "implication": "Operating system software may take inappropriate action due to an incorrectly reported L3 cache error.",
        "workaround": "System software should program F3x1B8[23] to 1b before enabling the L3 cache using CR0[30] (CD).",
        "status": "No",
        "errnum": "385"
    },
    {
        "title": "HyperTransport\u2122 Link in Retry Mode That Receives Repeated Invalid Packets May Cause MCA Exception",
        "problem": "Under highly specific and detailed internal timing conditions, a HyperTransport\u2122 link in retry mode that receives repeated invalid packets in a specific sequence may cause the processor to generate a link data buffer overflow MCA exception. This erratum applies only when a link is configured as 16-bit ganged and the northbridge current operating frequency is less than the link clock frequency.",
        "implication": "System hang. A link data buffer overflow MCA exception will also be reported.",
        "workaround": "System software should program the Link Base Channel Buffer Count Registers F0x[F0, D0, B0, 90][27:25] (FreeData) to 000b to disable all free list link data buffers. To maximize system performance when applying this workaround on NFCM coherent links, system software should modify the settings for F0x[F0, D0, B0, 90] as specified in the BIOS and Kernel Developer\u2019s Guide (BKDG) for AMD Family 10h Processors, order# 31116, per the following table: Register/Field NFCM Coherent Link Modified Setting FreeData 0 FreeCmd 8 RspData 3 NpReqData 2 ProbeCmd 8 RspCmd 9 PReq 3 NpReqCmd 4",
        "status": "Yes",
        "errnum": "386"
    },
    {
        "title": "Performance Counters Do Not Accurately Count L3 Cache Evictions",
        "problem": "The processor does not report the correct count of L3 cache evictions when Performance Event Select Register (PERF_CTL[3:0]) MSRC001_000[3:0][EventSelect] is 4E3h. This erratum applies to all unit mask settings for this event.",
        "implication": "Performance monitoring software will not be able to count L3 cache evictions with this event counter.",
        "workaround": "Performance monitoring software can use EventSelect 0EAh, UnitMask 01h as an alternate method to count victim block writebacks.",
        "status": "No",
        "errnum": "387"
    },
    {
        "title": "L3 Cache Scrubbing Does Not Bypass Disabled L3 Cache Locations",
        "problem": "The processor does not discontinue scrubbing L3 cache locations that are disabled using the L3 Cache Index Disable Registers F3x[1C0, 1BC].",
        "implication": "ECC errors that occur when scrubbing disabled L3 cache locations can generate unexpected machine check exceptions.",
        "workaround": "System software should program Scrub Rate Control Register F3x58[28:24] (L3Scrub) to 00000b before disabling any L3 cache locations. This workaround should not be applied when all L3 cache locations are enabled.",
        "status": "Yes",
        "errnum": "388"
    },
    {
        "title": "HyperTransport\u2122 Link in Retry Mode May Consume Link Packet Buffer Incorrectly",
        "problem": "Under highly specific and detailed internal timing conditions, a coherent HyperTransport\u2122 link in retry mode that receives an invalid per-packet CRC may cause the processor to incorrectly consume a link packet buffer during link retry. This erratum applies only when F0x150[11:9] (HtRetryCrcDatIns) is set to a value other than 000b.",
        "implication": "System hang.",
        "workaround": "When CPUID Fn0000_0001_EAX[7:4] (Model) < 8, no workaround is required. For system developers that wish to provide a workaround for this event, system software may clear F0x150[11:9] (HtRetryCrcDatIns) to 000b. System software should clear F0x150[11:9] (HtRetryCrcDatIns) to 000b for all other affected processor revisions.",
        "status": "Yes",
        "errnum": "389"
    },
    {
        "title": "HyperTransport\u2122 Link RTT and RON Specification Violations",
        "problem": "The RTT and RON specifications of the HyperTransport\u2122 link may be violated on some lanes.",
        "implication": "These violations do not result in any functional failures on HyperTransport\u2122 links.",
        "workaround": "None.",
        "status": "No",
        "errnum": "391"
    },
    {
        "title": "Performance Monitor May Count Fastpath Double Operation Instructions Incorrectly",
        "problem": "The processor does not report the correct count for all fastpath double operation instructions when Performance Event Select Register (PERF_CTL[3:0]) MSRC001_000[3:0][EventSelect] is 0CCh. This erratum applies to all unit mask settings for this event.",
        "implication": "Performance monitoring software will not have an accurate count of fastpath double operation instructions.",
        "workaround": "None.",
        "status": "No",
        "errnum": "393"
    },
    {
        "title": "Incorrect Data Masking in Ganged DRAM Mode",
        "problem": "The DRAM controller may apply incorrect DRAM data masks when operating in ganged mode (DRAM Controller Select Low Register[DctGangEn] (F2x110[4]) is set to 1b).",
        "implication": "Unpredictable system behavior.",
        "workaround": "The DRAM controllers should only be configured in the unganged mode. BIOS should not set DRAM Controller Select Low Register[DctGangEn] (F2x110[4]). When only a single DCT is in use, DctGangEn is always zero.",
        "status": "Yes",
        "errnum": "395"
    },
    {
        "title": "VLDT Maximum Current Specification Exceeded at HyperTransport\u2122 Link Transfer Rates Up to 2.0 GT/s",
        "problem": "At HyperTransport\u2122 link transfer rates up to 2.0 GT/s, VLDT maximum current (ILDT) may exceed the specified 500 mA per link limit.",
        "implication": "The processor may exceed the design of the power subsystem, resulting in over-current conditions that can lead to a shutdown or voltage droop.",
        "workaround": "For platforms that utilize Gen1 link transfer rates less than or equal to 2.0 GT/s, refer to the following documents for updated VLDT current specifications: \u2022 AMD Family 10h Server and Workstation Processor Power and Thermal Datasheet, order #43374 revision 3.07 or later \u2022 AMD Family 10h Desktop Processor Power and Thermal Datasheet, order #43375 revision 3.33 or later",
        "status": "No",
        "errnum": "396"
    },
    {
        "title": "VLDT Maximum Current Specification Exceeded on HyperTransport\u2122 Links in Retry Mode",
        "problem": "HyperTransport\u2122 links in retry mode may exceed the 1.4 A per link VLDT maximum current (ILDT) specification.",
        "implication": "The processor may exceed the design of the power subsystem, resulting in over-current conditions that can lead to a shutdown or voltage droop.",
        "workaround": "Refer to the following document for updated VLDT current specifications: \u2022 AMD Family 10h Server and Workstation Processor Power and Thermal Datasheet, order #43374 revision 3.04 or later",
        "status": "No",
        "errnum": "397"
    },
    {
        "title": "HyperTransport\u2122 Links In Retry Mode May Experience High Bit Error Rate At Specific Link and Northbridge Clock Frequencies",
        "problem": "The processor HyperTransport\u2122 link transmit FIFOs may underflow, resulting in bit errors. This erratum only applies when all of the following conditions are satisfied: \u2022 Links are in retry mode. \u2022 The HyperTransport link clock frequency is greater than the northbridge clock frequency. \u2022 The HyperTransport link clock frequency is an odd multiple of 200 MHz. \u2022 LDTSTOP# has not been asserted since the last warm reset.",
        "implication": "The link may fail to train due to multiple bit errors, or experience excessive retries. This behavior may be intermittent.",
        "workaround": "At link and northbridge frequency settings where the erratum applies, system software should subtract 0010b from the four bit value programmed into Link FIFO Read Pointer Optimization Registers F4x1[9C, 94, 8C, 84]_x[DF, CF][7:4] (XmtRdPtr). If the result of the subtraction is negative, truncate it to four bits of precision.",
        "status": "Yes",
        "errnum": "398"
    },
    {
        "title": "Memory Clear Initialization May Not Complete if DCT0 Fails Training",
        "problem": "During DRAM initialization, memory clearing that is initiated by writing 1b to DRAM Controller Select Low Register F2x110[3] (MemClrInit) may fail to complete when all of the following conditions are true: \u2022 All DRAM connected to DCT0 is disabled by system software as a result of a DRAM training failure. \u2022 DRAM connected to DCT1 is successfully trained and enabled by system software. \u2022 DRAM Base System Address Register F1x120[20:0] (DramBaseAddr) is not programmed to 0 when MemClrInit is programmed to 1b.",
        "implication": "If DramBaseAddr is greater than or equal to the total DRAM size on DCT1 and the erratum conditions are satisfied, the system may fail to boot. If DramBaseAddr is less than the total DRAM size on DCT1 and the erratum conditions are satisfied, memory clear initialization will not clear all memory locations on DCT1. If ECC is enabled, this may result in unexpected ECC errors occurring on uninitialized memory.",
        "workaround": "No workaround required if system software skips memory clear initialization and does not use memory on a node when any memory training errors have been reported on that node. System software developers that wish to use memory clear initialization regardless of memory training error status should program DramBaseAddr to 0 before programming MemClrInit to 1b. After completion of memory clear initialization, system software should restore the original value of DramBaseAddr.",
        "status": "No",
        "errnum": "399"
    },
    {
        "title": "APIC Timer Interrupt Does Not Occur in Processor C-States",
        "problem": "An APIC timer interrupt that becomes pending in low-power states C1E or C3 will not cause the processor to enter the C0 state even if the interrupt is enabled by Timer Local Vector Table Entry[Mask], APIC320[16]). APIC timer functionality is otherwise unaffected.",
        "implication": "System hang may occur provided that the operating system has not configured another interrupt source. APIC timer interrupts may be delayed or, when the APIC timer is configured in rollover mode (APIC320[17]), the APIC timer may roll over multiple times in the low-power state with only one interrupt presented after the processor resumes. The standard use of the APIC timer does not make this effect significant.",
        "workaround": "Operating system software should enable another source of timer interrupts, such as the High Precision Event Timer, before it enters the C1 state by executing the HLT instruction and C1E is enabled using Interrupt Pending and CMP-Halt Register[C1eOnCmpHalt or SmiOnCmpHalt] (MSRC001_0055[28:27] are not 00b). For purposes of determining if C1E is enabled, the operating system should not sample MSRC001_0055 until after ACPI has been enabled. Operating system software should enable another source of timer interrupts, such as the High Precision Event Timer, when the processor enters the C3 state. It is possible for the system to implement a hardware fix to C1E mode on some processor revisions and some packages. This is indicated by OSVW[1] and no workaround is necessary when OSVW_Length >= 2 and OSVW[1] is zero. Due to erratum #669, a similar workaround may be required even when OSVW[1] = 0b. An operating system workaround for C3 mode is always necessary, regardless of the setting of OSVW[1].",
        "status": "C1E state: Yes C3 state: No",
        "errnum": "400"
    },
    {
        "title": "HyperTransport\u2122 Link May Fail to Complete Training",
        "problem": "HyperTransport\u2122 links may fail to re-train when resuming from LS2 low-power mode or following a warm reset. The failure may be package-specific and sensitive to longer HyperTransport links that contain multiple connectors.",
        "implication": "System hang.",
        "workaround": "On G34r1 and C32r1 processors, system software should program the Link Global Extended Register[RXCalEn] (F0x16C[9]) to 1b. For Fr5 (1207) and Fr6 (1207) processors, system developers that observe the erratum conditions following warm reset should program the Link Global Extended Register[RXCalEn] (F0x16C[9]) to 1b. For all other processors, system software may program the Link Global Extended Register[RXCalEn] (F0x16C[9]) to 1b. This workaround is not necessary if erratum #351 applies to the processor revision.",
        "status": "No",
        "errnum": "405"
    },
    {
        "title": "Processor Does Not Perform BmStsClrOnHltEn Function",
        "problem": "The processor does not perform a write operation to clear the BM_STS bit when Interrupt Pending and CMP-Halt Register[BmStsClrOnHltEn] (MSRC001_0055[29]) is set.",
        "implication": "The ACPI-defined register BM_STS bit may not be cleared before entry into C1E mode. This does not cause functional issues but may reduce the power saving effectiveness of message-triggered C1E mode.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "406"
    },
    {
        "title": "System May Hang Due to Stalled Probe Data Transfer",
        "problem": "Under highly detailed and specific internal timing conditions, a processor that has one or more processor cores in a cache-flushed state following a C1E exit, and one or more cores executing in C0 state, may not complete a data transfer for a probe.",
        "implication": "System hang.",
        "workaround": "Contact your AMD representative for information on a BIOS update. This workaround requires that Clock Power/Timing Control 2 Register[CacheFlushOnHaltTmr] (F3xDC[25:19]) is greater than 01h, which is true under normal circumstances.",
        "status": "Yes",
        "errnum": "407"
    },
    {
        "title": "Processor AltVID Exit May Cause System Hang",
        "problem": "Under highly detailed and specific internal timing conditions, the processor may hang during an exit from the AltVID state.",
        "implication": "System hang.",
        "workaround": "System software should set Clock Power/Timing Control 0 Register[NbClkDiv] (F3xD4[30:28]) to 100b.",
        "status": "No",
        "errnum": "408"
    },
    {
        "title": "Processor May Exit Message-Triggered C1E State Without an Interrupt if Local APIC Timer Reaches Zero",
        "problem": "If the processor is in the message-triggered C1E state with local APIC Timer Initial Count Register (APIC380[31:0]) non-zero, and the Timer Current Count Register (APIC390[31:0]) transitions to 0, the processor will assert IDLEEXIT_L to request an exit from C1E even if the APIC timer interrupt is masked (Timer Local Vector Table Entry[Mask] (APIC320[16]) is 1b). If the timer interrupt is masked, the processor then enters the C1 state without an interrupt pending.",
        "implication": "This does not cause functional issues but may reduce the power saving effectiveness of message- triggered C1E mode. This would normally occur only if an operating system that has used the local APIC timer masks the interrupt without stopping the counter using the Timer Initial Count Register.",
        "workaround": "When programming APIC320[Mask] to 1b to mask the local APIC timer interrupt, operating system software should program APIC380[31:0] to 0.",
        "status": "No",
        "errnum": "411"
    },
    {
        "title": "Processor May Send Mode Register Set Commands to DDR3 DIMM Incorrectly",
        "problem": "The processor may send a Mode Register Set (MRS) command to a DDR3 DIMM without satisfying the auto-refresh row cycle time programmed at the DRAM Timing High Register F2x[1, 0]8C. In addition, the processor may send an MRS command to a DDR3 DIMM that has an active bank. This erratum applies only when DRAM Configuration High Register F2x[1, 0]94[15] (PowerDownEn) is programmed to 1b, F2x[1, 0]94[Ddr3Mode] is programmed to 1b, and DRAM MRS Register F2x[1, 0]84[23] (PchgPDModeSel) is programmed to 1b.",
        "implication": "For systems without ECC, undefined system behavior that usually results in a system hang. Systems with ECC enabled may experience repeated multiple-bit ECC errors.",
        "workaround": "System software should program F2x[1, 0]84[23] (PchgPDModeSel) to 0b.",
        "status": "No",
        "errnum": "414"
    },
    {
        "title": "HLT Instructions That Are Not Intercepted May Cause System Hang",
        "problem": "In guest mode when VMCB.V_INTR_MASK flag is 1b, the processor may not process host interrupts if a guest executes a HLT instruction that is not intercepted.",
        "implication": "System hang.",
        "workaround": "Hypervisors should intercept HLT instructions by setting VMCB.Intercept_HLT (offset 00Ch bit 24) to 1b.",
        "status": "No",
        "errnum": "415"
    },
    {
        "title": "DRAM Error Injection May Interfere With Power Management Events",
        "problem": "The value in the NB Array Address Register (F3xB8) may change during a stop-clock throttling event, C1E entry or C3 entry. In addition, a non-zero value in F3xB8 may cause a failure during stop-clock throttling or C1E or C3 mode entry.",
        "implication": "Unpredictable system behavior.",
        "workaround": "Diagnostic software should ensure that all power management events are disabled during a DRAM error injection and should restore F3xB8 to zero before resuming these power management functions.",
        "status": "No",
        "errnum": "416"
    },
    {
        "title": "Processor May Violate Tstab for Registered DDR3-1333 DIMMs",
        "problem": "Prior to asserting CKE during self-refresh exit, the processor may not provide a stable MEMCLK for the DIMM Tstab period of 6 microseconds. While MEMCLK is running for over 6 microseconds, one or more missing pulses may exist. The processor provides at least 4.2 microseconds of stable MEMCLK in DDR3-1333 mode, and has no violation at all lower MEMCLK frequencies. This violation only applies to registered DDR3-1333 operation only. This violation does not occur during DRAM initialization. It may occur only when the system exits DRAM self-refresh mode when DLL shutdown is enabled (DRAM Configuration Low Register[DisDllShutdown] (F2x[1,0]90[27]) is 0b).",
        "implication": "No adverse issues have been observed. If a DDR3 DIMM is sensitive to this issue, the system may fail to exit self-refresh.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "417"
    },
    {
        "title": "Host Mapping of Physical Page Zero May Cause Incorrect Translation",
        "problem": "Under highly specific and detailed architectural conditions, the processor may use an incorrect cached copy of translation tables during a SVM nested page translation. This condition requires that the host be in legacy physical address extension (PAE) mode and that the guest address translation tables reside in physical page zero.",
        "implication": "Unpredictable system behavior. This condition has not been observed in any commercially available software.",
        "workaround": "Hypervisor software should not use physical addresses 0 through 4095 for guest pages.",
        "status": "No",
        "errnum": "418"
    },
    {
        "title": "C32r1 Package Processor May Report Incorrect PkgType",
        "problem": "A processor in a C32r1 package may report an incorrect PkgType of 0001b in CPUID Fn8000_0001_EBX[31:28]. This is the package type encoding for AM2r2/AM3 packages instead of the correct C32r1 package type encoding of 0101b.",
        "implication": "Software may incorrectly report the package type and incorrectly initialize package-specific features.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "419"
    },
    {
        "title": "Instruction-Based Sampling Engine May Generate Interrupt that Cannot Be Cleared",
        "problem": "A micro-op that is tagged by the Instruction-Based Sampling (IBS) execution engine shortly before the software clears the IBS Execution Control Register[IbsOpEn] (MSRC001_1033[17]) may create a condition in which the IBS sampling engine continuously generates an interrupt. This condition can exist even if IBS is not re-enabled.",
        "implication": "Processor core may not make forward progress, usually resulting in a system crash or hang.",
        "workaround": "To disable the IBS execution sampling engine, software should first clear IbsOpMaxCnt to 0000h without changing IbsOpEn (write MSRC001_1033 to 00000000_00020000h). After IbsOpMaxCnt is set to zero, software should then perform a second write to clear IbsOpEn.",
        "status": "No",
        "errnum": "420"
    },
    {
        "title": "Performance Monitors for Fence Instructions May Increment Due to Floating-Point Instructions",
        "problem": "The processor may increment the count for LFENCE, SFENCE or MFENCE instructions (Performance Event Select Register (PERF_CTL[3:0]) MSRC001_000[3:0][EventSelect] is 1D3h, 1D4h or 1D5h respectively) when unrelated floating-point operations are executed.",
        "implication": "Performance monitoring software will not have an accurate count of LFENCE, SFENCE, or MFENCE instructions.",
        "workaround": "None.",
        "status": "No",
        "errnum": "421"
    },
    {
        "title": "L3 Cache Performance Events May Not Reliably Track Processor Core",
        "problem": "The following L3 cache performance events may increment for events caused by cores that are not being tracked and may not increment for events caused by cores that are being tracked. \u2022 F4x1C8 L3 Hit Statistics Register. \u2022 EventSelect 4E0h Read Request to L3 Cache when the unit mask is not Fxh. \u2022 EventSelect 4E1h L3 Cache Misses when the unit mask is not Fxh. \u2022 EventSelect 4E2h L3 Fills caused by L2 Evictions when the unit mask is not Fxh. \u2022 EventSelect 4EDh Non-cancelled L3 Read Requests when the unit mask is not Fxh.",
        "implication": "Performance monitoring software may not have an accurate count of the L3 cache accesses caused by a specific program.",
        "workaround": "No workaround exists for F4x1C8. For other performance events, software should use the unit mask setting of Fxh. This setting selects all processor cores. There is no method to track the L3 cache accesses from a single core.",
        "status": "No",
        "errnum": "437"
    },
    {
        "title": "Access to MSRC001_0073 C-State Base Address Results in a #GP Fault",
        "problem": "An access to MSRC001_0073 C-State Base Address will result in a #GP fault.",
        "implication": "BIOS that attempts to enable an I/O C-state will generate an exception.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No",
        "errnum": "438"
    },
    {
        "title": "DQS Receiver Enable Training May Find Incorrect Delay Value",
        "problem": "Under highly specific and internal conditions, the algorithm for DQS Receiver Enable Training may incorrectly place the delay value for the DRAM DQS Receiver Enable Timing Control Register F2x[1,0]9C_x[2B:10] before the read preamble. The conditions under which this erratum may be observed are sensitive to platform memory configurations and the timing between successive training data reads.",
        "implication": "When the DQS Receiver Enable delay is placed before the read preamble, later DQS Position Training failures will result in the DIMM being reported in error due to a training failure. The DIMM may be removed from the configuration.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No",
        "errnum": "439"
    },
    {
        "title": "SMM Save State Host CR3 Value May Be Incorrect",
        "problem": "The processor writes bits 47:32 as 0000h of SMM Save State offset FF38h (Host CR3) when all of the following conditions are met: \u2022 An SMI occurs while in a guest context. \u2022 SMIs are not intercepted to the hypervisor and cause a direct transition from the guest to the SMM code. \u2022 Nested paging is in use (VMCB offset 090h[0], NP_ENABLE, is 1b). \u2022 The SVM Host CR3 address is greater than 4GB (VMCB Offset 0B0h, N_CR3, bits 47:32 are non-zero). \u2022 Guest is not in long mode at the time of the SMI (guest Extended Feature Enable Register EFER[Long Mode Enable], MSRC000_0080[8], is 0b). After the SMM BIOS executes an RSM instruction, the processor may then use this incorrect host CR3 for guest operation.",
        "implication": "Unpredictable system operation.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No",
        "errnum": "440"
    },
    {
        "title": "Move from Stack Pointer to Debug or Control Register May Result in Incorrect Value",
        "problem": "A move from the stack pointer to a debug register or a control register may store a value that does not include one or more updates based on completed pushes, pops, near calls or returns. This erratum does not occur if the instruction encoding uses the standard encoding of ModRM[7:6]=11b to indicate a register-to-register move.",
        "implication": "None expected based on the ModRM[7:6] normally being 11b.",
        "workaround": "Always encode ModRM[7:6]=11b when performing a move into a debug or control register.",
        "status": "No",
        "errnum": "441"
    },
    {
        "title": "Instruction-Based Sampling May Not Indicate Store Operation",
        "problem": "Instruction-Based Sampling (IBS) tagging on certain micro-ops that perform both the load and store operation may only set the IBS Op Data 3 Register[IbsLdOp] (MSRC001_1037[0]) and not IBS Op Data 3 Register[IbsStOp] (MSRC001_1037[1]).",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None.",
        "status": "No",
        "errnum": "443"
    },
    {
        "title": "DDR3-1333 Configurations with Three DIMMs per Channel May Experience Unreliable Operation",
        "problem": "In systems with three DDR3-1333 registered DIMMs on a channel, the processor memory subsystem may exhibit unreliable operation over the allowable voltage ranges.",
        "implication": "Memory system failure, leading to DRAM ECC machine check errors.",
        "workaround": "In a configuration where three registered DDR3-1333 DIMMs are populated on one channel, BIOS should de-rate DDR3-1333 system memory to 533 MHz operation (DDR3-1066) by setting the DRAM Configuration High Register[MemClkFreq] (F2x[1, 0]94[2:0]) to 100b and adjusting memory subsystem timing parameters accordingly.",
        "status": "No",
        "errnum": "459"
    },
    {
        "title": "Processor Thermal Data Sheet Specification Error",
        "problem": "The AMD Family 10h Server and Workstation Processor Power and Thermal Data Sheet, order #43374 for G34r1 and C32r1 OPNs incorrectly documented an \u201cIDD Max\u201d value that was based on current at \u201cThermal Design Power\u201d (TDP). The maximum current for these processors would be properly defined at \u201cMaxPower\u201d and documented as the \u201cThermal Design Current\u201d (TDC).",
        "implication": "None.",
        "status": "Consult the updated AMD Family 10h Server and Workstation Processor Power and Thermal Data Sheet, order# 43374 revision 3.19 or later for corrected values, now listed as TDC.",
        "workaround": "<No field for `workaround`>",
        "errnum": "486"
    },
    {
        "title": "C1E Resume Failure With Certain Registered DIMM Configurations",
        "problem": "Processors may fail to exit self-refresh mode under the following conditions: \u2022 LDTSTOP# is asserted less than 20 uS after it was last deasserted. \u2022 The system configuration includes a processor node having dual or quad rank DDR3 Registered DIMMs on one channel and only single rank or no DIMMs on the other channel. \u2022 The DRAM Configuration Register[MemClkFreq] (F2x94[2:0]) is 100b (DDR3-667) on the aforementioned processor node. \u2022 Message-triggered C1E is enabled (Clock Power/Timing Control 0 Register[MTC1eEn], F3xD4[13] = 1b).",
        "implication": "System hang.",
        "workaround": "System BIOS should program the minimum LDTSTOP# deassertion time to 20 uS. For systems using a SP5100 southbridge, this is accomplished by setting the southbridge LDTStartTime register (PM_Reg:88h) = 14h.",
        "status": "No",
        "errnum": "521"
    },
    {
        "title": "Latency Performance Counters Are Not Accurate",
        "problem": "Latency performance counters MSRC001_000[3:0][7:0] (EventSelect) in the range 1E2h to 1E7h are not accurate when L3 speculative miss prefetching is enabled (F2x1B0[13] = 0b, Extended Memory Controller Configuration Low[SpecPrefDis]).",
        "implication": "Performance monitoring software cannot accurately measure latency events. The reported latency may greatly exceed the actual latency in some instances.",
        "workaround": "No workaround is recommended. Performance monitoring code may set F2x1B0[13] = 1b to collect accurate latency values. This workaround has an impact to overall system performance.",
        "status": "No",
        "errnum": "550"
    },
    {
        "title": "Processor with Message-Triggered C1E Enabled May Report a False L3 LRU or Tag Machine Check",
        "problem": "During an exit from message-triggered C1E state (LDTSTOP# deassertion) that is less than 10 microseconds after the STOPGRANT message, the processor may report a false uncorrectable machine check exception for either an L3 LRU or tag error. The false machine check is due to an L3 stutter scrub happening while the L3 clocks are disabled. L3 stutter scrubs are enabled when Clock Power/Timing Control 0 Register[StutterScrubEn] (F3xD4[15]) is 1b, and BIOS enables this only when message-triggered C1E is enabled. This erratum is exposed only when the minimum time from STOPGRANT message to LDTSTOP# deassertion is violated. However, erratum #669 documents an additional circumstance under which a similar condition may be observed even when the minimum time from STOPGRANT message to LDTSTOP# deassertion is not violated. The BIOS and Kernel Developer\u2019s Guide (BKDG) for AMD Family 10h Processors, order# 31116 documents a minimum time of 16 microseconds between these events.",
        "implication": "Uncorrectable machine check exception (#MC) for an L3 LRU or tag error. The MC4_STATUS register (MSR0000_0411) is either FCxx21x0_001D010B or FCxx21x0_001E010B. Bit 62 (error overflow) and bits 43:42 (L3 subcache) of MC4_STATUS may or may not be set. This machine check also causes a sync flood and reboot, unless these mechanisms have been disabled.",
        "workaround": "BIOS should set F3x1B8[5] = 1b whenever message-triggered C1E is enabled (Clock Power/Timing Control 0 Register[MTC1eEn], F3xD4[13] = 1b) to remove the conditions under which the improper scrub can occur. Implementation of this workaround does not alter the required minimum time from STOPGRANT message to LDTSTOP# deassertion.",
        "status": "No",
        "errnum": "610"
    },
    {
        "title": "SB-RMI Writes May Not Be Observed by Processor",
        "problem": "After a write using the APML SB-RMI interface to either the Inbound Message Registers (SBRMI_x3[F:8]) or Software Interrupt Register (SBRMI_x40), the processor may observe the previous contents (as if the write did not occur) when reading these same registers using the SBI Address/Data registers (F3x1E8 and F3x1EC). The conditions under which this erratum may occur requires that message-triggered C1E is enabled (F3xD4[13] = 1b, Clock Power/Timing Control 0[MTC1eEn]). The functionality of the SB-RMI interface is not otherwise affected.",
        "implication": "Software running on the processor is not able to properly receive messages from system management software using the SB-RMI interface.",
        "workaround": "None. In the event that system management software needs to communicate with software running on the processor, an alternative mechanism should be used.",
        "status": "No",
        "errnum": "625"
    },
    {
        "title": "Processor May Increment CPU Watchdog Timer at an Incorrect Rate",
        "problem": "The rate at which the CPU watchdog timer counter increments may be significantly higher than the rate specified in the CPU Watchdog Timer Register[CpuWdtCountSel, CpuWdtCountBase] (MSRC001_0074[6:3 and 2:1]).",
        "implication": "The CPU watchdog timer, if enabled, may report a machine check earlier than the northbridge watchdog timer, possibly leading to incorrect failure analysis on the cause of a hang. While the CPU watchdog timer may expire at a faster rate, the increased rate is not expected to lead to a false machine check.",
        "workaround": "BIOS should not enable the CPU watchdog timer. MSRC001_0074[CpuWdtEn, bit 0] should remain at its reset value of 0b.",
        "status": "No",
        "errnum": "643"
    },
    {
        "title": "Local Vector Table Interrupt May Cause C1E Entry Without Caches Flushed",
        "problem": "An interrupt assigned to the APIC local vector table (LVT) that becomes pending in a short interval around entry to C1E mode may cause the processor to incorrectly enter C1E mode after storing the interrupt vector but before executing the first instruction of the interrupt handler. When this occurs, the processor is in C1E mode while the processor caches are not flushed. I/O activity that occurs while in C1E mode may cause additional and unexpected core clock frequency changes in order to probe these caches. A short LDTSTOP# assertion time may create a condition where the processor cores are still performing clock frequency changes when LDTSTOP# is de- asserted, even when the LDTSTOP# assertion time is greater than the minimum required assertion time. The interrupt handler for this LVT interrupt is only processed after the processor exits C1E mode for another interrupt.",
        "implication": "A system hang may be observed if the operating system enters C1 state (by execution of the HLT instruction) with only a one-shot APIC timer interrupt configured, since the processor is in C1E state until another interrupt occurs. A system hang has not been observed in silicon. The standard use of these interrupts, including the APIC timer, does not expose this effect. LVT interrupts may be delayed while the processor is in C1E low-power state. The standard use of these interrupts, including the APIC timer, does not make this effect significant. In addition, if LDTSTOP# is de-asserted while the processor is performing additional and unexpected core clock frequency changes due to the additional cache probing caused by this erratum, the conditions described in erratum #610 may be observed. Unless the BIOS or system software has applied the suggested workaround of erratum #610 (i.e. F3x1B8[5] is 0b), then the processor may generate an uncorrectable machine check exception (#MC) and a possible sync flood due to a falsely reported L3 LRU or tag error. Refer to erratum #610 for the MC4_STATUS signature of this machine check.",
        "workaround": "Contact your AMD representative for information on a BIOS update. Implementing this workaround does not alter the minimum LDTSTOP# assertion time.",
        "status": "No",
        "errnum": "669"
    },
    {
        "title": "Segment Load May Cause System Hang or Fault After State Change",
        "problem": "Under a highly specific and detailed set of conditions, a segment load instruction may cause a failure in one of the following instructions later in the instruction stream: \u2022 BTC mem, imm8 \u2022 BTC mem, reg \u2022 BTR mem, imm8 \u2022 BTR mem, reg \u2022 BTS mem, imm8 \u2022 BTS mem, reg \u2022 RCL mem, cl \u2022 RCL mem, imm \u2022 RCR mem, cl \u2022 RCR mem, imm \u2022 SHLD mem, reg, imm \u2022 SHLD mem, reg, cl \u2022 SHRD mem, reg, imm \u2022 SHRD mem, reg, cl \u2022 XCHG mem, reg (uses an implicit LOCK prefix) \u2022 XCHG reg, mem (uses an implicit LOCK prefix) \u2022 Any instruction with an explicit LOCK prefix in the instruction opcode.",
        "implication": "For affected instructions that have an implicit or explicit LOCK prefix, a system hang occurs. For affected instructions that do not have an implicit or explicit LOCK prefix, the processor may present a #PF exception after some of the instruction effects have been applied to the processor state. No system effect is observed unless the page fault handler has some dependency on this interim processor state, which is not the case in any known operating system software. This interim state does not affect the ability for the operating system to handle the #PF and resume the instruction without impact to the program. However, this interim state may be observed by a debugger or if the operating system changes the #PF to a program error (for example, a segmentation fault).",
        "workaround": "System software should set MSRC001_1020[8] = 1b. \u2020This workaround ensures that instructions with an implicit or explicit LOCK prefix do not cause a system hang due to this erratum. However, instructions may still present a #PF after altering architectural state.",
        "status": "No",
        "errnum": "670"
    },
    {
        "title": "TLB Flush Filter May Cause Coherency Problem in Multicore Systems",
        "problem": "Under highly specific internal timing conditions in system configurations that include more than one processor core, coherency problems may arise between the page tables in memory and the translations stored in the on-chip TLBs. This can result in the possible use of stale translations even after software has performed a TLB flush.",
        "implication": "Unpredictable system failure. This scenario has only been observed in a highly randomized synthetic stress test.",
        "workaround": "In multicore systems, disable the TLB flush filter by setting HWCR.FFDIS (bit 6 of MSRC001_0015).",
        "status": "No",
        "errnum": "122"
    },
    {
        "title": "CLFLUSH to Shadow RAM Address Will Not Invalidate",
        "problem": "WrDram and RdDram bits in extended MTRR type registers are used to copy BIOS ROM to corresponding DRAM and then execute out of DRAM. When these are configured to direct writes to ROM (WrMem =0b) and reads to DRAM (RdMem =01b), the CLFLUSH instruction will not invalidate shadow RAM addresses in the cache.",
        "implication": "CLFLUSH instruction will be ineffective for shadow RAM space.",
        "workaround": "Use the WBINVD instruction instead of CLFLUSH in shadow RAM space.",
        "status": "No",
        "errnum": "144"
    },
    {
        "title": "Instruction Break Point On VMRUN Instruction Leads To Unpredictable System Behavior",
        "problem": "VMRUN can be interrupted using a hardware instruction breakpoint using one of the debug registers, DR[0-3]. When the debug handler executes IRET, the processor is expected to execute the VMRUN instruction. However, in the failing case, the processor incorrectly re-enters the breakpoint handler with mixed guest and host state. This in turn causes erroneous execution and leads to unpredictable system behavior.",
        "implication": "Hypervisor developers will not be able to use hardware instruction break point on VMRUN instruction.",
        "workaround": "Set the breakpoint on the instruction prior to VMRUN, then single step through VMRUN.",
        "status": "No",
        "errnum": "171"
    },
    {
        "title": "Misaligned I/O Reads That Span CFCh Incorrectly Generate a Downstream I/O Request",
        "problem": "When configuration space is enabled, IOCF8[31] is 1b, an I/O read to address CFCh should result in a configuration request to the address specified in register IOCF8. However, when a misaligned downstream double word I/O read spans address CFCh the northbridge (NB) correctly sends an I/O read requests to CF8h with appropriate byte enables to the device attached to the I/O link, but incorrectly sends an I/O read request to CFCh instead of the configuration request.",
        "implication": "None expected.",
        "workaround": "Software should not issue misaligned read requests to I/O addresses that span address CFCh.",
        "status": "No",
        "errnum": "230"
    },
    {
        "title": "I/O Reads That Span 3BBh May Be Positively Decoded When They Should Not Be Positively Decoded",
        "problem": "The northbridge enables positive decode within the first 64K of I/O space mapped by the I/O base/ limit registers (F1xC0/C4) for the legacy VGA registers when F1xC0[4] (VE) is 1b and F1xF4[0] (VE) is 0b, i.e. accesses in which address bits[9:0] range from 3B0h to 3BBh or 3C0h to 3DFh and address bits[24:16] are all 0. However, if an I/O read spans address 3BBh, the northbridge will positive decode the entire access including the addresses outside the legacy VGA register space (i.e. 3B[C:E]h).",
        "implication": "A downstream request to I/O addresses 3B[C:E]h may not properly set the Compat bit. This may result in the packet not being forwarded to the compatibility bus.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "250"
    },
    {
        "title": "Northbridge Flow Control Credits May Be Lost Due to Watchdog Time Out",
        "problem": "A peer to peer or CPU transaction that times out in the northbridge due to a Watchdog time out may result in lost flow control credits. In addition, a master abort is not sent for peer to peer transactions that time out in the northbridge due to a Watchdog time out.",
        "implication": "The system may hang.",
        "workaround": "None. The watchdog time out is correctly reported as a MCA exception.",
        "status": "No",
        "errnum": "251"
    },
    {
        "title": "Logged Sync Error Results in Error Overflow Being Set",
        "problem": "When a sync error is logged in MC4_STATUS (MSR411), an error overflow is always indicated by MC4_STATUS[Over] (MSR411[62]) being set to 1b.",
        "implication": "None.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "272"
    },
    {
        "title": "Write To A F4x184 Register May Access Incorrect Array Register",
        "problem": "The contents of the Link Phy Offset Register (F4x180) may be used at the time of the write into the Link Phy Data Port register (F4x184) to determine which set of registers is being accessed. Since the software does not write F4x180 until after F4x184 when performing an array write operation, this may result in the array write not occurring or going to an unpredictable array register.",
        "implication": "Unpredictable results may occur.",
        "workaround": "The registers accessed by F4x184_x[N:0] can be split into four spaces 1. Direct map registers (When DirectMapEn is 1b) 2. Link FIFO Read Pointer Optimization Registers (offsets CFh and DFh) 3. BIST registers (offsets 100h to 144h) 4. Phy registers (offset E0h) Before performing a write to a F4x184_x[N:0] array register, when the value (i.e. from a previous access) in LinkPhyOffset or DirectMapEn maps to a different space (as defined above), software should first perform a read operation to the intended array register. No workaround is necessary when performing an array read access or when no space switch is involved.",
        "status": "No",
        "errnum": "288"
    },
    {
        "title": "Northbridge Will Not Raise an MCA Exception Unless Status Bits Are Cleared",
        "problem": "A machine check (MCA) exception is not raised if the Northbridge detects an overflow condition. An overflow condition exists if there is already an enabled uncorrectable machine check exception in the Northbridge MCA status register at the time that a second uncorrectable error is detected.",
        "implication": "The system will not enter the shutdown state if another uncorrectable error occurs prior to the MCA handler clearing the Northbridge MCA status register.",
        "workaround": "None.",
        "status": "No",
        "errnum": "305"
    },
    {
        "title": "Reset Occurring Near a Dynamic Link Frequency Change May Cause System Failures",
        "problem": "System failure can occur if reset is asserted while an LDTSTOP disconnect is in process for a Centralized Dynamic Link Frequency (CDLF) change and the HyperTransport\u2122 link is operating at a speed of 1000 MHz or lower (Gen1).",
        "implication": "The system may fail to reset.",
        "workaround": "CDLF should not be used in conjunction with Gen1 frequency speeds.",
        "status": "No",
        "errnum": "307"
    },
    {
        "title": "Certain Clock Divisors May Result in Unpredictable System Behavior",
        "problem": "The processor may violate internal timing requirements at certain core clock divisors. This may occur if software modifies the CpuFid in the P-state registers (MSRC001_00[6B:64][5:0]) or when core clocks are ramped due to P-state transitions in response to writes to the P-state Control register (MSRC001_0062), HTC, or Halt instruction execution.",
        "implication": "Unpredictable system behavior.",
        "workaround": "Contact your AMD representative for information on a BIOS update. In addition, software should not modify the P-state registers (MSRC001_00[6B:64]), or the HtcPstateLimit (F3x64[30:28]), from their reset values.",
        "status": "No",
        "errnum": "311"
    },
    {
        "title": "Incorrect CpuDid May Be Applied During ACPI States",
        "problem": "The processor may use an incorrect core clock divisor if it enters or exits the HTC-active state in a narrow window of time after it has applied the CpuDid for an ACPI power state transition. Under these conditions, the CpuDid from the current P-state as indicated by CurPstate (MSRC001_0063[2:0]) is used rather than the CpuDid from the ACPI power state.",
        "implication": "Unpredictable system behavior may result if an alternate voltage (altvid) is enabled for the ACPI power state, for example in C1E, and the CpuDid applied is less than that specified for the ACPI power state.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No",
        "errnum": "316"
    },
    {
        "title": "Alternative Voltage Is Not Supported",
        "problem": "The processor may function improperly when the alternative voltage (altvid) is applied.",
        "implication": "Unpredictable system behavior.",
        "workaround": "System software should not enable the alternative voltage through the Power Management Control Low Register[PMM1[CpuAltVidEn]] (F3x80[12]) or Power Management Control Low Register[PMM3[CpuAltVidEn]] (F3x80[28]). In addition, system software should not enable the alternative voltage through the LMM Configuration Register[LmmCpuAltVidEn] (F4x174_x[0F:00][17]) when using centralized link management.",
        "status": "No",
        "errnum": "332"
    },
    {
        "title": "Improper DIMM On-Die Termination Signaling May Occur",
        "problem": "Certain memory configurations may cause improper DIMM on-die termination (ODT) signaling when the AMD recommended settings for DCT ODT Control (D18F2x[1,0]F4_x180 and D18F2x[1,0]F4_x182) are not used. The AMD recommended values for D18F2x[1,0]F4_x180 and D18F2x[1,0]F4_x182 are provided in the BIOS and Kernel Developer\u2019s Guide (BKDG) for AMD Family 12h Processors, order# 41131.",
        "implication": "Unreliable DRAM signaling.",
        "workaround": "D18F2x[1,0]F4_x180 and D18F2x[1,0]F4_x182 should remain at the AMD recommended values.",
        "status": "No",
        "errnum": "366"
    },
    {
        "title": "Processor May Not Recognize A20M# Change During CC6",
        "problem": "A processor core that is in Core C6 (CC6) state at the time that A20 Mask (A20M#) changes state may continue to operate using the previous A20M# value after CC6 exit.",
        "implication": "None expected. Since no multi-core operating system uses A20M#, state changes during CC6 state are not expected.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "430"
    },
    {
        "title": "DEV Error May Be Erroneously Logged After a Warm Reset",
        "problem": "An uncorrectable DMA Exclusion Vector (DEV) table walk error may erroneously be logged if a warm reset is initiated while a DEV table walk is in progress.",
        "implication": "A false uncorrectable error may be reported to system software.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "432"
    },
    {
        "title": "First MRS Command After DRAM Initialization May Time-out",
        "problem": "The first DIMM Mode Register Set (MRS) command after DRAM Initialization Register[EnDramInit] (D18F2x[1,0]7C[31]) is set may take up to 2.5 ms to complete.",
        "implication": "BIOS time-out may occur resulting in a boot failure.",
        "workaround": "BIOS must use a time-out value greater than 2.5 ms for the MRS command sequence.",
        "status": "No",
        "errnum": "465"
    },
    {
        "title": "Warm Reset May Cause System Hang",
        "problem": "The processor may hang if a warm reset occurs while a register access to any of the PCI Express\u00ae controllers' internal registers is in progress. The processor may perform register accesses for internal management purposes that are transparent to software.",
        "implication": "System hang.",
        "workaround": "System BIOS should set D0F0xE4_x013[2:0]_8063 bits 4, 5, 12, 13 and 14 to 1b. This must be done early in the BIOS boot sequence to minimize the possibility of a hang due to a warm reset during the boot sequence. During a link reconfigure operation, system BIOS must perform the following steps: 1. Clear D0F0xE4_x013[2:0]_8063 bits 4, 5, 12, 13 and 14 to 0b. 2. Perform the link reconfigure operation. 3. Set D0F0xE4_x013[2:0]_8063 bits 4, 5, 12, 13 and 14 to 1b.",
        "status": "No",
        "errnum": "470"
    },
    {
        "title": "Memory Clear Feature May Use Non-Zero Pattern",
        "problem": "During a memory clear function (DRAM Controller Select Low Register[MemClrInit], D18F2x110[3]), the processor may not use zeros as the write pattern.",
        "implication": "Memory is not cleared to zeros. This may lead to boot failure if BIOS assumes that unused memory is cleared.",
        "workaround": "Before performing the memory clear function, BIOS should use the continuous pattern generator to perform a cache line write of zeros, followed by a read of the cache line. Consult the read and write pattern generation algorithms in the BIOS and Kernel Developer\u2019s Guide (BKDG) for AMD Family 12h Processors, order# 41131.",
        "status": "No",
        "errnum": "474"
    },
    {
        "title": "IBS Registers May Be Unpredictable After CC6 State",
        "problem": "The following Instruction-Based Sampling (IBS) registers may be unpredictable after the processor core exits the core C6 (CC6) state: \u2022 Read-only bits MSRC001_1030 IBS Fetch Control Register \u2022 MSRC001_1031 IBS Fetch Linear Address Register \u2022 MSRC001_1032 IBS Fetch Physical Address Register \u2022 MSRC001_1034 IBS Op Logical Address Register \u2022 MSRC001_1035 IBS Op Data Register \u2022 MSRC001_1036 IBS Op Data 2 Register \u2022 MSRC001_1037 IBS Op Data 3 Register \u2022 MSRC001_1038 IBS DC Linear Address Register \u2022 MSRC001_1039 IBS DC Physical Address Register \u2022 MSRC001_103B IBS Branch Target Address Register When IBS is not enabled at the time that the processor core enters CC6 state, the erratum conditions do not apply.",
        "implication": "In cases where the performance monitoring software fetches the IBS sampled data and the processor core has entered the CC6 state since this sample, the performance monitoring software may observe unpredictable values and may generate inaccurate results. The performance monitoring software would normally consume the sampled IBS data before a CC6 entry occurs, resulting in no observed effect under normal conditions.",
        "workaround": "Performance monitoring software should avoid entering ACPI sleep states (C1/HALT or C2) prior to accessing the IBS registers.",
        "status": "No",
        "errnum": "541"
    },
    {
        "title": "Processor May Fail to Set Auto-Halt Restart in SMM Save State",
        "problem": "The processor core may not set the auto-halt restart flag (offset FEC9h of the SMM save state area) when a HLT instruction causes the processor core to enter the core C6 (CC6) state and is then interrupted by an SMI. After the SMM code executes the RSM instruction, the processor core does not re-enter the HLT or CC6 state due to this incorrect auto-halt restart flag.",
        "implication": "The processor may continue execution after the HLT instruction, resulting in unpredictable system behavior. The operating system is not required to have a valid instruction after a HLT instruction when rFLAGS.IF = 1.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No",
        "errnum": "564"
    },
    {
        "title": "Processor Cores Observe Separate IBS Control Registers",
        "problem": "The processor implements the IBS Control Register as multiple registers, one per processor core. A read of this register using either MSRC001_103A or D18F3x1CC from one processor core may not observe a write to D18F3x1CC that has been performed by another processor core.",
        "implication": "Performance monitoring software using Instruction-Based Sampling (IBS) may incorrectly detect that no Local Vector Table (LVT) has been assigned to the IBS interrupt.",
        "workaround": "BIOS should write D18F3x1CC to the same value using all enabled processor cores. System software is not expected to modify the BIOS value, although in the event that system software writes D18F3x1CC, it must also write D18F3x1CC using all processor cores.",
        "status": "No",
        "errnum": "565"
    },
    {
        "title": "Processor May Incorrectly Update Instruction Pointer After FSINCOS Instruction",
        "problem": "After execution of an FSINCOS instruction, the processor core may incorrectly update the instruction pointer (rIP) and execute incorrect instructions or may hang.",
        "implication": "Unpredictable system behavior after execution of an FSINCOS instruction.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No",
        "errnum": "573"
    },
    {
        "title": "Northbridge Clock Gating May Lead to Invalid Prefetched Data",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the northbridge may gate the clock (NCLK) to the In-Flight Queue (IFQ) while a DRAM prefetch caused by a CPU fetch is still outstanding. This may result in the prefetch buffer being marked valid but with unpredictable data. IFQ clock gating is performed only when no cores are in C0 state.",
        "implication": "Unpredictable system behavior. This has not been observed with any commercially available software.",
        "workaround": "BIOS should not set Clock Power/Timing Control 2 Register[NbClockGateEn] (D18F3xDC[30]) and leave this bit at its reset value of 0b.",
        "status": "No",
        "errnum": "596"
    },
    {
        "title": "Processor May Hang While Performing Voltage Transitions Overlapping with C-state Requests",
        "problem": "A processor may hang while performing overlapping voltage transitions and C-state requests. The hang may result when one of the following conditions occurs: \u2022 The processor performs a core performance boost (CPB) transition that requires a voltage transi- tion just prior to a core entering C1 state (HLT instruction or I/O C-state based). Prior to this volt- age transition completing, the processor core transitions from C1 to C0 state and another C-state is requested by software. This new C-state flushes the processor caches and performs core C6 (CC6) clock gating. \u2022 The processor performs a hardware thermal control (HTC) transition that requires a voltage tran- sition just prior to a core entering C1 state (HLT instruction or I/O C-state based). Prior to this voltage transition completing, the processor core recognizes a second HTC transition and the pro- cessor core transitions from C1 to C0 state and another C-state is requested by software. This new C-state flushes the processor caches and performs core C6 (CC6) clock gating. The hang is possible only if the initial voltage transition has not completed by the time the CC6 clock gating occurs.",
        "implication": "Processor core hang",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No",
        "errnum": "662"
    },
    {
        "title": "Integer Divide Instruction May Cause Unpredictable Behavior",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor core may abort a speculative DIV or IDIV integer divide instruction (due to the speculative execution being redirected, for example due to a mispredicted branch) but may hang or prematurely complete the first instruction of the non-speculative path.",
        "implication": "Unpredictable system behavior, usually resulting in a system hang.",
        "workaround": "BIOS should set MSRC001_1029[31]. This workaround alters the DIV/IDIV instruction latency specified in the Software Optimization Guide for AMD Family 10h and 12h Processors, order# 40546. With this workaround applied, the DIV/IDIV latency for AMD Family 12h Processors are similar to the DIV/IDIV latency for AMD Family 10h Processors.",
        "status": "No",
        "errnum": "665"
    },
    {
        "title": "Processor Does Not Implement MSRC001_0055",
        "problem": "The processor does not properly allow writes to MSRC001_0055 (Interrupt Pending Register). A write to MSRC001_0055 is ignored and a read to the register returns zero.",
        "implication": "BIOS is unable to program this register.",
        "workaround": "Contact your AMD representative for a BIOS workaround.",
        "status": "No",
        "errnum": "686"
    },
    {
        "title": "LAR and LSL Instructions Do Not Check Invalid Long Mode Descriptor Types",
        "problem": "The architecture specifies that the processor checks for invalid descriptor types when a Load Access Rights Byte (LAR) instruction or a Load Segment Limit (LSL) instruction is executed in long mode. An invalid descriptor type should cause the processor to clear the zero flag (ZF) and complete the instruction without modifying the destination register. However, the processor does not perform this check and loads the attribute (LAR) or segment limit (LSL) as if the descriptor type was valid. The invalid descriptor types for LAR are 1 (available 16-bit TSS), 3 (busy 16-bit TSS), 4 (16-bit call gate) or 5 (task gate). The invalid descriptor types for a LSL instruction are types 1 (available 16-bit TSS) or 3 (busy 16-bit TSS).",
        "implication": "None expected, since the operating system code would typically only provide legal descriptors. However, in the case of erroneous software, the above described check would not be performed, resulting in unpredictable system failure. AMD has not observed this erratum with any commercially- available software.",
        "workaround": "None required, it is anticipated that long mode operating system code ensures that the descriptor type is legal when executing LAR and LSL instructions.",
        "status": "No",
        "errnum": "700"
    },
    {
        "title": "AD631XOJZ43GX Incorrectly Reports a Maximum Rate of DDR3-1600",
        "problem": "OPN AD631XOJZ43GX (65W FM1 AMD Athlon\u2122 II X4 631X Quad-Core Processor) may incorrectly report a maximum DDR transfer rate of 1600 MT/s. The actual maximum transfer rate of this OPN should be 1866 MT/s. Northbridge Capabilities Register[DdrMaxRate], D18F3xE8[7:5] may be equal to 001b, indicating DDR3-1600. The correct value should be 000b.",
        "implication": "The BIOS may incorrectly limit the DDR rate with DDR3-1866 DIMMs to 1600 MT/s.",
        "workaround": "No workaround is necessary with DDR3-1600 (or lower) DIMMs, on a FS1 motherboard, or on a FM1 motherboard that has two DIMM slots per channel. System developers with an FM1 motherboard that has only one DIMM slot per channel and that use this OPN with DDR3-1866 DIMMs may require a workaround. To implement a workaround, platform BIOS replaces the actual reported value in the Northbridge Capabilities Register[DdrMaxRate] field (D18F3xE8[7:5]) with 000b if the above affected processor type (OPN) is detected. The affected OPN can be uniquely identified if all of the following characteristics are true: \u2022 CPUID Fn0000_0001_EAX = 00300F10h (LN-B0) \u2022 CPUID Fn8000_0001_EBX BrandId Identifier[PkgType, bits 31:28] = 0010b (FM1) \u2022 D18F3xA0[27:16] = 02Ah",
        "status": "Yes",
        "errnum": "710"
    },
    {
        "title": "Processor May Hang During PCIe\u00ae Initialization",
        "problem": "The processor may hang during BIOS boot on a downstream transaction to a PCIe\u00ae interface.",
        "implication": "System hang during BIOS boot.",
        "workaround": "Contact your AMD representative for a BIOS workaround.",
        "status": "No",
        "errnum": "711"
    },
    {
        "title": "Processor May Incorrectly Update Stack Pointer",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor may incorrectly update the stack pointer after a long series of push and/or near-call instructions, or a long series of pop and/or near-return instructions. The processor must be in 64-bit mode for this erratum to occur.",
        "implication": "The stack pointer value jumps by a value of approximately 1024, either in the positive or negative direction. This incorrect stack pointer causes unpredictable program or system behavior, usually observed as a program exception or crash (for example, a #GP or #UD).",
        "workaround": "System software may set MSRC001_1029[0] = 1b.",
        "status": "No",
        "errnum": "721"
    },
    {
        "title": "Incorrect APIC Remote Read Behavior",
        "problem": "The processor may provide incorrect APIC register data on an APIC remote register read. A remote read is performed using Interrupt Command Register Low[MsgType] of 011b (APIC300[10:8]). The processor may, but does not always, provide an error indication in the remote read status field (APIC300[17:16]). This erratum does not impact the use of remote APIC reads by BIOS during early power-on-self-test (POST) when the remote read is performed for addresses APIC300-APIC3F0.",
        "implication": "None expected, as it is anticipated that no software other than BIOS uses remote APIC reads.",
        "workaround": "Software should not use remote APIC reads.",
        "status": "No",
        "errnum": "725"
    },
    {
        "title": "Performance Counters Do Not Accurately Count Memory Turnaround Time",
        "problem": "Write-to-read and read-to-write memory controller turnaround events are not accurately counted by PMCx0E3 (Memory Controller Turnarounds).",
        "implication": "Performance monitoring software will not be able to accurately itemize the DRAM bandwidth used for turnaround events.",
        "workaround": "None.",
        "status": "No",
        "errnum": "433"
    },
    {
        "title": "Processor May Violate Twr for Precharge Commands",
        "problem": "The processor may violate Twr for precharge commands when self-refresh commands are pending.",
        "implication": "Unpredictable system behavior.",
        "workaround": "When converting the DIMM timing parameter for Twr to the encoded Twr value in the DRAM MRS Register[Twr] (D18F2x84[6:4], BIOS should add one MEMCLK to the number of clocks required.",
        "status": "No",
        "errnum": "434"
    },
    {
        "title": "Precharge Failure After Self Refresh Exit",
        "problem": "Under a highly specific and detailed set of internal timing conditions, a processor may open a DRAM page that is already open. This may occur if a northbridge P-state transition occurs shortly after a self- refresh exit, and results in inconsistent memory controller state.",
        "implication": "Unpredictable system behavior, usually leading to a system hang.",
        "workaround": "BIOS should clear DRAM Configuration High[PowerDownMode] (D18F2x94[16]) to 0b.",
        "status": "No",
        "errnum": "435"
    },
    {
        "title": "Certain GPU and Northbridge Clock Combinations May Result in Unpredictable System Behavior",
        "problem": "The processor may violate internal timing requirements at certain clock combinations of LCLK and NCLK. No violation occurs at boot and will not occur until both LCLK and NCLK exceed 200 MHz.",
        "implication": "Unpredictable system behavior.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No",
        "errnum": "455"
    },
    {
        "title": "CLFLUSH Instruction to I/O Address May Cause System Hang",
        "problem": "Under a highly specific and detailed set of conditions, a CLFLUSH instruction to an I/O address may not properly deallocate an internal buffer used for cache operations.",
        "implication": "System hang may occur after repetitive occurrences.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No",
        "errnum": "461"
    },
    {
        "title": "Low Power Drive Strength May Use Improper Calibration Code",
        "problem": "During a self-refresh operation, a simultaneous DDR calibration code update may latch incorrect data used to calibrate the low power drive strength.",
        "implication": "The DRAM may incorrectly sense a CKE transition during self-refresh mode. This causes the DRAM to prematurely exit from self-refresh mode, leading to the loss of memory contents.",
        "workaround": "BIOS normally programs the Phy Calibration Configuration Register[DisAutoComp] (D18F2x9C_x0D0F_E003[14]) to 1b when performing the Phy Compensation Initialization sequence as described in the BIOS and Kernel Developer\u2019s Guide (BKDG) for AMD Family 14h Models 00h- 0Fh Processors, order# 43170. As a workaround to this erratum, BIOS should not re-enable the auto- compensation after this sequence and should keep DisAutoComp=1.",
        "status": "No",
        "errnum": "473"
    },
    {
        "title": "Northbridge Instruction-Based Sampling Fields Are Not Sampled for Write-Combining Operations",
        "problem": "The IBS Op Data 2 Register (MSRC001_1036) does not provide valid status when an access to write- combining (WC) memory is tagged (IBS Op Data 3 Register[IbsDcWcMemAcc], MSRC001_1037[13], is 1b).",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None.",
        "status": "No",
        "errnum": "484"
    },
    {
        "title": "Potential Violation of Read Ordering Rules Between Semaphore Operation and Subsequent Load Operations",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the memory read ordering between a semaphore operation and a subsequent load operation may be incorrect and allow the load operation to operate on the memory location ahead of the completion of the semaphore operation.",
        "implication": "In the unlikely event that the condition described above occurs, the load operation (in the critical section) may operate on data that existed prior to the semaphore operation.",
        "workaround": "BIOS should set MSRC001_1020[36].",
        "status": "No",
        "errnum": "530"
    },
    {
        "title": "Processor May Not Forward Data From Store to a Page Crossing Read-Modify-Write Operation",
        "problem": "A read-modify-write operation that crosses a page boundary may not see the results of a previous store.",
        "implication": "Unpredictable system behavior.",
        "workaround": "BIOS should set MSRC001_1020[25].",
        "status": "No",
        "errnum": "551"
    },
    {
        "title": "Processor May Incorrectly Forward Data with Non-cacheable Floating-Point 128-bit SSE Operation",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor may perform a non-cacheable floating-point 128-bit SSE instruction and forward the data from this instruction to a nearby unrelated non-cacheable load.",
        "implication": "No effect is expected under normal system operation, as software that performs floating-point 128-bit SSE instructions to non-cacheable memory types (CD, UC, or WC) is not anticipated. Under the highly unlikely circumstances that this software exists, unpredictable system behavior may occur due to the incorrect forwarding of data.",
        "workaround": "BIOS should set MSRC001_1020[18].",
        "status": "No",
        "errnum": "560"
    },
    {
        "title": "Processor May Incorrectly Walk Page Tables in I/O or Non- Cacheable Memory",
        "problem": "When HWCR[TlbCacheDis] (MSRC001_0015[3]) is 1b and the page tables reside in I/O or DRAM that is marked non-cacheable, the processor may incorrectly perform page table walks.",
        "implication": "Unpredictable system behavior.",
        "workaround": "None required. No operating system places page tables in memory that is not marked as WB DRAM, and therefore HWCR[TlbCacheDis] can always be at its reset state of 0b.",
        "status": "No",
        "errnum": "561"
    },
    {
        "title": "Processor Executing VMRUN to Interrupt Shadow Instruction May Lose a Breakpoint",
        "problem": "The processor may not recognize a code breakpoint #DB exception when all of the following conditions are true: \u2022 The hypervisor is executing a VMRUN instruction with the interrupt shadow field set (VMCB offset 068h bit 0), specifying that the first guest instruction that is to be executed is in an interrupt shadow. \u2022 The code breakpoint is on this first instruction (the instruction that is in the guest interrupt shadow). \u2022 The global interrupt flag (GIF) for the guest virtual machine is set. \u2022 The global interrupt flag (GIF) for the host is not set.",
        "implication": "None expected under normal conditions. Debug exceptions may not be received for programs running under a hypervisor.",
        "workaround": "None.",
        "status": "No",
        "errnum": "562"
    },
    {
        "title": "Processor May Store Incorrect Resume Flag in VMCB",
        "problem": "A processor core may incorrectly store rFLAGS.RF = 1 in the VMCB when the processor is performing an SVM interception on a CLI instruction, including an intercept on an exception that occurred during execution of the CLI instruction.",
        "implication": "None expected under normal conditions. Instruction breakpoints on CLI instructions may not be received for programs running under a hypervisor.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "563"
    },
    {
        "title": "Branch Prediction May Cause Incorrect Processor Behavior",
        "problem": "Under a highly specific and detailed set of internal timing conditions involving multiple events occurring within a small window of time, the processor branch prediction logic may cause the processor core to decode incorrect instruction bytes.",
        "implication": "Unpredictable program behavior, generally leading to a program exception.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "578"
    },
    {
        "title": "Processor May Generate #GP Exception on CLFLUSH to Execute-Only Code Segment",
        "problem": "The processor generates a #GP exception while executing a CLFLUSH instruction to an execute-only code segment (CS descriptor with Readable attribute bit = 0b, bit 9 of descriptor byte 4). This erratum affects only legacy and compatibility modes, as the readable attribute is deprecated in 64-bit mode.",
        "implication": "Unexpected program (#GP) exception.",
        "workaround": "None expected. CLFLUSH instructions to an execute-only code segment are not normally performed in commercially available software.",
        "status": "No",
        "errnum": "579"
    },
    {
        "title": "Instruction-Based Sampling May Bias Execution Samples",
        "problem": "The Instruction-Based Sampling (IBS) execution samples may be biased and not match expected results: \u2022 The processor execution sample engine may select some instructions at a higher probability than other instructions that have a similar execution frequency. This error may be significant, espe- cially when the code includes floating-point double operations. \u2022 The processor may not perform an IBS sample after the specified number of clock cycles expires (IBS Execution Control[IbsOpCntCtl], MSRC001_1033[19] = 0b). When this occurs, the counter rolls over and the current sample is delayed for some multiple of the counter. This issue has no impact on the more common case of counting dispatched operations instead of clock cycles.",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None. This erratum may prevent the software from obtaining statistically accurate data from IBS execution sampling.",
        "status": "No",
        "errnum": "580"
    },
    {
        "title": "Processor May Perform Incorrect Large Granularity TSS Limit Checking",
        "problem": "After resuming from System Management Mode (SMM), the processor may not scale Task-State Segment (TSS) limits when the TSS descriptor granularity bit (bit 23 of descriptor byte 4) is 1b. The granularity (G) bit, when set, indicates that the segment-limit field should be scaled by 4096 bytes.",
        "implication": "Unexpected #GP exception, leading to system crash. This has not been observed with any commercially available operating system.",
        "workaround": "Operating system software must use G=0 for all TSS descriptors. The largest possible size of a TSS descriptor does not require G=1.",
        "status": "No",
        "errnum": "581"
    },
    {
        "title": "Move to CR3 May Cause Unexpected #GP Exception in PAE Mode",
        "problem": "Under highly intermittent internal timing conditions, the processor may incorrectly sense that a reserved bit is set in the Page Directory Pointer Table entries (PDPE), even when no reserved bits are set. The PDPE is checked for reserved bits during a move to CR3 (MOV CR3) instruction. This error is intermittent and observable only when all of the following conditions are met: \u2022 The processor is in legacy mode with physical address extension (PAE) enabled (CR4.PAE = 1). \u2022 The MOV CR3 is the first MOV CR3 instruction executed after a reset or CC6 exit.",
        "implication": "Unexpected #GP exception during a MOV CR3 instruction, leading to a kernel panic or system crash.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No",
        "errnum": "594"
    },
    {
        "title": "Load Effective Address with Stack Pointer May Result in Incorrect Value",
        "problem": "Uncommon usages of the Load Effective Address (LEA) instruction, where the stack pointer is added to one of {R8 .. R15} without a displacement and without a scale applied to that register, may utilize the stack pointer with a value that does not include one or more updates based on completed pushes, pops, near calls or returns. This erratum can occur only when the processor is in 64-bit mode. The following is a complete list of instructions that may observe this incorrect behavior: \u2022 LEA <any destination>, [RSP + R8] \u2022 LEA <any destination>, [RSP + R9] \u2022 LEA <any destination>, [RSP + R10] \u2022 LEA <any destination>, [RSP + R11] \u2022 LEA <any destination>, [RSP + R12] \u2022 LEA <any destination>, [RSP + R13] \u2022 LEA <any destination>, [RSP + R14] \u2022 LEA <any destination>, [RSP + R15]",
        "implication": "Unpredictable system behavior.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "595"
    },
    {
        "title": "Processor May Install Duplicate Entries in L1 TLB",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor may move an entry from the L2 TLB to the L1 TLB that has already been installed in the L1 TLB.",
        "implication": "Uncorrectable machine check exception (MC#) for an L1 TLB Multimatch error. The MC0_STATUS register (MSR0000_0401) is B6000000_00010015h. Bit 62 (error overflow) of MC0_STATUS may or may not be set.",
        "workaround": "BIOS should set MC0_CTL_MASK[6] (MSRC001_0044[6]) = 1b.",
        "status": "No",
        "errnum": "629"
    },
    {
        "title": "LDT or GDT Segment Descriptor Wrapping at 4GB Boundary Causes Incorrect Operation",
        "problem": "In 32-bit protected mode, a segment load using a Local Descriptor Table (LDT) or Global Descriptor Table (GDT) system-segment descriptor with a base/limit that wraps around the 4GB boundary may cause an unexpected page fault.",
        "implication": "None expected, since the operating system typically aligns the GDT/LDT limit such that no descriptors wrap. In the unlikely event that software creates the conditions described, the processor may generate an unexpected page fault (#PF). The address reported in CR2 is zero.",
        "workaround": "None.",
        "status": "No",
        "errnum": "632"
    },
    {
        "title": "Invalid Guest Address in CR3 May Cause System Hang",
        "problem": "The processor may hang when all of the following conditions are met: \u2022 Secure Virtual Machine (SVM) mode is enabled. \u2022 The host is not in long mode (host EFER.LMA is 1). \u2022 The host executes a VMRUN instruction with nested paging enabled (VMCB offset 090h[0], NP_ENABLE, is 1b) and enters a guest that is allowed to go into long mode. \u2022 The guest loads a Page-Map Level-4 Table Base Address into CR3 that is above 4GB. Since the host is not in long mode, the guest's address space is already limited to 4GB (the maximum size of the virtual address allowed in the host). Therefore, the guest is loading an illegal address into CR3.",
        "implication": "System hang. This has not been observed with any commercially available hypervisor.",
        "workaround": "Hypervisors that allow long mode guests must also operate in long mode or take steps to avoid the above erratum conditions, such as intercepting all modifications of CR3 to validate the register.",
        "status": "No",
        "errnum": "634"
    },
    {
        "title": "Processor May Have Incorrect Instruction Pointer Following a Specific CALL Instruction Encoding",
        "problem": "Under a highly specific and detailed set of internal timing conditions where the processor has performed at least 100 pushes, pops, near-calls and/or near-returns without executing any other operation that uses the stack pointer, the processor may incorrectly execute the following instruction: \u2022 CALL RSP without any offset (instruction encoding FFD4h). Under the above conditions, the processor does not execute the CALL instruction and instead may treat this instruction as if it is a NOP (no operation) instruction. The processor incorrectly updates the rIP to the address following the CALL. This CALL RSP instruction should transfer instruction execution to the stack (i.e. it changes the rIP to the value that was in the rSP prior to the execution of the instruction). If the stack address is marked with a no-execute attribute (the NX bit is set in the page table), this generates a #GP exception. The stack is commonly marked with a no-execute attribute. As a result, the use of this instruction encoding is uncommon in applications.",
        "implication": "Unpredictable program behavior after incorrectly updating the instruction pointer (rIP). This behavior has not been observed with any commercially available software.",
        "workaround": "Contact your AMD representative for information on a BIOS workaround.",
        "status": "No",
        "errnum": "639"
    },
    {
        "title": "CLTS or LMSW Instruction Executed in Real Mode May Cause Unpredictable Behavior",
        "problem": "Under a highly specific and detailed set of conditions that include operation in real mode (CR0.PE = 0b) or System-Management Mode (SMM), the processor may incorrectly perform a nearby segment load while executing a CLTS instruction or an LMSW instruction that does not change CR0 bits.",
        "implication": "Unpredictable system behavior. This erratum is not expected to occur with any commercially available operating systems or system-management code.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "651"
    },
    {
        "title": "Processor May Cause Unpredictable Program Behavior Under Highly Specific Branch Conditions",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor may incorrectly update the branch status when a taken branch occurs where the first or second instruction after the branch is an indirect call or jump. This may cause the processor to update the rIP (the instruction pointer register) after a not-taken branch that ends on the last byte of an aligned quad-word such that it appears the processor skips, and does not execute, one or more instructions. The new updated rIP due to this erratum may not be at an instruction boundary.",
        "implication": "Unpredictable program behavior, possibly leading to a program error or system error. It is also possible that the processor may hang or recognize an exception (for example, a #GP or #UD exception), however AMD has not observed this effect.",
        "workaround": "BIOS should set MSRC001_1021[14] = 1b and MSRC001_1021[3] = 1b. This workaround is required only when bit 2 of Fixed Errata Status Register (D18F4x164[2]) = 0b.",
        "status": "Yes",
        "errnum": "688"
    },
    {
        "title": "Processor Does Not Check 128-bit Canonical Address Boundary Case on Logical Address",
        "problem": "The processor core may not detect a #GP exception if the processor is in 64-bit mode and the logical address of a 128-bit operation (for example, a octal-word SSE instruction) is canonical on the first byte, but whose final byte crosses over the canonical address boundary. The processor does check the linear address and signals a #GP exception if the linear address is not canonical (for all eight bytes of the operation). Therefore, this erratum can only occur if the segment register is non-zero and causes a wrap in the logical address space only. In the unlikely event that software causes this wrap, the processor core will execute the 128-bit operation as if the second part of the misaligned access starts at linear address equal to zero.",
        "implication": "None expected, as the normal usage of segment registers and segment limits does not expose this erratum.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "737"
    },
    {
        "title": "Debug Exception Concurrent with Unintercepted SMI May Store Incorrect Stack Pointer in VMCB",
        "problem": "During processing of a RSM instruction to return from a system management interrupt (SMI) that occurred while in secure virtual machine (SVM) mode and without the SMI being intercepted, the processor core may not restore the guest stack pointer prior to presenting a debug exception (#DB) on the resumed guest instruction. In the event that this #DB is intercepted (or some other exception during the #DB processing is intercepted), the stack pointer from system management mode (SMM) may be saved into the virtual machine control block (VMCB offset 1D8h). There is no error if an interception does not occur during the #DB.",
        "implication": "Unpredictable program behavior when debug exceptions are enabled for a virtual machine, likely observed as a program or guest operating system crash. AMD has not observed this erratum with any commercially available software.",
        "workaround": "None required.",
        "status": "No",
        "errnum": "738"
    },
    {
        "title": "Spurious Debug Exception May Be Observed",
        "problem": "Under a highly specific and detailed set of internal timing requirements, the processor may report a debug exception (#DB) on an address that has a data write breakpoint while executing instructions that do not actually write to the address. The exception is misreported due to a branch misprediction that occurs for the monitored address.",
        "implication": "Debug engineers or debug programs may observe a #DB exception when no write occurs.",
        "workaround": "None.",
        "status": "No",
        "errnum": "747"
    },
    {
        "title": "Processor Incorrectly Restores Guest Privilege Level after Unintercepted I/O C-state Request",
        "problem": "Following an unintercepted guest access to an I/O address that causes an entry to a C-state, the processor may enter core C6 (CC6) state and incorrectly clear the guest current privilege level (CPL) to zero.",
        "implication": "Unpredictable system behavior. AMD has not observed this erratum with any commercially available software.",
        "workaround": "Hypervisors should intercept any guest accesses to the I/O registers associated with I/O C-states, to avoid the possibility that a guest operating system has allowed a non-privileged application to request I/O C-states. To intercept these accesses, hypervisors should program the virtual machine control block (VMCB) I/O interception bits as follows: \u2022 VMCB offset 00Ch bit 27 (IOIO_PROT) should be 1b. \u2022 The I/O protection map should indicate interception on a read to the eight consecutive I/O addresses starting with the address specified at C-state Base Address Register[CstateAddr] (MSRC001_1073[15:0]). The physical address of the I/O protection map is at VMCB offset 040h.",
        "status": "No",
        "errnum": "770"
    },
    {
        "title": "Processor May Cache Guest Write Combining Memory Type",
        "problem": "The processor may incorrectly cache reads performed to memory regions that are defined as WC+ memory type. The processor may incorrectly cache this memory type based on speculative read operations. The program does not need to retire a load instruction in order for the caching to occur. This incorrectly cached data is removed from the cache if there is any write to this address from this processor core, from another processor core, or from a device that probes all cores during the write. The WC+ memory type is only used when all of the following conditions apply: \u2022 An SVM guest with nested paging enabled is currently executing. \u2022 The guest page table maps the memory to WC as the guest PAT memory type. \u2022 The host page table maps the memory to WP, WT or WB as the host PAT memory type. \u2022 The MTRR memory type is either WP, WT, or WB.",
        "implication": "Under most conditions, except as specified below, the incorrect caching has no effect as this WC+ memory type is still probed by processor and I/O accesses. As a result, these transactions still observe and maintain the most current copy of the data even in the presence of incorrect caching. Incorrect caching may have an effect when one of these conditions occurs: \u2022 An SVM guest program observes inconsistent \u201cstale\u201d data for a write-combining MMIO address due to the program observing cached data that is inconsistent with the current device state. In order for this to occur, the SVM guest must have direct mapped access to the MMIO address region for an I/O device that is capable of write-combining. However, the MTRR for the device\u2019s MMIO region would also normally be mapped as WC, and the erratum would not apply in this case. \u2022 An SVM guest program observes inconsistent \u201cstale\u201d data when it has DRAM pages marked as WC in the guest PAT tables and is using this memory as a buffer that a non-coherent device may also write (a non-coherent device is one that does not probe processor caches when it reads or writes the system memory). One possible example of a device that does not probe processor caches during the upstream writes to memory is a graphics engine (GPU) writing into a DRAM mapped buffer or a PCI Express\u00ae device that is using the No Snoop attribute in its upstream transactions.",
        "workaround": "A workaround is not recommended. System developers may disable the ability for an I/O device to perform upstream writes without probing memory by setting D18F3x88[22] = 1b.",
        "status": "No",
        "errnum": "780"
    },
    {
        "title": "Processor May Incorrectly Provide Control Register Data as the Result of a Load Operation",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor core may provide control register data as the result of an instruction that is performing a load from memory. In order to observe this incorrect data, the processor must be at the highest privilege level (CPL 0) and be speculatively or non-speculatively executing certain invalid opcodes.",
        "implication": "Data corruption causing unpredictable system behavior.",
        "workaround": "Contact your AMD representative for information on an update.",
        "status": "No",
        "errnum": "784"
    },
    {
        "title": "APIC Task-Priority Register May Be Incorrect",
        "problem": "An APIC task priority register (TPR) write may use an incorrect internal buffer for the data.",
        "implication": "Incorrect interrupt prioritization.",
        "workaround": "BIOS should set MSRC001_102A[11] to 1b.",
        "status": "No fix planned",
        "errnum": "503"
    },
    {
        "title": "Corrected L3 Errors May Lead to System Hang",
        "problem": "Under a highly specific and detailed set of internal timing conditions that involves corrected L3 errors, a processor read from the L3 cache may hang.",
        "implication": "System hang.",
        "workaround": "BIOS should program D18F3x1B8[18] to 1b.",
        "status": "No fix planned",
        "errnum": "504"
    },
    {
        "title": "Scrub Rate Control Register Address Depends on DctCfgSel",
        "problem": "When DCT Configuration Select[DctCfgSel] (D18F1x10C[0]) is 1b, accesses to the Scrub Rate Control register (D18F3x58) incorrectly accesses a different register that does not actually affect any hardware.",
        "implication": "Incorrect scrub rate controls may be read or in effect.",
        "workaround": "Software should clear DctCfgSel (D18F1x10C[0]) to 0b prior to any access to D18F3x58 Scrub Rate Control Register. The software must serialize any accesses to D18F3x58 with other accesses to registers that use DctCfgSel. When enabling scrub settings, BIOS should write D18F3x58 twice with the same value - once with D18F1x10C[0] set to 0b and once with D18F1x10C[0] set to 1b. BIOS should program D18F1x10C[0] to 0b before handing over control to the operating system.",
        "status": "No fix planned",
        "errnum": "505"
    },
    {
        "title": "Some Lightweight Profiling Counters Stop Counting When Instruction-Based Sampling is Enabled",
        "problem": "When Lightweight Profiling (LWP) and Instruction-Based Sampling (IBS) measurement of instruction execution are simultaneously enabled, the following LWP counters do not increment: \u2022 Instructions retired event counter (LWP EventId 2) \u2022 Branches retired event counter (LWP EventId 3) LWP is enabled once software executes a LLWCP or XRSTOR instruction with a valid LWPCB address. IBS instruction execution sampling is enabled when IBS Execution Control[IbsOpEn] (MSRC001_1033[17]) is 1b.",
        "implication": "Performance monitoring software using LWP may not have a count of instructions retired or branches retired.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "520"
    },
    {
        "title": "Lightweight Profiling May Not Indicate Fused Branch",
        "problem": "The Lightweight Profiling (LWP) fused operation bit (FUS - bit 28 of the branch retired event record, LWP EventId 3) may not be set when the processor core is profiling a fused branch (a compare operation followed by a conditional branch that is executed as a single operation internally) and a #PF or nested-paging exception occurs during the storing of the event.",
        "implication": "Performance monitoring software may not profile a fused branch correctly.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "535"
    },
    {
        "title": "Performance Counter for Instruction Cache Misses Does Not Increment for Sequential Prefetches",
        "problem": "PMCx081 (Instruction Cache Misses) does not increment for L1 instruction cache misses that are due to sequential prefetches.",
        "implication": "Performance monitoring software may undercount instruction cache misses.",
        "workaround": "Performance monitoring software may use the difference of PMCx083 and PMCx082 as a close approximation of instruction cache misses.",
        "status": "Yes",
        "errnum": "536"
    },
    {
        "title": "Performance Counter for Ineffective Software Prefetches Does Not Count for L2 Hits",
        "problem": "PMCx052[3] (ineffective software prefetch due to an L2 cache hit) does not increment.",
        "implication": "Performance monitoring software can not determine ineffective software prefetches due to an L2 cache hit.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "537"
    },
    {
        "title": "Performance Counter Does Not Count for Some Retired Micro-Ops",
        "problem": "Some instructions with F0h in the opcode byte are incorrectly detected by the processor core as empty micro- ops, causing the processor core to not properly increment PMCx0C1. The following instructions may cause this performance monitor to undercount: \u2022 FCOMI \u2022 FCOMIP \u2022 F2XM1",
        "implication": "Performance monitoring software will not have an accurate count of retired micro-ops. The performance counter may undercount and the error is directly proportional to the number of the instructions listed above.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "538"
    },
    {
        "title": "GART Table Walk Probes May Cause System Hang",
        "problem": "Probes that are generated for GART table walks may overflow internal queues and lead to a deadlock.",
        "implication": "System hang.",
        "workaround": "System software that initializes the GART Table Base Address (D18F3x98) should set GART Aperture Control[DisGartTblWlkPrb] (D18F3x90[6]) = 1b. The GART tables should be in UC DRAM or be updated only using strongly-ordered uncacheable writes. System software should not set HWCR[ForceRdWrSzPrb] (MSRC001_0015[23]) if GART is enabled.",
        "status": "No fix planned",
        "errnum": "540"
    },
    {
        "title": "Incorrect Memory Controller Operation Due to a WrDatGrossDly Setting of 3.5 MEMCLKs",
        "problem": "The memory controller may incorrectly issue a ZQ command during a 64-byte write operation when WrDatGrossDly is set to a value of 3.5 MEMCLKs (111b).",
        "implication": "Undefined system behavior.",
        "workaround": "If WrDatGrossDly (D18F2x9C_x0000_0[3:0]0[3:1]_dct[1:0]) for all byte lanes (including the ECC byte lane) and all populated DIMMs = 111b, BIOS should set DataTxFifoWrDly (D18F2x210_dct[1:0]_nbp[3:0] bits 18:16) as specified in the BIOS and Kernel Developer's Guide (BKDG) for AMD Family 15h Models 00h-0Fh Processors, order# 42301, but with a minimum value of 010b.",
        "status": "No fix planned",
        "errnum": "585"
    },
    {
        "title": "A Far Control Transfer Changing Processor Operating Mode May Generate a False Machine Check",
        "problem": "A far control transfer that changes the processor operating mode may erroneously indicate a decoder instruction buffer parity error (DEIBP) machine check, leading to a system shutdown. The extended error code logged in the IF Machine Check Status register indicates a decode instruction buffer error (MSR0000_0405[20:16] = 10010b).",
        "implication": "Machine check exception due to a decoder instruction buffer parity error leading to system shutdown.",
        "workaround": "BIOS should set MSRC001_0045[18] = 1b (MC1_CTL_MASK[DEIBP]).",
        "status": "Yes",
        "errnum": "586"
    },
    {
        "title": "VPEXTRQ and VPINSRQ May Not Signal Invalid-Opcode Exception",
        "problem": "Advanced Vector Extensions (AVX) variants of legacy SSE instructions normally promote the size of a GPR operand using VEX.W. When running in 32-bit legacy or compatibility modes, setting VEX.W=1 is nonsensical and VEX.W is ignored. VPEXTRQ and VPINSRQ are an exception to that general rule and are specified to generate a Invalid-Opcode (#UD) exception. In violation of this, the processor does not signal #UD exception for AVX instructions VPEXTRQ and VPINSRQ when VEX.W=1 and the processor is running in 32-bit legacy or compatibility modes. Instead, the instruction is executed as if VEX.W=0.",
        "implication": "None expected. These opcode encodings are not expected to be generated by software.",
        "workaround": "Software should only generate VPEXTRQ and VPINSRQ instructions with VEX.W=0 when operating in 32-bit modes and not depend on generating a #UD with VEX.W=1.",
        "status": "Yes",
        "errnum": "592"
    },
    {
        "title": "Last-Branch Record Enabled May Cause Machine Check and Incorrect LastBranchToIp",
        "problem": "When LBR is enabled, a complex interaction between two threads of the same compute-unit may result in the processor core reporting an incorrect value in the LastBranchToIp register (MSR0000_01DC).",
        "implication": "In rare circumstances, the value reported in LastBranchToIP may present incorrect debug information. The processor may also report an uncorrectable machine check exception for a branch status register parity error, simultaneous to the above error. MC1_STATUS[ErrorCodeExt] (MSR0000_0405[20:16]) = 00110b identifies a branch status register parity error.",
        "workaround": "BIOS should set MSRC001_0045[15] = 1b (MC1_CTL_MASK[BSRP]). This workaround does not resolve the potential for an incorrect address to be provided in LastBranchToIp. This latter effect has negligible impact on debugging due to the low probability of the error occurring when this data is being collected. No workaround is required for this aspect.",
        "status": "Yes",
        "errnum": "593"
    },
    {
        "title": "HyperTransport\u2122 Link Retry Due to Partial CRC Error May Cause System Hang",
        "problem": "The northbridge may stall when a probe hit returning data occurs simultaneously with a link retry due to a partial CRC error detected on an unrelated read packet. This error can only occur on a coherent HyperTransport\u2122 link.",
        "implication": "System hang.",
        "workaround": "BIOS should not alter D18F0x150[11:9] (Link Global Retry Control Register[HtRetryCrcDatIns]) from its reset value of 000b.",
        "status": "Yes",
        "errnum": "600"
    },
    {
        "title": "HyperTransport\u2122 Link Frequency Changes May Cause a System Hang",
        "problem": "A HyperTransport\u2122 link operating at a Gen3 frequency (greater than 2.0 GT/s) may have excessive link retries or may fail to train after transitioning to a new Gen3 frequency. The failure is due to a misconfiguration of the HyperTransport Link Phy Receiver DLL Control and Test 5 Register [DllProcessFreqCtlOverride, DllProcessFreqCtlIndex2] settings (D18F4x1[9C,94,8C,84]_x[5:4][9:0][8,0]F_dm[1] bits 12 and 3:0). These settings are specific to each Gen3 frequency and may be programmed only while the link is operating at a Gen1 frequency (less than or equal to 2.0 GT/s).",
        "implication": "System hang.",
        "workaround": "Software that transitions a HyperTransport link between two different Gen3 frequencies must first transition the link to a Gen1 frequency so that the DllProcessFreqCtlOverride and DllProcessFreqCtlIndex2 settings may be programmed according to the algorithm documented in the BIOS and Kernel Developer's Guide (BKDG) for AMD Family 15h Models 00h-0Fh Processors, order# 42301.",
        "status": "No fix planned",
        "errnum": "602"
    },
    {
        "title": "P-state Limit Changes May Not Generate Interrupts",
        "problem": "P-state limit changes fail to generate interrupts when the target P-state limit is a higher or equal performance P- state (lower or equal numbered P-state) than the Application Power Management (APM) P-state limit.",
        "implication": "Operating systems monitoring processor P-state capabilities may not be notified of all P-state limit changes, resulting in either one of the following conditions: \u2022 The processor runs continuously in a lower performance (higher numbered) P-state than is actually available. \u2022 The operating system may request a higher performance (lower numbered) P-state than is actually available.",
        "workaround": "BIOS should set MSRC001_1000[16] = 1b.",
        "status": "No fix planned",
        "errnum": "608"
    },
    {
        "title": "Non-Posted Reads May Block Write Dependent on Probe Responses",
        "problem": "The northbridge may stall indefinitely on non-posted reads when a posted write becomes dependent on probe responses.",
        "implication": "System hang.",
        "workaround": "BIOS should set D18F5x88[14] = 1b.",
        "status": "Yes",
        "errnum": "619"
    },
    {
        "title": "Small Code Segment Limits May Cause Incorrect Limit Faults",
        "problem": "In cases where the code segment limit is less than 0_0020h and the Granularity (G) bit is zero, the processor reports an incorrect #GP exception even when no limit violation exists.",
        "implication": "None expected. In the unlikely case that a code segment is 32 bytes or smaller, an unexpected #GP exception may occur.",
        "workaround": "None required. It is anticipated that code segment sizes are greater than 32 bytes.",
        "status": "Yes",
        "errnum": "623"
    },
    {
        "title": "SB-RMI Processor State Accesses May Persistently Timeout if Interrupted by a Warm Reset",
        "problem": "The assertion of a warm reset during a small timing window of an APML SB-RMI processor state access may cause the internal processor state access interface to hang. A protocol status code of 11h or 12h (Command Timeout) is returned, however, the internal interface remains hung and all future SB-RMI processor state accesses receive command timeouts until a cold reset is performed. If SB-RMI timeouts are disabled (Control Register[TimeoutDis], SBRMI_x01[2]), the SB-RMI processor state accesses will not receive a successful completion, instead of a command timeout.",
        "implication": "Under rare circumstances, system management software will not be able to access processor state using SB-RMI processor state accesses. SB-TSI accesses and SB-RMI register accesses are not impacted. Refer to Advanced Platform Management Link (APML) Specification, order# 41918 for details on differentiating SB-RMI processor state accesses from SB- RMI register accesses.",
        "workaround": "None required.",
        "status": "Yes",
        "errnum": "624"
    },
    {
        "title": "Instruction Addresses Near Canonical Address Limit May Cause #GP Exception",
        "problem": "The processor may incorrectly generate a #GP exception when an instruction executes within a small window of the linear-memory address at the limit of canonical address space (0000_7FFF_FFFF_FFFFh: 0000_7FFF_FFFF_FFF2h) and multiple branch mis-predicts occur to a linear-memory address at the limit of canonical address space.",
        "implication": "In the unlikely event that the conditions for this erratum occur, an unexpected #GP exception may result in a program or system crash.",
        "workaround": "None required.",
        "status": "Yes",
        "errnum": "636"
    },
    {
        "title": "Processor Does Not Report the Correct DRAM Address for MCA Errors Within the CC6 Save Area",
        "problem": "While reporting an ECC machine check error in the core C6 (CC6) save area, the processor may store an internal address in MC4_ADDR (MSR0000_0412) instead of the physical DRAM address. The stored internal address can be uniquely identified, as it matches 000000FD_F7xxxxxxh.",
        "implication": "Software may not be able to correctly interpret the machine check addresses for either corrected or uncorrected DRAM errors. As a result, it may fail to report the correct physical location of the error.",
        "workaround": "When using the address in MC4_ADDR (MSR0000_0412) software should compare MC4_ADDR[47:24] with 00FDF7h. If it matches 00FDF7h, then the following algorithm can be used to correct the value from MC4_ADDR into the physical DRAM address that is in error. 1. Software first determines which node (identified by its node ID) reported the machine check. This is usually known to software that reads MC4_ADDR, (i.e. NodeReportingMca = CPUID Fn8000_001e_ECX[NodeId, bits 7:0]), but in some cases software may not know the node that reported the machine check. In this case, the node that reported the MCA can be determined as follows: a. SourceNode = MC4_ADDR[22:20]. In this step, software determines the node that generated the CC6 save request. This is not necessarily the node that reported the machine check. b. NodeReportingMca = D(18h+SourceNode)F4x128[14:12], where \"18h+SourceNode\" is the device number of the node that generated the CC6 save request. In this step, software accesses the C-state Policy Control 1 Register[CoreStateSaveDestNode] on the node that generated the CC6 save request (SourceNode from the previous step). This is the node that reported the machine check. 2. DramLimitSysAddrReg = D(18h+NodeReportingMca)F1x124, where \"18h+NodeReportingMca\" is the device number of the node that reported the machine check. In this step, software reads the register containing the DRAM Limit System Address from the node that reported the machine check. The register contents from this step are saved in a temporary variable for use in later steps. 3. Cc6BaseAddress[47:0] = {DramLimitSysAddrReg[20:0], ((DramLimitSysAddrReg[23:21] ^ 111b) << 24), 000000h} . In this step, software calculates the CC6 base address using the DramLimitAddr. DramLimitAddr[47:27] is bits 20:0 of the register read in step 2. Bits 26:24 of the CC6 base address is calculated from DramInlvEn. 4. NodeInterleavingEnabled = (DramLimitSysAddrReg[23:21] != 000b). In this step, software determines if node interleaving is enabled. Node interleaving is enabled if the register read in step 2 has a non-zero value in bits 23:21 (DramIntlvEn). 5. If node interleaving is not enabled (!NodeInterleavingEnabled from step 4): a. The physical DRAM address of the machine check error is (Cc6BaseAddress + MC4_ADDR[23:0]) where Cc6BaseAddress is the result from step 3. 6. If node interleaving is enabled (NodeInterleavingEnabled from step 4): a. TempMcaAddress = (MC4_ADDR[63:0] & 00000000_00FFF000h) << (log (base 2) of (DramLimitSysAddrReg[23:21] + 1)). In this step, a temporary variable is initialized using the value reported in MC4_ADDR, removing bits 47:24 and bits 11:0, and shifting the remaining bits by either 1 (two nodes), 2 (four nodes) or 3 (eight nodes). The node count is indirectly determined from DramIntlvEn (bits 23:21 of the register read in step 2). b. DramBaseSysAddrReg = D(18h+NodeReportingMca)F1x120, where \"18h+NodeReportingMca\" is the device number of the node that reported the machine check. In this step, software reads the register containing the DRAM Base System Address from the node that reported the machine check. The register contents from this step are saved in a temporary variable for use in the next step. c. TempMcaAddress = TempMcaAddress | (DramBaseSysAddrReg[23:21] << 12). In this step, the DramIntlvSel, bits 23:21 of the register read in the previous step, is placed in bits 14:12 of the address. d. TempMcaAddress = TempMcaAddress | MC4_ADDR[11:0]. In this step, the low order bits of the machine check address are placed into the calculated address. e. The physical DRAM address of the machine check error is (Cc6BaseAddress + TempMcaAddress) where Cc6BaseAddress is the result from step 3. The DRAM address that results from this workaround is only appropriate for determining the location of the failing memory. Software cannot access system DRAM using this address.",
        "status": "No fix planned",
        "errnum": "637"
    },
    {
        "title": "MC1_STATUS Enable Bit Not Set When Logging Corrected Errors",
        "problem": "The processor does not set MC1_STATUS[En] = 1b (MSR0000_0405[60]) when logging an enabled and corrected error in the IF machine check register bank (bank 1). Software can identify the corrected errors that are affected by this erratum when it observes an MC1_STATUS register with all of the following: \u2022 MC1_STATUS[Valid] (bit 63) = 1b \u2022 MC1_STATUS[Uc] (bit 61) = 0b \u2022 MC1_STATUS[En] (bit 60) = 0b \u2022 MC1_STATUS[Pcc] (bit 57) = 0b \u2022 The corresponding enable bit in MC1_CTL (MSR0000_0404) = 1b",
        "implication": "None expected.",
        "workaround": "None required.",
        "status": "No fix planned",
        "errnum": "657"
    },
    {
        "title": "CPUID Incorrectly Reports Large Page Support in L2 Instruction TLB",
        "problem": "The CPUID instruction incorrectly reports the number of entries and the associativity of 2 MB, 4 MB and 1 GB TLB entries in the L2 instruction TLB. The following CPUID fields are incorrectly zero: \u2022 CPUID Fn8000_0006_EAX[L2ITlb2and4MSize] \u2022 CPUID Fn8000_0006_EAX[L2ITlb2and4MAssoc] \u2022 CPUID Fn8000_0019_EBX[L2ITlb1GSize] \u2022 CPUID Fn8000_0019_EBX[L2ITlb1GAssoc]",
        "implication": "None expected.",
        "workaround": "Software may substitute the following values to determine the number and associativity of large page L2 TLB entries: \u2022 CPUID Fn8000_0006_EAX[L2ITlb2and4MSize] = 1024 \u2022 CPUID Fn8000_0006_EAX[L2ITlb2and4MAssoc] = 6 \u2022 CPUID Fn8000_0019_EBX[L2ITlb1GSize] = 1024 \u2022 CPUID Fn8000_0019_EBX[L2ITlb1GAssoc] = 6 This workaround should only be implemented after checking for affected silicon family and model (CPUID Fn0000_0001_EAX[Extended Family, Family, Extended Model and Model]), and that the processor reports zero for these fields.",
        "status": "Yes",
        "errnum": "658"
    },
    {
        "title": "VMCB Interrupt Shadow Status May Be Incorrect",
        "problem": "The processor may fail to clear the VMCB INTERRUPT_SHADOW field (VMCB offset 068h bit 0) when intercepting or interrupting an SVM guest that is executing a Move String instruction with a REP prefix under interrupt shadow. This erratum does not occur on the last iteration of the Move String instruction.",
        "implication": "The SVM guest may continue to operate under interrupt shadow until the Move String instruction has completed. This may delay servicing of a pending interrupt.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "659"
    },
    {
        "title": "APERF May Increase Unpredictably",
        "problem": "The value of MSR0000_00E8 (APERF) may increase unpredictably after any of the following events: \u2022 A P-state transition, including those performed due to core performance boost (CPB). \u2022 A C-state transition. \u2022 A change in the P-state limit due to hardware thermal control (HTC), application power management (APM) or advanced platform management link (APML) TDP limiting. \u2022 Execution of the MWAIT instruction.",
        "implication": "Software may calculate the effective frequency of a core incorrectly or observe that the APERF register value appears to increase unpredictably.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "660"
    },
    {
        "title": "P-State Limit and Stop Clock Assertion May Cause System Hang",
        "problem": "A P-state limit change that occurs within a small timing window of a Stop Clock assertion may result in DRAM not entering self-refresh mode for an S3 sleep state transition, or a system hang if it occurs while another processor core is transitioning to the Core C6 (CC6) state.",
        "implication": "System hang.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "661"
    },
    {
        "title": "Local Interrupts LINT0/LINT1 May Occur While APIC is Software Disabled",
        "problem": "The processor unmasks local interrupts (LINT0 and LINT1) while the APIC is software disabled (Spurious- Interrupt Vector Register[APICSWEn], APICF0[8] = 0b). The LINT[1:0] LVT entry mask bits (APIC3[60:50] bit 16) are cleared and cannot be set. Broadcast ExtInt and NMI interrupt requests can be converted to LINT0 and LINT1 local interrupts respectively by setting Link Transaction Control Register[LintEn] (D18F0x68[16]) = 1b. If this bit is set while the APIC is software disabled, an ExtInt or NMI interrupt causes an unexpected local interrupt.",
        "implication": "Software may receive a local interrupt that was not expected, possibly leading to a system crash.",
        "workaround": "BIOS should set MSRC001_001F[23] = 1b before enabling the APIC (APIC_BAR[ApicEn] (MSR0000_001B[11]) = 1b) or before setting Link Transaction Control[LintEn] (D18F0x68[16]) = 1b.",
        "status": "No fix planned",
        "errnum": "663"
    },
    {
        "title": "Processor May Generate Incorrect P-state Limit Interrupts",
        "problem": "P-state limit changes due to SB-RMI (SBI P-state Limit[PstateLimit], MSRC001_0072[10:8]), software (Software P-state Limit Register[SwPstateLimit], D18F3x68[30:28]), or hardware thermal control (entering HTC-active state, i.e. PROCHOT# assertion) may generate duplicate interrupts when Hardware Thermal Control Register bits [PslApicLoEn, PslApicHiEn] are not both zero (D18F3x64[7:6] != 00b). The processor actually uses APM TDP Control[ApmTdpLimitIntEn] = 1b to enable the generation of interrupts for P-state limit changes due to SB-RMI, software, or HTC, as well as to generate interrupts for changes to TDP Limit 3 Register[ApmTdpLimit] (D18F5xE8[28:16]).",
        "implication": "Operating systems monitoring processor P-state capabilities may receive duplicate notification of P-state limit changes due to SB-RMI, software, or HTC.",
        "workaround": "BIOS should leave Hardware Thermal Control[PslApicLoEn, PslApicHiEn] at their default reset value (D18F3x64[7:6] = 00b) and should set APM TDP Control[ApmTdpLimitIntEn] (D18F4x16C[4]) = 1b. This workaround requires software to receive both P-state limit change interrupts and ApmTdpLimit change interrupts.",
        "status": "No fix planned",
        "errnum": "667"
    },
    {
        "title": "Load Operation May Receive Incorrect Data After Floating- point Exception",
        "problem": "The processor may incorrectly load data from a prior store-to-load forwarding operation after an unmasked x87 floating-point exception (#MF) if the exception occurs while CR0 Numeric Error = 0b (CR0.NE, bit 5) and a prior exception is indicated (x87 Status Word Register Exception Status, FSW.ES bit 7, is already 1b).",
        "implication": "None expected. Operating systems typically set CR0.NE = 1b or floating-point exception handlers normally clear the exception status (FSW.ES). If these conditions are not met, a load operation may receive data that was not updated by the most current write from a processor core. AMD has not observed this erratum with any commercially available software.",
        "workaround": "None.",
        "status": "Yes",
        "errnum": "668"
    },
    {
        "title": "Debug Breakpoint on Misaligned Store May Cause System Hang",
        "problem": "A misaligned store that crosses cache lines and requires an address translation due to a TLB miss may cause a system hang if the trailing cache line has an address breakpoint enabled using DR7.",
        "implication": "System hang.",
        "workaround": "Contact your AMD representative for information on a BIOS update. This workaround has a performance impact when certain debug breakpoints are enabled. System developers that wish to enable debug breakpoints without this workaround may first set MSRC001_1000[17] = 1b. AMD recommends this workaround be enabled with AMD Opteron\u2122 processors. For all other processors, BIOS should disable the workaround by setting MSRC001_1000[17] = 1b.",
        "status": "Yes",
        "errnum": "671"
    },
    {
        "title": "SVM Guest Performance Counters May Be Inaccurate Due to SMI",
        "problem": "Performance Event Counters[5:0] (MSRC001_020[B,9,7,5,3,1]) incorrectly count events in System- Management Mode (SMM) after a Secure Virtual Machine (SVM) guest receives a System-Management Interrupt (SMI) that is not intercepted by the host. This occurs when guest event counting is enabled by setting Performance Event Select[5:0][HostGuestOnly] = 01b (MSRC001_020[A,8,6,4,2,0][41:40]) and EFER[SVME] = 1b (MSRC000_0080[12]).",
        "implication": "Performance monitoring software overcounts events for an SVM guest when non-intercepted SMIs occur.",
        "workaround": "Contact your AMD representative for information on a BIOS update. When the workaround is enabled, the processor swaps the HostGuestOnly bits (i.e. bits 41 and 40 of MSRC001_020[A,8,6,4,2,0] are exchanged) before entering SMM from SVM guest mode and again on the corresponding RSM.",
        "status": "Yes",
        "errnum": "672"
    },
    {
        "title": "Misaligned Page Crossing String Operations May Cause System Hang",
        "problem": "A misaligned Move String or Store String instruction with a REP prefix that crosses a page boundary may cause a system hang. This may occur when the TLB entry for the leading page is evicted while the string operation is executing, or the trailing page of the string operation crosses into a large page (1 GB or 2 MB) which requires an address translation due to a TLB miss.",
        "implication": "Unpredictable system behavior, likely leading to a system hang.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "673"
    },
    {
        "title": "Processor May Cache Prefetched Data from Remapped Memory Region",
        "problem": "Prefetches from a write back (WB) DRAM memory region may persist when that memory region is remapped to an uncacheable (UC) or write combining (WC) memory type.",
        "implication": "Data could be cached in a modified state from the remapped memory region, which will not be probed, however this can only occur if a prefetch operation persists through the invalidation or flushing of TLB entries and cache lines before the remapped memory region is accessible in a coherent manner. There have been no observations of this erratum on silicon.",
        "workaround": "None recommended. Optionally, system software may set MSRC001_1022[13] = 1b (DC_CFG[DisHwPf]) during system boot if frequent run-time remapping of memory types as described is expected.",
        "status": "Yes",
        "errnum": "674"
    },
    {
        "title": "Instructions Performing Read-Modify-Write May Alter Architectural State Before #PF",
        "problem": "An instruction performing a read-modify-write operation may be presented with a page fault (#PF) after modifying architectural state.",
        "implication": "The processor may present a #PF exception after some of the instruction effects have been applied to the processor state. No system effect is observed unless the operating system's page fault handler has some dependency on this interim processor state, which is not the case in any known operating system software. The interim state does not impact program behavior if the operating system resolves the #PF and resumes the instruction. However, this interim state may be observed by a debugger or if the operating system changes the #PF to a program error (for example, a segmentation fault).",
        "workaround": "None recommended.",
        "status": "Yes",
        "errnum": "675"
    },
    {
        "title": "Some Processor Cores May Have Inaccurate Instruction Cache Fetch Performance Counter",
        "problem": "The processor may over-report PMCx080 (instruction cache fetches) when the performance monitor is enabled on an odd processor core number (APIC20[ApicId] is odd - i.e. bit 24 is 1b), as compared to when the performance counter is used on an even processor core number.",
        "implication": "Performance monitoring software may not have an accurate count of instruction cache fetch operations. The performance counter may overcount.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "685"
    },
    {
        "title": "AM3r2 Six Core Processor May Limit P-State When Core C6 State Is Disabled",
        "problem": "If system software disables core C6 state (CC6) on an AMD FX\u2122 6100 Six-Core Processor, OPN FD6100WMW6KGU, the application power management (APM) incorrectly limits the processor P-state to a low performing P-state. Refer to the BIOS and Kernel Developer's Guide (BKDG) for AMD Family 15h Models 00h-0Fh Processors, order# 42301 section \"Core C6 (CC6) State\" for the conditions under which CC6 state is disabled.",
        "implication": "None expected under normal circumstances, as AMD recommends that CC6 is enabled in all systems. In the event that the system software implements an option to disable CC6, the system may experience low performance in this mode.",
        "workaround": "AMD recommends that CC6 is enabled. This erratum does not apply in this case and no workaround is necessary. In the event that system software disables CC6, disable APM using Core Performance Boost Control Register[ApmMasterEn] (D18F4x15C[7]) = 0b. To avoid unnecessarily disabling APM on unaffected parts, the following conditions should be met before implementing this workaround: \u2022 CC6 is disabled. \u2022 CPUID Fn8000_0001_EBX[31:28] (BrandID Identifier[PkgType]) = 0001b (AM3r2 package type). \u2022 CPUID Fn8000_0008_ECX[NC] (APIC ID Size and Core Count[Number of Physical Cores]) = 5. \u2022 D18F4x150[7:0] = 6Bh. \u2022 D18F4x10C[11:0] (TDP Limit 2 Register[NodeTdpLimit]) = 130h.",
        "status": "Yes",
        "errnum": "689"
    },
    {
        "title": "Northbridge FIFO Read/Write Pointer Overlap May Cause Hang or Protocol Error Machine Check",
        "problem": "A command or data transfer may be lost when the write pointer overlaps the read pointer of a synchronization FIFO between the processor core and the northbridge.",
        "implication": "Unpredictable system behavior, likely leading to a hang of both cores of a compute-unit. The processor may also report a probe filter protocol machine check exception identified by the extended error code in the NB Machine Check Status Register (MC4_STATUS[ErrorCodeExt], MSR0000_0411[20:16] = 01011b).",
        "workaround": "BIOS should set D18F3xDC[14:12] = 101b (Clock Power/Timing Control 2 [NbsynPtrAdj]). A warm reset is required before this setting takes effect.",
        "status": "No fix planned",
        "errnum": "690"
    },
    {
        "title": "Processors Using 1 MB L3 Subcaches May Execute a Write- Back Invalidate Operation Incorrectly",
        "problem": "The processor may fail to flush the full address range of L3 cache when executing a WBINVD instruction, or INVD instruction with Hardware Configuration Register[INVDWBINVD] = 1b (MSRC001_0015[4]). This occurs when the L3 cache is less than 8 MB per northbridge and is configured using at least one 1 MB L3 subcache, as indicated by the L3SubcacheSize fields (L3 Cache Parameter Register[L3SubcacheSize[3:0]], D18F3x1C4[[15:12],[11:8],[7:4],[3:0]] = Dh or Eh).",
        "implication": "Unpredictable system behavior. This has only been observed by AMD as a system hang while using cache as general storage during boot.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "691"
    },
    {
        "title": "Performance Counter May Incorrectly Count MXCSR Loads",
        "problem": "The processor may incorrectly increment the following performance counter due to XRSTOR, FXRSTOR, LDMXCSR or VLDMXCSR instructions loading the MXCSR register: \u2022 PMCx003 (Retired Floating Point Ops)",
        "implication": "Performance monitoring software will not have an accurate count of the number of retired floating point operations reported by the above performance counter.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "693"
    },
    {
        "title": "IBS Sampling of Instruction Fetches May Be Uneven",
        "problem": "Instructions selected for instruction-based sampling (IBS) of fetch performance (Fetch Control[IbsFetchEn], MSRC001_1030[48] = 1b) may be sampled unevenly when the instruction fetch stream is redirected (e.g., due to a branch taken).",
        "implication": "Performance monitoring software may not receive even, unbiased IBS sampling of the instruction fetch stream. However, IBS can still be used effectively for identifying performance issues associated with specific instructions. The sampling bias makes IBS less effective for measuring the statistical distribution of operations and events.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "694"
    },
    {
        "title": "Processor May Interpret FCW Incorrectly after FNSAVE/ FSAVE Limit Fault",
        "problem": "The processor operates as if the floating-point control word (FCW) has been initialized after executing an FNSAVE or FSAVE instruction which generates a stack limit fault (SS). This occurs when the instruction attempts to store the state of the floating-point unit to a memory location that crosses a 16-bit (0xFFFF) or 32-bit (0xFFFF_FFFF) address boundary in real or protected mode respectively, and persists until software reinitializes the FCW. The FXSAVE instruction is not affected by this erratum.",
        "implication": "None expected during normal operation. A stack limit fault while executing an FNSAVE or FSAVE instruction is unusual and AMD has not observed the above conditions in any commercially available software. In the unlikely event that software creates the conditions described above one of the following may occur: \u2022 The processor may write an indefinite value, as if masked, when signaling an invalid-operation exception (IE) after an FLD instruction executes with invalid operands while invalid operations are unmasked (FCW.IM, bit 0 = 0b). \u2022 The processor may set the FERR signal incorrectly after an FLDCW instruction updates the floating-point control word mask bits (FCW[5:0]). A subsequent floating point operation may then result in an incorrect or missing x87 floating-point exception (#MF).",
        "workaround": "None required.",
        "status": "No fix planned",
        "errnum": "695"
    },
    {
        "title": "Processor May Generate Illegal Access in VMLOAD or VMSAVE Instruction",
        "problem": "The processor may generate a speculative access during execution of a VMLOAD or VMSAVE instruction. The memory type used for this access is defaulted to WB DRAM memory type, however the address used may not be a valid DRAM address or it may be an address that is not specified as cacheable in the memory type (i.e., the actual memory type is UC or WC).",
        "implication": "When the address is not a valid DRAM address, the processor may recognize a northbridge machine check exception for a link protocol error. This machine check exception causes a sync flood and system reset under AMD recommended BIOS settings. The machine check has the following signature: \u2022 The MC4_STAT register (MSR0000_0411) is equal to BA000020_000B0C0F. Bit 62 (error overflow) or bit 59 (miscellaneous valid) of MC4_STAT may or may not be set. \u2022 Bits 5:1 of the MC4_ADDR register (MSR0000_0412) is equal to 01001b, indicating that a coherent-only packet was issued to a non-coherent link. When the address is actually a non-cacheable memory type, the processor may incorrectly cache the data, resulting in unpredictable system behavior. AMD has only observed a northbridge link protocol error machine check. The incorrect caching of an uncacheable memory region has not been observed by AMD.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "699"
    },
    {
        "title": "Processor May Report Incorrect Instruction Pointer",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor may store an incorrect instruction pointer (rIP) while processing an interrupt or a debug trap exception (#DB).",
        "implication": "Unpredictable system behavior.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "704"
    },
    {
        "title": "Performance Counter for Locked Operations May Count Cycles from Non-Locked Operations",
        "problem": "PMCx024[2] may include cycles spent performing non-locked operations.",
        "implication": "Performance monitoring software may receive an incorrect (larger) count of the number of cycles spent in the non-speculative phase of locked operations.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "707"
    },
    {
        "title": "Initial Value of Time Stamp Counter May Include an Offset Error",
        "problem": "During the interval of time between the northbridge observing the RESET# deassertion and the processor cores initializing internal copies of the time stamp counter (TSC), the TSC appears to increment at a rate that is twice the actual processor core software P0 frequency. This introduces an initial offset error in the reset value for each processor core. The actual value of the offset error is unpredictable. On the first case of any P-state change (either due to a P-state limit change or a software initiated P-state change), any halt instruction or C-state activity, the above initial offset error is removed. It is possible that the BIOS could observe the TSC to change to a smaller value (i.e., the TSC may appear to decrement once) if the latency of this operation is less than the above introduced error. If the software was to perform a write to the TSC before this event, the offset error is also removed.",
        "implication": "None expected under normal circumstances.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "708"
    },
    {
        "title": "Processor May Be Limited to Minimum P-state After a P- state Limit Change",
        "problem": "Following a change to the P-state limit or a core C6 (CC6) exit, the processor may incorrectly restrict the processor to the lowest-performing P-state (Clock Power/Timing Control 2 Register[HwPstateMaxVal], D18F3xDC[10:8]). This restriction may not match any of the actual P-state limits and does not get removed until a processor reset occurs. P-state limit changes that may cause this erratum may be due to SB-RMI (SBI P-state Limit[PstateLimit], MSRC001_0072[10:8]), software (Software P-state Limit Register[SwPstateLimit], D18F3x68[30:28]), or hardware thermal control (entering HTC-active state, i.e. PROCHOT# assertion).",
        "implication": "Processor performance is limited to the lowest-performing P-state.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "709"
    },
    {
        "title": "Processor May Check DRAM Address Maps While Using L2 Cache as General Storage during Boot",
        "problem": "BIOS accesses, while running with L2 cache as general storage, may hit in the L2 cache while they are concurrently checked against the DRAM Base and Limit Registers in the northbridge. In the event that this check is performed while the DRAM address maps are not yet completed by BIOS, the northbridge may flag a protocol error if it cannot find a DRAM address map associated with the BIOS access. AMD has only observed this issue when node-interleaving is enabled (DRAM Base/Limit Register[IntlvEn] (D18F1x[17C:140,7C:40] [10:8] != 000b).",
        "implication": "The processor may recognize a northbridge machine check exception for a link protocol error. The machine check exception may cause a sync flood and/or a system reset. This may be observed as a system hang. The machine check has the following signature: \u2022 The MC4_STAT register (MSR0000_0411) is equal to BA000020_000B0C0F. Bit 62 (error overflow) or bit 59 (miscellaneous valid) of MC4_STAT may or may not be set. \u2022 Bits 5:1 of the MC4_ADDR register (MSR0000_0412) is equal to 01001b, indicating that a coherent-only packet was issued to a non-coherent link. The conditions under which this erratum may be observed as a system failure are sensitive to the core and northbridge frequencies. AMD has only observed this erratum with one G34 processor configuration where the software P-state 0 core frequency is less than the northbridge frequency.",
        "workaround": "BIOS should set MSRC001_102A[8] to 1b prior to using L2 cache as general storage during boot, and then should restore MSRC001_102A[8] to it's original value after completing L2 cache as general storage.",
        "status": "No fix planned",
        "errnum": "714"
    },
    {
        "title": "Instruction-Based Sampling May Be Inaccurate",
        "problem": "The processor may experience sampling inaccuracies when Instruction-Based Sampling (IBS) is enabled in the following cases: \u2022 When IBS Op Data 3 Register[IbsDcMiss] (MSRC001_1037[7]) is 0b, IBS Op Data 3 Register[IbsDcMabHit] (MSRC001_1037[16])] should always be 0b. However, the processor may incorrectly set IbsDcMabHit. \u2022 When the processor samples an instruction that is altering the CS_BASE value, the IbsOpRip reported in IBS Op Logical Address (MSRC001_1034) may be determined using an incorrect CS_BASE. \u2022 In rare instances, a tagged branch may set an inaccurate value in IBS Branch Target Address Register (MSRC001_103B).",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "The following workarounds can be used for the above issues: \u2022 Performance monitoring software should treat IBS Op Data 3 Register[IbsDcMabHit] (MSRC001_1037[16]) as 0b when MSRC001_1037[7] is 0b. \u2022 No workaround is necessary for IbsOpRip when CS_BASE is zero. CS_BASE is normally zero in commercially available software. \u2022 Performance monitoring software should not rely on the value in MSRC001_103B (IbsBrTarget).",
        "status": "Yes",
        "errnum": "717"
    },
    {
        "title": "Instruction-Based Sampling May Be Inaccurate",
        "problem": "The processor may experience sampling inaccuracies when Instruction-Based Sampling (IBS) is enabled in the following cases: \u2022 The processor may set IBS Op Data 3 Register[IbsDcStToLdCan, IbsDcStToLdFwd] (MSRC001_1037[12, 11]) incorrectly for load instructions that are tagged for IBS if there was a recently executed store instruction whose store address matches the load address in bits 11:0. \u2022 When performing an IBS execution sample, the processor only sets, but never clears, the following bits: \u2022 IbsDcL2TlbMiss (MSR C001_1037[3]) \u2022 IbsDcL2TlbHit2M (MSR C001_1037[6]) \u2022 IbsDcL2TlbHit1G (MSR C001_1037[19]) \u2022 The processor incorrectly updates IBS Op Data 2 Register[NbIbsReqCacheHitSt, NbIbsReqDstProc, NbIbsReqSrc] (MSR C001_1036[5,4,2:0]) during an IBS fetch sample. If both IBS execution sampling (IBS Execution Control[IbsOpEn], MSRC001_1033[17] = 1b) and IBS fetch sampling (IBS Fetch Control[IbsFetchEn], MSRC001_1030[48] = 1b) are enabled simultaneously, valid execution sample data may be overwritten by a fetch sample resulting in IBS data that is inconsistent with the accompanying IBS execution sample data. \u2022 The processor may infrequently report an incorrect instruction pointer in the IBS Fetch Linear Address (MSRC001_1031).",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "The following workarounds can be used for the above issues: \u2022 No workaround exists for IbsDcStToLdCan and IbsDcStToLdFwd. These bits would not significantly over- indicate a store to load forwarding with most code. \u2022 Performance monitoring software should clear the IBS Op Data 3 Register (MSR C001_1037[63:0] = 0) between each IBS sample. \u2022 Performance monitoring software should not rely on MSRC001_1036 if both IBS execution sampling and IBS fetch sampling are enabled simultaneously. \u2022 Performance monitoring software should not rely on MSRC001_1031.",
        "status": "No fix planned",
        "errnum": "718"
    },
    {
        "title": "Instruction-Based Sampling Fetch Counter Always Starts at Maximum Value",
        "problem": "When setting IBS Fetch Control Register[IbsFetchEn] = 1b to enable IBS fetch sampling, the periodic fetch counter always starts at the maximum value programmed into IBS Fetch Control Register[IbsFetchMaxCnt] (MSRC001_1030[15:0]) instead of starting at the value written into IBS Fetch Control Register[IbsFetchCnt] (MSRC001_1030[19:4]).",
        "implication": "System software that is managing multiple processes or virtual machines with different IBS configurations may create unintended delays before the next IBS sample by writing to MSRC001_1030. In the event that system software consistently writes to MSRC001_1030, it is possible that the IBS fetch counter never expires and no instruction fetches are tagged. AMD has not observed this effect with production software.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "719"
    },
    {
        "title": "Processor May Not Respect Interrupt Shadow",
        "problem": "Under a highly specific and detailed set of internal timing conditions, a #DB exception may be presented during execution of an instruction that is in an interrupt shadow. In order for this erratum to occur, the other processor core in the compute-unit must be performing microcoded functions that are uncommon in usage.",
        "implication": "Under rare circumstances, a debug exception may occur in an interrupt shadow. Under common software use, this exception does not have a system effect. In the event that system software uses \"STI, RET\" instead of a single IRET instruction, or changes the stack segment simultaneously with the stack pointer (i.e. not using a flat segment for the stack), unpredictable system failure may result. AMD has not observed this erratum with any commercially available software.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "720"
    },
    {
        "title": "Unintercepted Halt Instruction May Cause Protocol Machine Check or Unpredictable System Behavior",
        "problem": "An unintercepted halt instruction executed in guest mode may result in a processor core being in a cache-flush- on-halt state while having VMCB data in the cache.",
        "implication": "Northbridge machine check exception (#MC) for a link protocol error. This machine check exception causes a sync flood and system reset under AMD recommended BIOS settings. The machine check has the following signature: \u2022 The MC4_STAT register (MSR0000_0411) is equal to BA000020_000B0C0F. Bit 62 (error overflow) or bit 59 (miscellaneous valid) of MC4_STAT may or may not be set. \u2022 Bits 5:1 of the MC4_ADDR register (MSR0000_0412) is equal to one of 10011b, 10100b, 11000b or 11001. In addition, it is possible for unpredictable system operation to occur without a machine check exception. For example, a processor core may not observe a write that is performed by another processor core. AMD has not observed this effect in any commercially available software.",
        "workaround": "Hypervisors should intercept HLT instructions by setting VMCB.Intercept_HLT (offset 00Ch bit 24) to 1b.",
        "status": "No fix planned",
        "errnum": "724"
    },
    {
        "title": "Processor May Report Incorrect MCA Address for Loads that Cross Address Boundaries",
        "problem": "In the event that a line fill error or system read data error is reported for some, but not all, bytes of an unaligned load instruction that crosses a cache line boundary (64 bytes), the processor may intermittently report the address of the unaffected cache line in MC0_ADDR (MSR0000_0402).",
        "implication": "None expected.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "726"
    },
    {
        "title": "Processor Core May Hang During CC6 Resume",
        "problem": "During a resume from core C6 (CC6) state, the processor may hang.",
        "implication": "Processor core hang, usually resulting in a system hang.",
        "workaround": "BIOS should set MSRC001_1000[15] = 1b.",
        "status": "No fix planned",
        "errnum": "727"
    },
    {
        "title": "Processor May Incorrectly Store VMCB Data",
        "problem": "Under a highly specific and detailed set of internal timing conditions during a #VMEXIT for a virtual machine guest that has multiple virtual CPUs, the processor may store incorrect data to the virtual machine control block (VMCB) reserved and guest save areas and may also store outside of the VMCB.",
        "implication": "Data corruption.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "734"
    },
    {
        "title": "Processor May Read Branch Status Register With Inconsistent Parity Bit",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor may read an internal branch status register (BSR) while the register is being updated and may observe a partially written entry with an inconsistent parity bit. When the conditions for this erratum occur, the processor does not actually use the contents of this branch status register, however it may report a parity error machine check exception (#MC).",
        "implication": "The processor reports an uncorrectable machine check exception for a branch status register parity error. MC1_STATUS[ErrorCodeExt] (MSR0000_0405[20:16]) = 00110b identifies a branch status register parity error.",
        "workaround": "BIOS should set MSRC001_0045[15] = 1b (MC1_CTL_MASK[BSRP]).",
        "status": "No fix planned",
        "errnum": "739"
    },
    {
        "title": "Lightweight Profiling May Cause System Hang with Concurrent Stop Clock",
        "problem": "The processor may hang if it performs an internal stop-clock event to handle an I/O C-state request or P-state change at approximately the same time that a lightweight profiling (LWP) monitored event overflows its event counter, signalling the need for an LWP event record to be stored. Only LWP record type 2 (instructions retired) or LWP record type 3 (branches retired) events can cause this hang to occur. LWP is enabled once software executes an LLWCP or XRSTOR instruction with a valid LWP control block (LWPCB) address.",
        "implication": "System hang.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "740"
    },
    {
        "title": "DRAM Scrub Request During Register Write May Cause Unpredictable Behavior",
        "problem": "The default BIOS sequence for enabling DRAM scrubbing and performing configuration accesses to enable DRAM phy power savings results in the possibility that a DRAM scrub event is occurring simultaneously to a BIOS write to a register accessed through the DRAM Controller Additional Data Index/Data port of D18F2x98_dct[1:0] and D18F2x9C_dct[1:0]. In the event that these operations occur at the same time, the processor DRAM controller may enter an invalid state. DRAM scrubbing is enabled when the value in Scrub Rate Control Register[DramScrub] (D18F3x58[4:0]) is not equal to 00000b or when the DRAM Scrub Address Low Register[ScrubReDirEn] (D18F3x5C[0]) is equal to 1b. BIOS does not enable DRAM scrubbing unless the DIMMs support ECC.",
        "implication": "All future reads of the memory attached to the affected DRAM controller return unpredictable data. The processor may report, but not necessarily in all circumstances, an uncorrectable DRAM ECC machine check error. The system may hang or reset during the BIOS boot process, or the inconsistent memory data may cause a system crash. This failure is highly intermittent over multiple boot cycles.",
        "workaround": "BIOS should complete all writes to any register in the range of D18F2x9C_x0000_0000_dct[1:0] through D18F2x9C_x0D0F_FFFF_dct[1:0] prior to enabling DRAM scrubbing. Specifically, the writes that are recommended by the BIOS and Kernel Developer's Guide (BKDG) for AMD Family 15h Models 00h-0Fh Processors, order# 42301 section \"DRAM Phy Power Savings\" should be performed earlier in the DCT initialization sequence so that they do not occur while scrubbing is enabled, provided that they are performed after completing DRAM data training.",
        "status": "No fix planned",
        "errnum": "742"
    },
    {
        "title": "Processor CC6 May Not Restore Trap Registers",
        "problem": "Following a core C6 (CC6) power state transition, the processor core may not restore the following registers: \u2022 MSRC001_0053, IO Trap Register 3 \u2022 MSRC001_0052, IO Trap Register 2 \u2022 MSRC001_0051, IO Trap Register 1 \u2022 MSRC001_0050, IO Trap Register 0 Instead, the registers are set to zero when the processor resumes from CC6 state. This erratum only applies on processor models that have a single core per compute-unit (Compute Unit Status Register[DualCore], D18F5x80[16] is 0b).",
        "implication": "The processor may not observe debug traps after the processor has entered and exited CC6 mode.",
        "workaround": "BIOS should not use these trap registers.",
        "status": "No fix planned",
        "errnum": "744"
    },
    {
        "title": "Processor May Incorrectly Report Cache Sharing Property in CPUID Topology",
        "problem": "On processor models that have a single core per compute-unit (Compute Unit Status Register[DualCore], D18F5x80[16] is 0b), CPUID Fn8000_001D_EAX_x1[NumSharingCache, bits 25:15] and CPUID Fn8000_001D_EAX_x2[NumSharingCache, bits 25:15] incorrectly report that the instruction cache and the L2 cache as being shared between two processor cores. On the above-mentioned processor models, the instruction cache and the L2 cache are not shared and software would not find two processor cores that reported the same Compute Unit ID (CPUID Fn8000_001E_EBX[ComputeUnitID, bits 7:0]).",
        "implication": "Software may incorrectly observe the topology of the instruction cache and the L2 cache.",
        "workaround": "None required.",
        "status": "Yes",
        "errnum": "745"
    },
    {
        "title": "One Core May Observe a Time Stamp Counter Skew",
        "problem": "During a P-state change or following a C-state change, the processor core may synchronize an internal copy of the time stamp counter (TSC) incorrectly. The processor may then observe TSC values (e.g., RDTSC, RDTSCP and RDMSR 0000_0010h instructions) or MPERF (MSR0000_000E7) values that do not account for the time spent performing this last P-state or C-state change. This error is normally temporary in nature, in that it may be resolved after the next P-state or C-state change.",
        "implication": "System software or software with multiple threads may observe that one thread or processor core provides TSC values that are behind all of the other threads or processor cores. While a single thread operating on a single core can not observe successively stored TSC values that incorrectly decrement, it is possible that a single thread may be dispatched on one core, where the software observes a TSC, and is then dispatched by the operating system on another core that has encountered the conditions of the erratum. In this sequence of events, the thread may observe a TSC that appears to decrement. In addition, software may calculate a higher effective frequency (APERF, MSR0000_00E8, divided by MPERF).",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "Yes",
        "errnum": "759"
    },
    {
        "title": "Processor May Present More Than One #DB Exception on REP-INS or REP-OUTS Instructions",
        "problem": "When a REP-INSx or REP-OUTSx instruction is interrupted by a system management interrupt (SMI), the processor does not set RFLAGS.RF to 1b in the SMM save state. After the SMM code executes RSM to return from SMM, any debug exception present on the instruction may get presented again.",
        "implication": "Debug software may observe two or more #DB exceptions for a single execution of REP-INS or REP-OUTS instruction.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "775"
    },
    {
        "title": "Processor Core Time Stamp Counters May Experience Drift",
        "problem": "Following a long period in a P-state without any core P-state or C-state activity, the time stamp counter for a processor core may appear to drift slightly from other processor cores. This TSC drift does not occur unless the processor has spent over four billion consecutive clocks in a single P-state at C0. This erratum does not apply if the processor is in the non-boosted software P0 frequency.",
        "implication": "System software or software with multiple threads may observe that one thread or processor core provides TSC values that are behind another thread or processor core. This can only happen if the processor core is spending very long intervals in the C0 (running) state and is either pinned to a software P-state lower than P0, or the application power management (APM) behavior of the software running on this core allows the processor to remain in a boosted state without any changes to the P-state. A single thread operating on a single core can not observe successively stored TSC values that incorrectly decrement.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "778"
    },
    {
        "title": "APIC Timer Periodic Mode is Imprecise",
        "problem": "The APIC timer may not properly initialize back to the APIC timer initial count value (APIC380) when it transitions to zero and Timer Local Vector Table Entry[Mode] (APIC320[17]) is configured to run in periodic mode. In this mode, when the APIC timer reaches zero, the next value in the APIC current count register (APIC390) is set to the APIC initial count (APIC380), but the processor may incorrectly add or subtract an offset that is between 0 and 31.",
        "implication": "The standard use of the APIC timer and the level of accuracy required does not make this error significant.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "786"
    },
    {
        "title": "Processor May Read Partially Updated Branch Status Register",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor may read an internal branch status register (BSR) while the register is being updated resulting in an incorrect rIP.",
        "implication": "The incorrect rIP causes unpredictable program or system behavior, usually observed as a page fault.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "815"
    },
    {
        "title": "Processor May Violate Trp During Dynamic Mode Switch",
        "problem": "The processor may violate the precharge time (Trp) for a DIMM when sending a mode register set (MRS) command to dynamically adjust MR0[PPD] during a precharge power down. This erratum may occur only when fast exit/slow exit (dynamic) mode is selected as follows: \u2022 D18F2x94_dct[1:0][15] = 1b (DRAM Configuration High[PowerDownEn]) \u2022 D18F2x84_dct[1:0][23] = 1b (DRAM MRS[PchgPDModeSel])",
        "implication": "Unpredictable system operation.",
        "workaround": "If D18F2x84_dct[1:0] bit 23 (PchgPDModeSel) = 1b and D18F2x94_dct[1:0] bit 15 (PowerDownEn) = 1b, then precharge time (D18F2x200_dct[1:0]_mp[1:0] bits 20:16, Trp) should be set one higher than the DIMM specified value.",
        "status": "No fix planned",
        "errnum": "638"
    },
    {
        "title": "Memory Arbitration May Stall",
        "problem": "The processor arbitration between CPU, I/O transactions and graphics transactions to the DRAM controller may not recognize and properly prioritize a CPU or I/O transaction that has been marked high priority. This causes the internal transaction arbiter to stall. This stall may occur only if the processor reports D18F3x1FC[29] = 0b (Product Information Register 1[EnDcqChgPriToHigh]).",
        "implication": "The memory bus may stall for excessive periods, causing display buffer under-run (screen corruption).",
        "workaround": "BIOS should set D18F2x408_dct[1:0] bit 0 (GMC to DCT Control 2[CpuElevPrioDis]) = !D18F3x1FC[29] (the inverse of D18F3x1FC bit 29) and should set D18F5x88[14] = D18F3x1FC[29] (without inverting).",
        "status": "No fix planned",
        "errnum": "687"
    },
    {
        "title": "P-State Limit Removal During PC6 Entry May Cause System Hang",
        "problem": "The processor may hang if the following conditions occur: \u2022 A P-state limit has been applied that is actively restricting the current P-state to a lower-performing P-state than is requested by software. This limit may be due to application power management (APM), hardware thermal control (HTC), or Software P-state Limit Register[SwPstateLimit] (D18F3x68[30:28]). \u2022 The P-state limit is an equal or lower performance (higher numbered) P-state than the pop-down P-state (Pop Up and Down P-states Register[PopDownPstate], D18F3xA8[31:29]). \u2022 The P-state limit is removed during the period of time that the processor enters package C6 (PC6) state, i.e., the processor has a new P-state limit that is a lower P-state number (higher performing) than the previously applied P-state limit.",
        "implication": "System hang. While the conditions for the erratum occur during the entry to PC6, the hang is observed during the exit from PC6.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "697"
    },
    {
        "title": "Processor May Not Recognize P-state Limit Changes During Northbridge P-state Transition",
        "problem": "During the period of time that a northbridge P-state transition is in process, a concurrent core P-state limit change may not transition the core P-state to reflect this new limit. The core P-state limit change may be due to application power management (APM), hardware thermal control (HTC), or Software P-state Limit Register[SwPstateLimit] (D18F3x68[30:28]).",
        "implication": "If the core P-state limit changed to a higher P-state limit (i.e., the core P-state is now limited to lower performing P-states), then the processor cores may continue to operate at a P-state that is higher performing than this limit. This may result in a violation of the appropriate thermal design power (TDP). If the core P-state limit changed to a lower P-state limit (i.e., the core P-state is no longer limited to lower performing P-states), then the processor cores may continue to operate at the lower performing P-states. In addition, the processor does not generate an APIC330 interrupt for this P-state limit change.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "698"
    },
    {
        "title": "SB-RMI Access While Northbridge is Power Gated May Cause Interface Hang",
        "problem": "The processor SB-RMI state machine may hang if a SB-RMI access is performed while the northbridge is power gated. The northbridge is power gated when all cores are in the core C6 (CC6) state and the applied C-state Control Register northbridge power gating bit (NbPwrGate[2:0]) is set to 1b (i.e., D18F4x11C[11], D18F4x118[26], or D18F4x118[11] is set to 1b).",
        "implication": "SB-RMI accesses may hang, resulting in failures or timeouts being returned to the platform management software. A warm reset may be necessary for SB-RMI accesses to be restored.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "703"
    },
    {
        "title": "Processor May Hang During Graphics Memory Controller Sequencing",
        "problem": "The processor may hang during a graphics memory controller (GMC) sleep state transitioning. The failure may be processor specific and may be sensitive to temperature.",
        "implication": "System hang.",
        "workaround": "BIOS should set D18F2x408_dct[1:0] bit 31 = 1b.",
        "status": "No fix planned",
        "errnum": "712"
    },
    {
        "title": "Processor May Hang Due to Short Graphics Memory Controller Activity",
        "problem": "The processor may hang if LCLK deep sleep is enabled (LCLK_DEEP_SLEEP_CNTL[EnableDs], GMMx7A0[31] is 1b) and a short burst of activity occurs from the graphics memory controller.",
        "implication": "System hang.",
        "workaround": "BIOS should set GMMx7A0[31] = 0b.",
        "status": "No fix planned",
        "errnum": "713"
    },
    {
        "title": "Processor May Alter Machine Check Registers on a Warm Reset",
        "problem": "The processor may alter warm-reset persistent bits in MC0_STATUS (MSR0000_0401), MC0_ADDR (MSR0000_0402), MC0_MISC (MSR0000_0403), MC2_STATUS (MSR0000_0409), MC2_ADDR (MSR0000_040A), MC2_MISC (MSR0000_040B), MC5_STATUS (MSR0000_0415), MC5_ADDR (MSR0000_0416), MC5_MISC (MSR0000_0417), MC6_STATUS (MSR0000_0419) and MC6_ADDR (MSR0000_040A) during a warm reset. The status bits may be cleared of an actual error indication, or may be written to a non-zero value that does not correlate to an actual machine check error. A machine check exception (#MC) is not created when these registers are incorrectly altered. This erratum is only observed when the processor core operating frequency is less than 900 MHz at the time of the warm reset.",
        "implication": "The operating system software may place the incorrect machine check status information in an error log. In the event that the warm-reset was the result of an actual machine check, the processor may also over-write the machine check information and the reason for the warm reset is not available for diagnostic purposes.",
        "workaround": "Do not operate the processor core frequency less than 900 MHz. Software should not modify any of the P- state[7:0] Registers (MSRC001_00[6B:64]) such that the CpuFid (bits 5:0) and the CpuDid (bits 8:6) specify a core operating frequency that is less than 900 MHz. Some processors have a default configuration where the hardware thermal control (HTC) P-state is configured for a core frequency of 800 MHz. BIOS should perform the following algorithm to adjust this configuration: 1. Read Hardware Thermal Control Register[HtcPstateLimit] (D18F3x64[30:28]) 2. Use this value to index into the P-state Registers to the P-state register used in HTC mode (MSR(C001_0064 + HtcPstateLimit)). 3. Read this MSR and check if bits 8:6 (CpuDid) is 1h and bits 5:0 (CpuFid) is 0h. If these values are not observed, the algorithm ends at this step. 4. Read the MSR of the next higher-performing P-state register (MSR(C001_0064 + HtcPstateLimit - 1)), and save the value for CpuVid (bits 16:9). 5. Write the HTC P-state MSR (MSR(C001_0064 + HtcPstateLimit)) with CpuFid = 2h and the saved CpuVid from the previous step. The other fields in this MSR are unchanged. The above algorithm should be run by BIOS before entering CC6 mode and before enabling hardware thermal control (before writing Hardware Thermal Control Register[HtcEn] (D18F3x64[0]) = 1b).",
        "status": "No fix planned",
        "errnum": "715"
    },
    {
        "title": "Warm Reset After BIOS Changes P-state During Early Boot May Cause System Hang",
        "problem": "A warm reset that occurs following a BIOS change to the P-state may cause a system hang. In order for this erratum to occur, the BIOS change to the P-state must occur while at least one processor core has the corresponding core enable (CpuEn, D18F0x1DC[7:1]) bit clear after a reset.",
        "implication": "System hang.",
        "workaround": "The system BIOS should not perform a P-state change before the core enable bits are set for all cores.",
        "status": "No fix planned",
        "errnum": "716"
    },
    {
        "title": "IOMMU Event Not Flagged when DTE Reserved Bits Are Not Zero",
        "problem": "The processor IOMMU may not generate an event log entry when a translation table walk encounters a valid device table entry (DTE) with reserved bits 8:2 not equal to 000_0000b. The reserved bits are ignored by the processor.",
        "implication": "None expected in the absence of IOMMU host software programming errors. In the presence of IOMMU host software programming errors, the device may receive and report a completion-abort response without an IOMMU event log to diagnose the reason for the completion-abort response. Debug information presented by the processor in the event logs may be missing.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "728"
    },
    {
        "title": "IOMMU Event Log Not Generated for Invalid DTE GCR3 Table Root Pointer",
        "problem": "The processor IOMMU does not generate an event log entry when a translation table walk encounters a valid device table entry (DTE) whose GCR3 table root pointer is not a valid system address. When the IOMMU is operating in nested paging mode, the erratum occurs only if the host page table translations of the GCR3 root pointer translates this address to an invalid system address. Instead, the processor treats this as an IOMMU page fault.",
        "implication": "None expected in the absence of IOMMU host software programming errors. In the presence of IOMMU host software programming errors, debug information presented by the processor in the event logs may be missing or incorrect.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "729"
    },
    {
        "title": "IOMMU Event Log Not Generated for Not Present Host Intermediate Page Tables",
        "problem": "The processor IOMMU, when performing a nested address translation of a guest virtual address to a host physical address, does not generate event logs in the case that the table walk encounters an intermediate (non- leaf) host page table that is not present (valid bit is 0b). The IOMMU does abort this translation request and properly signals an I/O page fault. This erratum does not impact IOMMU operation with peripherals that use address translation service (ATS) in conjunction with peripheral page service requests (PPR). When PPR is not used, the page tables used by the IOMMU translation typically requires \"pinned\" pages where the present or valid bit is always 1b.",
        "implication": "None expected in the absence of IOMMU or memory management software programming errors in the hypervisor or driver software errors in the guest. In the presence of programming errors, the device may receive and report a completion-abort response without an IOMMU event log to diagnose the reason for the completion- abort response. Debug information presented by the processor in the event logs may be missing.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "730"
    },
    {
        "title": "Incorrect Translation with IOMMU v1 512 GB Page Table",
        "problem": "The processor may perform incorrect IOMMU translations using an IOMMU v1 page table that has a page size of 512 GB.",
        "implication": "None expected. In the unlikely event that IOMMU software uses a 512 GB sized page table, unpredictable system behavior may result. AMD has not observed this erratum with any commercially available software.",
        "workaround": "IOMMU software should limit the IOMMU v1 page table such that the page size is never greater than the system memory.",
        "status": "No fix planned",
        "errnum": "731"
    },
    {
        "title": "IOMMU Event Log Ordering Violation",
        "problem": "The processor IOMMU does not maintain producer-consumer ordering between the IOMMU event log DMA writes and IOMMU MMIO register read completions. The processor core may read stale or uninitialized event logs from memory when a read response from the event log tail pointer register passes the corresponding event log DMA write. A series or burst of event log DMA writes would normally be necessary for this ordering violation to be observed.",
        "implication": "Software may process an event log before it has been completely written, possibly resulting in the operating system or Hypervisor taking improper corrective actions.",
        "workaround": "The IOMMU driver of the hypervisor or operating system should initialize the event log buffer to all zeros and write event log entries to zero after they are processed. If software subsequently observes an all zero event log entry, it should re-read the buffer until a non-zero event log is returned. It is recommended that software detects that the log buffer has not been written by checking for an EventCode (bits 63:60) that is equal to 0000b.",
        "status": "No fix planned",
        "errnum": "732"
    },
    {
        "title": "IOMMU PPR Log Ordering Violation",
        "problem": "The processor IOMMU does not maintain producer-consumer ordering between the IOMMU peripheral page service request (PPR) log DMA writes and IOMMU MMIO register read completions. The processor core may read stale or uninitialized PPR logs from memory when a read response from the PPR log tail pointer register passes the corresponding PPR log DMA write. A series or burst of PPR log DMA writes would normally be necessary for this ordering violation to be observed. This erratum only applies in systems where a device is performing Address Translation Service (ATS) requests.",
        "implication": "Software may process a PPR log before it has been completely written, possibly resulting in the IOMMU software not properly processing a page service request. This may result in unpredictable IOMMU behavior.",
        "workaround": "The IOMMU driver of the hypervisor or operating system should initialize the PPR log buffer to all zeros and write PPR log entries to zero after they are processed. If software subsequently observes an all zero PPR log entry, it should re-read the buffer until a non-zero PPR log is returned. It is recommended that software detects that the log buffer has not been written by checking for a PPRCode (bits 63:60) that is equal to 0000b.",
        "status": "No fix planned",
        "errnum": "733"
    },
    {
        "title": "IOMMU Logging May Stall Translations",
        "problem": "The processor IOMMU may stop processing IOMMU translations due to a perceived lack of credits for writing upstream periphial page service request (PPR) or event logs. The IOMMU does not properly register credits after the log request has completed if the L2B miscellaneous clock gating feature is enabled.",
        "implication": "System hang.",
        "workaround": "BIOS should disable L2B miscellaneous clock gating by setting L2_L2B_CK_GATE_CONTROL[CKGateL2BMiscDisable] (D0F2xF4_x90[2]) = 1b.",
        "status": "No fix planned",
        "errnum": "746"
    },
    {
        "title": "IOMMU Interrupt May Be Lost",
        "problem": "The IOMMU may not send a message-signaled interrupt (MSI) if the interrupt becomes pending around a very small timing window while the software is clearing a previous IOMMU interrupt. Once this erratum occurs, message-signaled interrupts are not sent until the software clears the interrupt pending status.",
        "implication": "The IOMMU driver may not receive IOMMU interrupts. This effect may persist and cause the IOMMU to stop processing transactions since the software normally does not clear the interrupt pending status in the absence of an actual interrupt. AMD has only observed this erratum with IOMMU version 2 software.",
        "workaround": "No workaround is recommended for IOMMU version 1 driver software. After clearing interrupts, the IOMMU version 2 driver software should read the interrupt status register and process any pending interrupts.",
        "status": "No fix planned",
        "errnum": "787"
    },
    {
        "title": "DRAM Scrubbing May Overwrite CC6 Core Save State Data Resulting in Unpredictable System Behavior",
        "problem": "The processor does not properly ensure that a DRAM scrub read and write sequence is atomic with respect to simultaneous processor core accesses to the CC6 save area. If a DRAM scrub access is to the same address as a concurrent save of the processor state, the CC6 entry may appear as if it was not written.",
        "implication": "Unpredictable system behavior.",
        "workaround": "BIOS should set Scrub Rate Control D18F3x58[4:0] = 00h to disable sequential DRAM scrubbing. BIOS should set DRAM Scrub Address Low D18F3x5C[0] = 0b to disable re-direct DRAM scrubbing.",
        "status": "No fix planned",
        "errnum": "792"
    },
    {
        "title": "IOMMU IO_PAGE_FAULT Events Are Not Correctly Suppressed When DTE.SA=1 and PTE.PR=0",
        "problem": "IO_PAGE_FAULT events may incorrectly be logged when DTE.SA=1 and PTE.PR=0.",
        "implication": "This behavior has been observed in simulation. To date, no detrimental effects from this behavior have been observed in system.",
        "workaround": "IOMMU driver software may need to ignore extraneous IO_PAGE_FAULT event logs.",
        "status": "No fix planned",
        "errnum": "800"
    },
    {
        "title": "IOMMU IO_PAGE_FAULT Event May Be Logged Instead of INVALID_DEVICE_REQUEST Event",
        "problem": "An IO_PAGE_FAULT event may be logged instead of an INVALID_DEVICE_REQUEST event for untranslated guest requests to the IOMMU with AT=0 and PASID TLP prefix.",
        "implication": "This behavior has been observed in simulation. To date, no detrimental system impact has been observed.",
        "workaround": "IOMMU driver software may need to treat IO_PAGE_FAULT events as INVALID_DEVICE_REQUEST events.",
        "status": "No fix planned",
        "errnum": "801"
    },
    {
        "title": "D-bit May Not Be Set By IOMMU For Untranslated Guest PCIe\u00ae Atomic Requests",
        "problem": "Under specific and detailed pipeline conditions, the IOMMU may not set the D-bit properly when handling untranslated guest PCIe\u00ae atomic requests.",
        "implication": "If a page that should be marked dirty is paged out without IOMMU setting the D-bit, software will incorrectly revert back to the stored page, resulting in unpredictable system behavior. This behavior has been observed in simulation. To date, no detrimental effects from this behavior have been observed in system. No PCIe device that will issue untranslated guest PCIe atomic requests have been encountered.",
        "workaround": "PCIe devices should be programmed not to issue untranslated guest PCIe atomic requests.",
        "status": "No fix planned",
        "errnum": "813"
    },
    {
        "title": "IOMMU Event Not Flagged when Guest PTE Reserved Bits Are Not Zero",
        "problem": "An IOMMU event is not flagged when a translation table walk encounters a guest page table entry (PTE) with non-zero values programmed for MBZ reserved bits 20:13 for a 2 MByte PTE, or bits 30:13 for a 1 GByte PTE. The reserved bits are incorrectly ignored by the IOMMU.",
        "implication": "None expected in the absence of IOMMU software programming errors. This behavior has been observed in simulation. To date, no detrimental effects from this behavior have been observed in system.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "814"
    },
    {
        "title": "IOMMU Always Masks PASID TLP Prefix On PPR Auto Response Regardless Of PRG Response PASID Required Register Bit Setting On PRI Endpoint Devices",
        "problem": "If the IOMMU PPR Auto Response feature is enabled and PPR Log overflow occurs, IOMMU generates PPR responses automatically. However, IOMMU always masks the PASID TLP Prefix in the PPR auto response regardless of the PRG Response PASID Required bit setting by the PRI endpoint devices; it fails to generate PPR response with PASID TLP Prefix even if the PRI request contains a valid PASID TLP Prefix and the originating endpoint device has the PRG Response PASID Required bit set.",
        "implication": "None expected in the absence of PPR Log overflow events. If PRI endpoint devices stay within their quota and PPRLOG is sized appropriately, PPR Log overflow should not happen. In the unlikely event of PPR Log overflow, PRI endpoint devices expecting the PASID TLP Prefix in the PPR auto response and not getting it may cause unpredictable system behavior.",
        "workaround": "IOMMU PPR Auto Response feature should not be used on systems with PRI endpoint devices with PRG Response PASID Required bit = 1 that do not initiate auto retry on incomplete responses.",
        "status": "No fix planned",
        "errnum": "870"
    },
    {
        "title": "Down-cored Processor May Experience Incorrect Machine Check Error (MCE) Reporting via SB-RMI",
        "problem": "Dual core or software down-cored processors may experience incorrect logical core number mapping. This may lead to erroneous MCE status reporting.",
        "implication": "MCE alert event may be incorrectly reported via SB-RMI interface.",
        "workaround": "SB-RMI should not be used on systems with dual core processors or four core processors that may be software down-cored.",
        "status": "<No field for `status`>",
        "errnum": "882"
    },
    {
        "title": "LPC_SMI_L/AGPIO86 Pin On FP4 Package/Socket Does Not Support LPC SMI Function",
        "problem": "LPC SMI function is not supported by the processor LPC_SMI_L/AGPIO86 pin on FP4 package or socket.",
        "implication": "LPC SMI device will not function if connected to LPC_SMI_L/AGPIO86 pin.",
        "workaround": "Connect LPC device SMI pin to any one of the pins according to the information in the section named \"Enabling LPC_SMI Function\" in the BIOS and Kernel Developers Guide (BKDG) for AMD Family 15h Models 60h-6Fh, PID # 50742, revision 3.01 or newer.Connect LPC device SMI pin to any one of the pins according to the information in the section named \"Enabling LPC_SMI Function\" in the BIOS and Kernel Developers Guide (BKDG) for AMD Family 15h Models 70h-7Fh, PID # 55072, revision 1.01 or newer.",
        "status": "No fix planned",
        "errnum": "902"
    },
    {
        "title": "IOMMU Mishandles Invalid COMPLETE_PPR_REQUEST Command",
        "problem": "When IOMMU encounters an invalid COMPLETE_PPR_REQUEST command, it will log the Invalid PPR Request event correctly with RX=1; however, it will not fetch new commands even after software recovers from the INVALID_PPR_REQUEST event and re-enables the command buffer. Invalid COMPLETE_PPR_REQUEST command can be caused by the following conditions: \u2022 out of range DeviceID value, \u2022 out of range PASID value, \u2022 GN=1 when guest translation is not enabled.",
        "implication": "Unpredictable system behavior.",
        "workaround": "Software should not issue an invalid COMPLETE_PPR_REQUEST command.",
        "status": "No fix planned",
        "errnum": "903"
    },
    {
        "title": "IOMMU Unnecessarily Updates Dirty Bit (D-bit) While Handling Non-supervisor DMA Write Request To Writable Supervisor-only Page",
        "problem": "IOMMU incorrectly sets the D-bit in the guest page table when it encounters a DMA write request without supervisor privilege to a writable supervisor-only page.",
        "implication": "No functional issue is expected; the non-permitted DMA write request is aborted without any memory content modification. However, the affected pages may be unnecessarily written out to the pagefile by software.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "911"
    },
    {
        "title": "Unpredictable IOMMU IO_PAGE_FAULT Event Logging For PCIe\u00ae Atomic Requests To Protected Pages",
        "problem": "IOMMU has unpredictable IO_PAGE_FAULT event logging when it encounters a PCIe\u00ae atomic request accessing protected pages. The following might occur when IOMMU encounters PCIe atomic requests accessing protected pages; \u2022 when DTE.SA = 1, IO_PAGE_FAULT might be logged when it should be suppressed, \u2022 when DTE.SA = 0, IO_PAGE_FAULT might be suppressed incorrectly.",
        "implication": "Unpredictable event logging behavior. PCIe atomic requests to protected pages are aborted as expected.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "937"
    },
    {
        "title": "Incorrect IOMMU IO_PAGE_FAULT Event Logging For Reserved Message Type Interrupt Requests With DTE.IG = 1",
        "problem": "IOMMU will log an IO_PAGE_FAULT event when it encounters any reserved message type interrupt request regardless of DTE.IG setting. Even when DTE.IG = 1, IO_PAGE_FAULT event is logged when it should be suppressed.",
        "implication": "Software may encounter unexpected IO_PAGE_FAULT event logging. Reserved message type interrupt requests are aborted as expected.",
        "workaround": "Software may ignore IO_PAGE_FAULT event log entries for reserved message type interrupt requests from devices with DTE.IG = 1.",
        "status": "No fix planned",
        "errnum": "965"
    },
    {
        "title": "Machine Check Information May Show Inconsistent Signature from an Older Corrected Error",
        "problem": "The processor core may not properly overwrite machine check architecture (MCA) information from an older corrected error in MC1_STATUS (MSR0000_0405) and MC1_ADDRESS (MSR0000_0406) when presenting a machine check exception (#MC) for a newer uncorrected error. Although the processor does set processor context corrupt (MC1_STATUS[PCC] bit 57) to 1b and error uncorrected status (MC1_STATUS[UC], bit 61) to 1b, it does not update the remaining bits in the registers.",
        "implication": "The machine check handler may be presented with status and address registers that are not consistent with the cause of the uncorrected error. It is expected that the MCA handler will respond to a #MC when MC1_STATUS[PCC] is set with an operating system panic or crash, regardless of the remaining bits in MC1_STATUS. However, the information pertaining to the actual uncorrected error may be lost. In addition, debug engineers may note that the error signature does not align to MC1 error signatures documented in the BKDG, as the error signature will match a possibly unrelated corrected error except for the UC and PCC bits. This effect only occurs if a processor reports both corrected and uncorrected errors.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "756"
    },
    {
        "title": "L2 Tag Error Machine Check Status May Be Incorrect",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the MC2 status information (MC2_STATUS, MSR0000_0409) for a corrected or uncorrected L2 tag error may not indicate the actual operation that was occurring at the time the error was detected. The status information may report that the processor was performing an L2 fill operation when in reality the error was detected while processing a probe. The MC2_STATUS fields that identify the possibility that this erratum applies (i.e., when MC2_STATUS may improperly indicate a fill operation) are: \u2022 MC2_STATUS[Valid] (bit 63) = 1b \u2022 MC2_STATUS[UC] (bit 61) = 0b or 1b (may be a corrected error or an uncorrected error) \u2022 MC2_STATUS[ErrorCodeExt] (bits 20:16) = 0Bh or 0Fh \u2022 MC2_STATUS[RRRR] (bits 7:4) = 0001b",
        "implication": "None expected.",
        "workaround": "None required.",
        "status": "No fix planned",
        "errnum": "757"
    },
    {
        "title": "Processor APM Behavior May Be Incorrect After CC6",
        "problem": "The processor core may not properly restore internal Application Power Management registers after it exits the core C6 (CC6) state.",
        "implication": "The processor may exceed the specified thermal design power (TDP) or thermal design current (TDC).",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "767"
    },
    {
        "title": "Incorrect Processor Branch Prediction for Two Consecutive Linear Pages",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor core may incorrectly fetch instructions when the instruction pointer (rIP) changes (via a branch or other call, return) between two consecutive linear address 4K pages with the same offset in rIP[11:6].",
        "implication": "Unpredictable system behavior.",
        "workaround": "BIOS should set MSRC001_1021[26] = 1b.",
        "status": "No fix planned",
        "errnum": "776"
    },
    {
        "title": "Initial Time Stamp Counter Frequency May Be Incorrect",
        "problem": "The processor core may increment the core time stamp counter (TSC) at a frequency that is equal to the startup P-state frequency, instead of incrementing the TSC at the software P0 frequency. This effect occurs until the first instance of either a P-state or a C-state change. At the time that the first P-state or C-state change occurs, the actual value in the TSC will adjust as if it had incremented at this P-state rate for the entire duration.",
        "implication": "The BIOS may calculate incorrect time stamps. For example, since the TSC is incrementing at a slower rate than it should increment, calculations of the elapsed time in BIOS boot may appear to be incorrect. In the unlikely event that the system is in a state where one or more cores are affected by the erratum (i.e., those cores have not performed any P-state or C-state changes) and other cores have performed a change, the operating system software may observe TSC synchronization failures during early boot due to the different frequencies. A normal system initialization causes at least one P-state change on all cores before the operating system boots.",
        "workaround": "BIOS must perform a P-state change on all cores prior to the transfer of control to the operating system.",
        "status": "No fix planned",
        "errnum": "779"
    },
    {
        "title": "Improper Handling of ECX Value During RDPMC Instruction",
        "problem": "The processor may return the incorrect northbridge performance counter register, when a RDPMC instruction is executed with ECX equal to 6, 7, 8 or 9.",
        "implication": "Performance monitoring software receives incorrect northbridge performance monitor results.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "781"
    },
    {
        "title": "USB Interrupt Status May Not Be Set After a Short Packet",
        "problem": "The Enhanced Host Controller Interface (EHCI) does not issue an interrupt after processing a short packet when the Interrupt on Completion (IOC) bit in the Transfer Descriptor (TD) is 0b. The specification violation is encountered only when the following conditions apply: \u2022 A USB full-speed or USB low-speed device is attached to the EHCI controller port (USB_HSD[9:0]P/N) through a USB high-speed external hub. \u2022 The USB device is performing bulk or interrupt transfers to the host controller. \u2022 The USB host controller driver (HCD) is not setting the IOC bit on all transfer descriptors.",
        "implication": "USB 2.0 full-speed and low-speed devices connected to EHCI controller port (USB_HSD[9:0]P/N pins) via a high-speed external hub may encounter functional problems.",
        "workaround": "The USB host controller driver should set the Interrupt On Complete bit on all Transfer Descriptors.",
        "status": "No fix planned",
        "errnum": "785"
    },
    {
        "title": "G3 to S5 Power State Transition May Observe Real Time Clock Errors and Other Unpredictable System Behavior",
        "problem": "Internal fusion controller hub (FCH) state may be unpredictable after a transition from G3 (mechanical off) to S5 (soft off) state.",
        "implication": "Unpredictable system behavior.",
        "workaround": "Contact your AMD representative for information on a workaround.",
        "status": "No fix planned",
        "errnum": "789"
    },
    {
        "title": "RDTSCP Instruction Does Not Serialize",
        "problem": "The instruction RDTSCP (Read Time Stamp Counter and Processor ID) does not wait for prior instructions to retire before reading the time stamp counter, as specified by AMD64 Architecture Programmer's Manual Volume 3: General-Purpose and System Instructions, order# 24594.",
        "implication": "Programs that rely on the serialization of the RDTSCP instruction may observe incorrect results. For example, the program may observe a time stamp counter value that was fetched before all previous instructions were retired - possibly causing anomalies in timing and performance monitoring software.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "791"
    },
    {
        "title": "Specific Combination of Writes to Write Combined Memory Types and Locked Instructions May Cause Core Hang",
        "problem": "Under a highly specific and detailed set of internal timing conditions, a locked instruction may trigger a timing sequence whereby the write to a write combined memory type is not flushed, causing the locked instruction to stall indefinitely.",
        "implication": "Processor core hang.",
        "workaround": "BIOS should set MSRC001_1020[15] = 1b.",
        "status": "No fix planned",
        "errnum": "793"
    },
    {
        "title": "Performance Monitor PMCx076 May Be Inaccurate and Lose Overflow Interrupts When Halted",
        "problem": "PMCx076, CPU Clocks Not Halted, should not increment whenever the core is in a halted state - e.g. due to a stop clock, I/O C-state or HALT instruction. However, the processor may continue to incorrectly increment this performance counter in these states. This may result in the performance monitor counter being incorrect. In addition, since overflows are not signaled in these states, an overflow interrupt may be lost.",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "<KB or ML>Contact your AMD representative for information on a BIOS update. </KB or ML><ON>None.</ON>",
        "status": "No fix planned",
        "errnum": "794"
    },
    {
        "title": "Core Performance Monitor Counters May Appear to be Cleared to Zero in the Least Significant 32 Bits",
        "problem": "Core performance monitor counters may appear to clear to zero the least significant 32 bits of the count if disabled at the cycle that a carry-out from the least significant 32 bits to the most significant 16 bits of the counter occurs. Conditions which cause the counter to be disabled and may cause this erratum to be observed when: \u2022 Explicitly disabled by software through PERF_CTL[22] \u2022 The PMC is designated to count only in user or OS mode (PERF_CTL[17] is not equal to PERF_CTL[16]) and a change in the current privilege level (CPL) occurs \u2022 The PMC is designated to count only in guest or host mode (PERF_CTL[41] is not equal to PERF_CTL[40]) and a change between guest and host mode occurs",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None.",
        "status": "No fix planned",
        "errnum": "795"
    },
    {
        "title": "Time Stamp Counter (TSC) value may be incorrect upon resume from S3 state",
        "problem": "Upon resume from S3 state, the TSC value may not monotonically increment.",
        "implication": "Software may observe that the Time Stamp Counter (TSC) appears to decrement which could result in a program crash.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No fix planned",
        "errnum": "798"
    },
    {
        "title": "U-bit May Not be Set Properly by IOMMU in the ATS Response for GVA-SPA Translations",
        "problem": "The IOMMU incorrectly propagates the U-bit from a page table entry to an ATS response when translating guest virtual addresses to system physical addresses instead of forcing it to 0b as described in the IOMMU specification.",
        "implication": "If the U-bit is propagated as 1b, devices would not be able to use pre-translated requests after receiving the address translation service response. This issues was observed in simulations and, to date, there have been no detrimental impacts seen in systems.",
        "workaround": "IOMMU driver software should ensure that the U-bit in the PTE is always set to 0b.",
        "status": "No fix planned",
        "errnum": "799"
    },
    {
        "title": "IOMMU Incorrectly Issues Guest Page Table Walk Request as Non-coherent Request",
        "problem": "When software issues a guest table walk request with DTE.SD=1, IOMMU will issue the table walk request as a non-coherent request just based on the DTE.SD value. It ignores the intermediate guest page PTE.FC value to properly determine if the guest page table walk request should be a coherent request.",
        "implication": "A guest page table walk request is issued as non-coherent instead of coherent even when host PTE.FC (Force Coherent) is set.",
        "workaround": "Software should program DTE.SD=0.",
        "status": "No fix planned",
        "errnum": "913"
    },
    {
        "title": "USB tPortConfiguration Timer Incorrectly Resets During Recovery Before LMP (Link Management Packet) Exchange",
        "problem": "If the USB link transitions through Recovery before the LMPs are exchanged successfully in U0 state, the tportConfiguration timer erroneously resets during Recovery and restarts once the link enters U0.",
        "implication": "None. There is no interoperability or compliance issue because the controller is able to exchange the Port Capability and Port Configuration LMPs after transiting to U0.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "919"
    },
    {
        "title": "IOMMU Event Not Logged When Software Programs DTE.HAD Bits Incorrectly",
        "problem": "IOMMU fails to log an ILLEGAL_DEV_TABLE_ENTRY event when it encounters software setting of DTE.HAD (Host Access and Dirty Update) bits that is inconsistent with what EFR (Extended Feature Register) specifies. The following are the invalid programming scenarios: \u2022 HASup == 0 & DTE.HAD != 00b. \u2022 HASup == 1 & HDSup == 0 & DTE.HAD == 1xb. \u2022 HASup == 1 & HDSup == 1 & DTE.HAD == 10b.",
        "implication": "Unpredictable system behavior when software does not program DTE.HAD correctly.",
        "workaround": "Software should program DTE.HAD bits according to the AMD I/O Virtualization Technology (IOMMU) Specification, order# 48882, revision 2.63 or later.",
        "status": "No fix planned",
        "errnum": "923"
    },
    {
        "title": "MCA_MISC0[BlkPtr] May Contain Incorrect Value",
        "problem": "If CPUID_Fn80000007_EBX[ScalableMca] == 1b, the MCA_MISC0[BlkPtr] field is used to indicate the presence of the additional MISC registers. This field is set to 1 regardless of whether additional MISC registers are present.",
        "implication": "None expected.",
        "workaround": "System software must program the MCA_MISC0[BlkPtr] field to 00h in each MCA_MISC0 register except MCA_MISC0_UMC. System software must program the MCA_MISC0[BlkPtr] to 01h in MCA_MISC0_UMC. System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "931"
    },
    {
        "title": "Processor Will Shut Down If It Issues a Load That Consumes Poison Data When Error Reporting is Disabled",
        "problem": "If MCA_CTL_LS[DcDataErr1]==0 and MCG_CTL[LS]==1, the processor will shut down if it issues a load that consumes poison data. This configuration is unsupported except for platform firmware during the boot phase.",
        "implication": "System shutdown during boot if an uncorrectable error occurs.",
        "workaround": "If platform firmware wishes to enable error logging in the MCA, it should program the following registers: \u2022 MCA_CONFIG_LS[McaxEn] to 1b \u2022 MCA_CTL_LS[63:0] to FFFF_FFFF_FFFF_FFFFh \u2022 MCG_CTL[0] to 1b \u2022 CR4.MCE to 1b These settings will cause a machine check exception to be generated on an error, which platform firmware must handle. Once handled, the platform firmware can continue operation. Alternatively, if platform firmware does not wish to enable exceptions, platform firmware should program the following register: \u2022 MCG_CTL[0] to 0b This setting will cause the processor to ignore errors in the load-store unit and will allow the machine to survive poison data consumption. Platform firmware may poll other MCA banks to look for errors that occur during boot (e.g., platform firmware may poll the MCA banks associated with the memory controller to look for DRAM ECC errors). Before passing control to the operating system, platform firmware should restore the previous state of these registers.",
        "status": "No fix planned",
        "errnum": "954"
    },
    {
        "title": "Processor May Stall If Error Reporting is Disabled and a Cacheable Lock or Table-Walk Load Encounters a Master Abort, Target Abort, or Protection Violation",
        "problem": "If MCG_CTL[LS]==1, and MCA_CTL_LS[SystemReadDataErrorT0]==0 or MCA_CTL_LS[SystemReadDataErrorT1]==0, the processor may stall if it issues a cacheable lock or table-walk load that encounters a master abort, target abort, or protection violation. The error may also not be logged. This configuration is unsupported except for platform firmware during the boot phase. Because cacheable locks and table-walk loads must be issued to DRAM, these aborts and violations are not expected to occur.",
        "implication": "The system may hang or reset.",
        "workaround": "If platform firmware wishes to enable error logging in the MCA, it should program the following registers: \u2022 MCA_CONFIG_LS[McaxEn] to 1b \u2022 MCA_CTL_LS[63:0] to FFFF_FFFF_FFFF_FFFFh \u2022 MCG_CTL[0] to 1b \u2022 CR4.MCE to 1b These settings will cause a machine check exception to be generated on an error, which platform firmware must handle. Once handled, the platform firmware can continue operation. Before passing control to the operating system, platform firmware should restore the previous state of these registers.",
        "status": "No fix planned",
        "errnum": "955"
    },
    {
        "title": "Certain Performance Counters For Retire Based Events May Overcount",
        "problem": "The processor may experience sampling inaccuracies that may cause the following performance counters to overcount retire-based events when PMCx022[4] is not equal to zero: \u2022 PMCx002 [Retired x87 Floating Point Operations] \u2022 PMCx003 [Retired SSE/AVX Operations] \u2022 PMCx005 [Retired Serializing Ops] \u2022 PMCx0CB [Retired MMX/FP Instructions]",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "990"
    },
    {
        "title": "FERR (Legacy Floating Point Error) for Thread 0 May be Incorrectly Cleared When Thread 1 Clears Its FERR",
        "problem": "Under a highly specific and detailed set of internal timing conditions, if thread 0 enters HALT or MWAIT with a pending FERR, then if thread 1 clears its FERR, the FERR for thread 0 may also incorrectly be cleared.",
        "implication": "Unpredictable system behavior.",
        "workaround": "None",
        "status": "Yes",
        "errnum": "1017"
    },
    {
        "title": "Load Operation May Receive Stale Data From Older Store Operation",
        "problem": "Under a highly specific and detailed set of internal timing conditions, a load operation may incorrectly receive stale data from an older store operation.",
        "implication": "Data corruption.",
        "workaround": "Program MSRC001_1029[13] to 1b. System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1021"
    },
    {
        "title": "Performance Monitor Counter Overflow Interrupts May Fail To Be Delivered When Two or More Counters Are Enabled",
        "problem": "Under a highly specific and detailed set of internal timing conditions, when two or more performance monitor counters on the same thread are enabled to generate an interrupt on a counter overflow, they may stop generating interrupts after the first performance monitor counter interrupt event.",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None. Performance monitor counter overflow interrupts will be delivered correctly if only a single performance monitor counter is enabled per thread.",
        "status": "Yes",
        "errnum": "1023"
    },
    {
        "title": "Cacheable Load Following Misaligned Cacheable Store Does Not Complete",
        "problem": "Under a highly specific and detailed set of internal timing conditions, if a misaligned cacheable store is followed by a cacheable load to a cache line with overlapping address bits [11:0], the load does not complete.",
        "implication": "The system may hang or reset.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1024"
    },
    {
        "title": "A Lock Operation May Cause the System to Hang",
        "problem": "Under a highly specific and detailed set of internal timing conditions, a Lock operation may cause the system to hang.",
        "implication": "The system may hang or reset.",
        "workaround": "Program MSRC001_1020[4] to 1b. System software may contain the workaround for this erratum.",
        "status": "Yes",
        "errnum": "1033"
    },
    {
        "title": "Processor May Return Incorrect Faulting Linear Address For a Cacheline-Misaligned Store",
        "problem": "The processor may return incorrect value when reporting the faulting linear address for a cacheline-misaligned store that is not page-misaligned. \u2022 For a non-nested page fault, CR2[11:0] may be incorrect. \u2022 For a nested page fault, EXITINFO2[11:0] of VMCB (Virtual Machine Control Block) may be incorrect.",
        "implication": "None, as long as software does not depend on the byte address of faulting cacheline-misaligned store.",
        "workaround": "If software requires bits [11:0] of the faulting address, then software may decode this information from the faulting X86 instruction and ignore information from EXITINFO2[11:0] or CR2[11:0]. \u2022 For non-nested page faults the faulting rIP can be used to read the instruction bytes. \u2022 For nested page faults the Guest Instruction Bytes field in the VMCB provides the instruction to be decoded.",
        "status": "Yes",
        "errnum": "1034"
    },
    {
        "title": "When IOMMU Interrupt Remapping Is Enabled the Remapped TM (Trigger Mode) Bit Is Incorrectly Ignored",
        "problem": "When IOMMU interrupt remapping is enabled the remapped TM (trigger mode) bit in the IOMMU interrupt remapping table entry is incorrectly ignored, and as a result all remapped interrupts will have TM=0 indicating edge-triggered mode.",
        "implication": "Remapped interrupts with TM=1 indicating level-triggered mode will result in IO devices not receiving EOI (end of interrupt).",
        "workaround": "No workaround. Only use devices with edge-triggered interrupts.",
        "status": "Yes",
        "errnum": "1036"
    },
    {
        "title": "USB 2.0 Device May Immediately Reconnect After Windows\u00ae \"Safely Remove Hardware\" Procedure",
        "problem": "If Selected Suspend is enabled, a USB 2.0 device may immediately be reconnected after the Windows\u00ae \"Safely Remove Hardware\" procedure completes.",
        "implication": "A USB 2.0 device may remain attached to the system after undergoing the Windows\u00ae \"Safely Remove Hardware\" procedure.",
        "workaround": "To avoid this issue the USB driver should not program the xHCI controller in D3 state when the last connected USB 2.0 device is disabled as a result of the Windows\u00ae \"Safely Remove Hardware\" procedure.",
        "status": "No fix planned",
        "errnum": "1037"
    },
    {
        "title": "xHCI Controller May Incorrectly Drop USB 3.0 ISOC Audio Packets",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the xHCI controller may incorrectly drop USB 3.0 ISOC audio packets.",
        "implication": "Audio stuttering during video playback.",
        "workaround": "To avoid this issue the USB driver should disable U1 and U2 states for the AMD USB device with vendor ID 0x1022 (USB:ROOT_HUB\\VID_1022) and PCI\u00ae device ID 0x145C (USB:ROOT_HUB\\PID_145C).",
        "status": "Yes",
        "errnum": "1038"
    },
    {
        "title": "Non-Cacheable Coherent Store May Not Complete If it Follows a Cacheable Access to the Same Cache Line",
        "problem": "Under a highly specific and detailed set of internal timing conditions, a non-cacheable coherent store may not complete if it follows a cacheable access to the same cache line.",
        "implication": "The system may hang or reset.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "Yes",
        "errnum": "1039"
    },
    {
        "title": "Processor May Fail To Boot On Systems With Both SPI (Serial Peripheral Interface) and Discrete TPM (Trusted Platform Module) Enabled",
        "problem": "Under a highly specific and detailed set of internal timing conditions, processor may hang while booting on a system when the following conditions occur: \u2022 both SPI (Serial Peripheral Interface) and discrete TPM (Trusted Platform Module) modules enabled, and \u2022 SPI ROM read prefetching is enabled.",
        "implication": "System hang while booting.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1042"
    },
    {
        "title": "IOMMU May Fail to Deliver an Interrupt or Incorrectly Send an Interrupt to the Host OS",
        "problem": "IOMMU may fail to deliver an interrupt or incorrectly send an interrupt to the host OS under the following conditions: \u2022 The vAPIC (Virtual Advanced Programmable Interrupt Controller) backing page is programmed in IRTE (Interrupt Remapping Table Entry), and \u2022 GA (Guest Virtual APIC) mode is enabled.",
        "implication": "Unpredictable system behavior.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1043"
    },
    {
        "title": "PCIe\u00ae Controller May Hang on Entry Into Either L1.1 or L1.2 Power Management Substate",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the PCIe\u00ae controller may hang on entry into either L1.1 or L1.2 power management substate. This failure occurs when L1 power management substate exit is triggered by a link partner asserting CLKREQ# prior to the completion of the L1 power management stubstates entry protocol.",
        "implication": "The system may hang or reset.",
        "workaround": "Disable L1.1 and L1.2 power management substates. System software may contain the workaround for this erratum.",
        "status": "Yes",
        "errnum": "1044"
    },
    {
        "title": "Miss Address Buffer Performance Counter May Be Inaccurate",
        "problem": "The processor may experience sampling inaccuracies in the the following performance counter: \u2022 MSRC001_1037[DcMissNoMabAlloc] may not be set.",
        "implication": "Performance monitoring software may experience inaccuracies.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1047"
    },
    {
        "title": "Three-Source Operand Floating Point Instructions May Block Another Thread on the Same Core",
        "problem": "An uninterrupted stream of three-source operand floating point instructions (e.g. FMA3) on one thread may block floating point instructions from completing on the other thread of the same core. A cache miss or a TLB miss or a branch misprediction would be sufficient to interrupt the stream of three-source operand floating point instructions and prevent the problem.",
        "implication": "Unpredictable system behavior.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1048"
    },
    {
        "title": "FCMOV Instruction May Not Execute Correctly",
        "problem": "Under a highly specific and detailed set of internal timing conditions, an FCMOV instruction may yield incorrect data if the following sequence of events occurs: \u2022 An FCOMI instruction \u2022 A non-FP instruction that modifies RFLAGS \u2022 An FCMOV instruction",
        "implication": "Incorrect results from FCMOV instruction.",
        "workaround": "Program MSRC001_1028[4] to 1b. System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1049"
    },
    {
        "title": "When SMAP is Enabled and EFLAGS.AC is Set, the Processor Will Fail to Page Fault on an Implicit Supervisor Access to a User Page",
        "problem": "When SMAP (Supervisor Mode Access Protection) is enabled and EFLAGS.AC is set to 1b, the processor will fail to page fault on an implicit supervisor access to GDT (Global Descriptor Table), LDT (Local Descriptor Table), IDT (Interrupt Descriptor Table), or TSS (Task State Segment) when they are located in a user page.",
        "implication": "If the system data structures GDT, LDT, IDT, or TSS are located in a user page, then an implicit supervisor access may incorrectly gain access to that user page.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1053"
    },
    {
        "title": "Instructions Retired Performance Counter May Be Inaccurate",
        "problem": "The processor may experience sampling inaccuracies that may cause the MSRC000_00E9 Read-Only Instructions Retired performance counter to count inaccurately after the processor exits the Core C6 (CC6) state.",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1054"
    },
    {
        "title": "MWAIT or MWAITX Instructions May Fail to Correctly Exit From the Monitor Event Pending State",
        "problem": "In the event that the following sequence occurs, a store from another core that matches the MONITOR or MONITORX address range will not cause an exit from the monitor event pending state: \u2022 A thread executes a MONITOR or MONITORX instruction. \u2022 The other thread on the same core changes CR0.CD to 1b. This asserts cache disable for both threads. \u2022 The first thread reads memory to check for desired value. \u2022 The first thread executes an MWAIT or MWAITX instruction.",
        "implication": "Unpredictable system behavior.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1057"
    },
    {
        "title": "Executing Code in the Page Adjacent to a Canonical Address Boundary May Cause Unpredictable Results",
        "problem": "Under a highly specific and detailed set of internal timing conditions, executing code in the page adjacent to a canonical address boundary may cause unpredictable results.",
        "implication": "Unpredictable system behavior.",
        "workaround": "Supervisor level software (operating systems and hypervisors) should create a guard page between the end of the user-mode accessible virtual address space and the beginning of the non-canonical area to prevent this issue.",
        "status": "No fix planned",
        "errnum": "1058"
    },
    {
        "title": "In Real Mode or Virtual-8086 Mode MWAIT or MWAITX Instructions May Fail to Correctly Exit From the Monitor Event Pending State",
        "problem": "Under a highly specific and detailed set of internal timing conditions, if a thread executes a MONITOR or MONITORX instruction in real mode or virtual-8086 mode, a store from another core that matches the MONITOR or MONITORX address range may not cause an exit from the monitor event pending state.",
        "implication": "Unpredictable system behavior.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1059"
    },
    {
        "title": "PCIe\u00ae Controller Will Generate MSI (Message Signaled Interrupt) With Incorrect Requestor ID",
        "problem": "The PCIe\u00ae controller will generate MSIs with an incorrect Requestor ID of 0x0 on internal interrupt events including: \u2022 Hot-plug \u2022 PME (Power Management Event) \u2022 AER (Advanced Error Reporting) \u2022 DPC (Dynamic Power Control) \u2022 Link Equalization \u2022 Link Bandwidth Notification",
        "implication": "Interrupts generated with an invalid Requestor ID may be blocked by the IOMMU if interrupt remapping is enabled; an error log may be generated. Hot-plugged PCIe\u00ae devices will not be configured.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1063"
    },
    {
        "title": "L3 Performance Event Counter May Be Inaccurate",
        "problem": "The processor may experience sampling inaccuracies that may cause the L3 Performance Event counter MSRC001_0231 to count inaccurately if \u2022 MSRC001_0230[EventSel] = 0x6, and \u2022 MSRC001_0230[8] (UnitMask[0]) = 1b.",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1067"
    },
    {
        "title": "16-bit Real Mode Applications May Fail When Virtual Mode Extensions (VME) Are Enabled",
        "problem": "A 16-bit real mode application may become unresponsive on a system running 32-bit operating system with Virtual Mode Extensions (VME) enabled.",
        "implication": "Unpredictable behavior of 16-bit applications on systems running 32-bit operating systems.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1070"
    },
    {
        "title": "Spurious Level 2 Branch Target Buffer (L2 BTB) Multi- Match Error May Occur",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor may incorrectly log a Level 2 Branch Target Buffer Multi-Match error in MCA_STATUS_IF with extended error code 0xB.",
        "implication": "Spurious L2 BTB Multi-Match error may be logged. If MCA error thresholding is enabled by programming MCA_MISC0_IF[CntEn]=1, the error counter may exceed its threshold and cause the processor to generate threshold overflow interrupts.",
        "workaround": "System software may contain the workaround for this erratum. Software should not enable MCA error thresholding in MCA_MISC0_IF[CntEn] to avoid spurious threshold overflow interrupts.",
        "status": "No fix planned",
        "errnum": "1071"
    },
    {
        "title": "CPUID Fn8000_0007_EDX[CPB] Incorrectly Returns 0",
        "problem": "CPUID Fn8000_0007_EDX[CPB] incorrectly returns 0, indicating the processor does not support Core Performance Boost (CPB). However, the processor does support CPB.",
        "implication": "Software may fail to use Core Performance Boost.",
        "workaround": "Software may ignore CPUID Fn8000_0007_EDX[CPB] and use the Core Performance Boost feature.",
        "status": "Yes",
        "errnum": "1076"
    },
    {
        "title": "PCIe\u00ae Link Exit to L0 in Gen1 Mode May Incorrectly Trigger NAKs",
        "problem": "When the PCIe\u00ae link is operating in Gen1 mode and enters electrical idle, the EDB (EnD Bad symbol which marks the end of a nullified Transaction Layer Packet) token is mistakenly forwarded upstream. This unexpected EDB token may incorrectly trigger NAKs (Negative Acknowledgements) when the link exits to L0.",
        "implication": "Unexpected NAKs may cause a device operating in PCIe\u00ae Gen1 mode to report correctable errors.",
        "workaround": "If AER (Advanced Error Reporting) is not enabled, no workaround is required. If AER (Advanced Error Reporting) is enabled, system software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1080"
    },
    {
        "title": "Programming MSRC001_0015 [Hardware Configuration] (HWCR)[CpbDis] Does Not Affect All Threads In The Socket",
        "problem": "The effect of programming MSRC001_0015 [Hardware Configuration] (HWCR)[CpbDis] is only local to the thread performing the write. The effect is not applied to the other threads in the socket.",
        "implication": "Software that assumes MSRC001_0015 [Hardware Configuration] (HWCR)[CpbDis] to have global effect may not have the desired results.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1081"
    },
    {
        "title": "PCIe\u00ae Link in Gen3 Mode May Incorrectly Observe EDB Error and Enter Recovery",
        "problem": "In Gen 3 mode, the PCIe\u00ae Root Port receiver may miss the TLP (Transaction Layer Packet) after a SKP if no IDL is sent before the SKP, causing the port to log a correctable error before the TLP is recovered. This scenario can only happen if the SKP Ordered Set contains 0xC0, causing spurious EDB (EnD Bad symbol) error.",
        "implication": "An error-free TLP may be observed as a Bad TLP (correctable error) and cause the link to enter recovery.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1083"
    },
    {
        "title": "xHCI Host May Fail To Respond to Resume Request From Downstream USB Device Within 1 ms",
        "problem": "xHCI host may fail to rebroadcast the resume signaling within 1 ms upon receiving resume signal from a downstream hub or device.",
        "implication": "Downstream USB hubs or devices requiring a resume signaling response within 1 ms from the xHCI host may malfunction.",
        "workaround": "For USB hubs or devices that have this requirement in a Microsoft\u00ae operating system based system, apply the Microsoft approved \"ResetOnResume\" USB device registry entry which forces the USB driver stack to reset a device on port resume. The full description of the registry entry can be found in the Microsoft article at https://msdn.microsoft.com/en- us/library/windows/hardware/jj649944(v=vs.85).aspx. For example, if the affected USB device has a DeviceInstance value of xxxxyyyyzzzz where \u2022 xxxx is a 4-digit hexadecimal number that identifies the vendor, \u2022 yyyy is a 4-digit hexadecimal number that identifies the product and \u2022 zzzz is a 4-digit hexadecimal number that contains the revision number of the device, then the registry key for the affected device is as follows: \u2022 [HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\usbflags\\xxxxyyyyzzzz] \u2022 \"osvc\"=hex:00,00 \u2022 \"ResetOnResume\"=hex:00,01 For USB hubs or devices that have this requirement in a Linux\u00ae operating system based system, apply the workaround described in the article at https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/ drivers/usb/core?h=v4.13-rc5&id=e788787ef4f9c24aafefc480a8da5f92b914e5e6. Customers should contact their Operating System Vendor for availability of this workaround.",
        "status": "No fix planned",
        "errnum": "1084"
    },
    {
        "title": "4K Address Boundary Crossing Load Operation May Receive Stale Data",
        "problem": "Under a highly specific and detailed set of internal timing conditions, a load operation may incorrectly receive stale data when the following conditions are met: \u2022 there is a preceding store operation to the same address as the load operation, and \u2022 the load operation crosses a 4K address boundary.",
        "implication": "In the unlikely event that the condition described above occurs, a load operation would receive stale data that was not updated by the most current write from another logical processor.",
        "workaround": "Program MSRC001_102D[34] to 1b. System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1091"
    },
    {
        "title": "USB Device May Not be Enumerated After Device Reset",
        "problem": "The xHCI controller will ignore the ERDY response from a USB device and timeout incorrectly when the following conditions occur: \u2022 Two or more USB devices are attached either directly to the processor or indirectly via USB hub, \u2022 Reset Device Command is received by any of the USB devices other than the last connected one, causing the USB device to reset and to assume default state with device address 0, \u2022 Software then schedules a new control transfer (e.g. Get_Descriptor command) other than the Set_Address command to the USB device, resulting in a ERDY response from the USB device with address 0. As a result, the USB device is not enumerated correctly after device reset.",
        "implication": "USB device that is not enumerated will not function properly.",
        "workaround": "Software should always perform Set_Address Command before any other control transfer after Device Reset Command.",
        "status": "No fix planned",
        "errnum": "1092"
    },
    {
        "title": "Potential Violation of Read Ordering In Lock Operation In SMT (Simultaneous Multithreading) Mode",
        "problem": "Under a highly detailed and specific set of internal timing conditions, a lock operation may not fence a younger load operation correctly when the following conditions are met: \u2022 SMT (Simultaneous Multithreading) is enabled, and \u2022 a lock operation on memory location A, followed by a load operation on memory location B are executing on one thread while \u2022 a lock operation on memory location B, followed by a load operation on memory location A are executing on the second thread on the same core. This may result in the load operations on both threads incorrectly receiving pre-lock data.",
        "implication": "In the unlikely event that the condition described above occurs, a load operation would receive stale data that was not updated by the most current write from another logical processor.",
        "workaround": "Program MSRC001_1020[57] to 1b. System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1095"
    },
    {
        "title": "The GuestInstrBytes Field of the VMCB on a VMEXIT May Incorrectly Return 0h",
        "problem": "On a nested data page fault when CR4.SMAP = 1 and the guest data read generates a SMAP violation, the GuestInstrBytes field of the VMCB on a VMEXIT will incorrectly return 0h instead the correct guest instruction bytes.",
        "implication": "A hypervisor will not be able use the GuestInstrBytes field of the VMCB on a VMEXIT to determine what instruction the guest operating system was executing.",
        "workaround": "To determine what instruction the guest was executing the hypervisor will have to decode the instruction at the instruction pointer.",
        "status": "No fix planned",
        "errnum": "1096"
    },
    {
        "title": "MCA Error May Incorrectly Report Overflow Condition",
        "problem": "The MSR0000_0001[62] (MCA_STATUS_LS[Overflow]) may be incorrectly set when an MCA error is logged and MSR0000_0001[21:16] (MCA_STATUS_LS[ErrorCodeExt]) is 0x9 (SystemReadDataErrorT0) or 0xa (SystemReadDataErrorT1).",
        "implication": "None",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1108"
    },
    {
        "title": "MWAIT Instruction May Hang a Thread",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the MWAIT instruction may cause a thread to hang in SMT (Simultaneous Multithreading) Mode.",
        "implication": "The system may hang or reset.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1109"
    },
    {
        "title": "Response Transaction May be Lost on Data Fabric",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the CAKE (Data Fabric Coherent AMD socKet Extender) may lose a response transaction.",
        "implication": "System may hang or reset",
        "workaround": "Program \u2022 D18F3x2A4[28:25] to 4h, and \u2022 D18F3x2A4[11:8] to 4h System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1140"
    },
    {
        "title": "PCIe\u00ae DPC (Downstream Port Containment) RP PIO (Root Port Programmed I/O) Error Reporting May Not Function Correctly",
        "problem": "The system resets to a state where an unmasked RP PIO error may produce unpredictable system behavior. The DPC Extended Capability RP PIO SysError (PCIERCCFG::PCIE_RP_PIO_SYSERROR) register incorrectly inverts the sense of its enable bits, so that a bit value of 0b enables the function and a bit value of 1b disables the function. In addition, when enabled an RP PIO System Error may not be handled correctly by the processor resulting in unpredictable system behavior. The reset value of PCIERCCFG::PCIE_RP_PIO_SYSERROR is 0000_0000h which, due to the inversion of the bits, enables RP PIO errors to be reported as a System Error. While the value of PCIERCCFG::PCIE_RP_PIO_SYSERROR is 0000_0000h, clearing any of the mask bits in PCIERCCFG::PCIE_RP_PIO_MASK will allow the corresponding error to be reported as a System Error.",
        "implication": "Unpredictable system behavior.",
        "workaround": "Program PCIERCCFG::PCIE_RP_PIO_SYSERROR[18:0] to 7_0707h. This disables the DPC RP PIO System Error feature. System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1146"
    },
    {
        "title": "PCIe\u00ae Incorrectly Updates Some AER (Advanced Error Reporting) Registers After Egress Blocking Error",
        "problem": "When a PCIe egress blocking error occurs, PCIe will incorrectly update the following AER registers: \u2022 Header Log Register \u2022 TLP Prefix Log Register \u2022 Root Error Status register, Multiple ERR_FATAL/NONFATAL Received bit.",
        "implication": "After a PCIe egress blocking error, the system will not have access to accurate diagnostic information contained in the affected registers.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1150"
    },
    {
        "title": "MOV SS Instructions May Take Multiple Breakpoints",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the MOV SS instruction may prematurely clear the RFLAGS RF bit if: \u2022 RFLAGS TF bit is asserted, and \u2022 the instruction hits a debug breakpoint, and \u2022 an interrupt is taken by the affected instruction before it completes.",
        "implication": "The affected instruction may take multiple instruction breakpoints.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1154"
    },
    {
        "title": "DMA or Peer-to-peer Accesses Using Guest Physical Addresses (GPAs) May Cause IOMMU Target Abort",
        "problem": "In systems where: \u2022 Virtualization is enabled, and \u2022 IOMMU is in pass-through mode DMA or peer-to-peer accesses using Guest Physical Addresses (GPAs) occurring within the regions defined below trigger a target abort. \u2022 0x00FD_0000_0000->0x00FD_F8FF_FFFF, or \u2022 0x00FD_F910_0000->0x00FD_F91F_FFFF, or \u2022 0x00FD_FB00_0000->0x00FD_FFFF_FFFF",
        "implication": "A DMA device will receive a target abort from the IOMMU.",
        "workaround": "System software must mark the following block of memory as reserved: \u2022 FD_0000_0000 -> FD_FFFF_FFFF",
        "status": "No fix planned",
        "errnum": "1155"
    },
    {
        "title": "PCIe\u00ae Link Status May be Incorrect When Root Port Autonomously Changes to Gen4 Speed",
        "problem": "When the PCIe\u00ae root port autonomously changes to Gen4 speed, the following will occur: \u2022 Link Status Register (Offset 12h) [15] Link Autonomous Bandwidth Status will incorrectly not be asserted. If Link Status Control (Offset 10h) [15] Link Autonomous Bandwidth Interrupt Enable is asserted, an interrupt may fail to occur. \u2022 Link Status Register (Offset 12h) [14] Link Bandwidth Management Status will be incorrectly asserted. If Link Status Control (Offset 10h) [14] Link Bandwidth Management Interrupt Enable is asserted, a spurious interrupt will occur.",
        "implication": "Software may incorrectly handle an autonomous change to PCIe Gen4 Speed.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1157"
    },
    {
        "title": "Writes to Base Frequency Register May be Ignored",
        "problem": "If the base frequency register, (MSRC001_0064[CpuDfsId], MSRC001_0064[CpuFid]): \u2022 is programmed to a lower frequency than the default reset value, and \u2022 the default base frequency is not a multiple of 100 MHz then subsequent writes to the register that are greater than the next lower multiple of 100 MHz may be ignored.",
        "implication": "Software may report an incorrect value of base frequency.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1159"
    },
    {
        "title": "SdpParity and XiVictimQueue Mask Bits Incorrectly Mask Additional Errors",
        "problem": "If MCA::L3::MCA_CTL_MASK_L3[5] (SdpParity) is set then errors logged in MCA_STATUS_L3 that set MCA_STATUS_L3[ErrorCodeExt]=0x5 are correctly masked, and some system read data errors logged in MCA_STATUS_LS or MCA_STATUS_IF are masked incorrectly. If MCA::L3::MCA_CTL_MASK_L3[6] (XiVictimQueue) is set then errors logged in MCA_STATUS_L3 that set MCA_STATUS_L3[ErrorCodeExt]=0x6 are correctly masked, and some system read data errors logged in MCA_STATUS_LS are masked incorrectly.",
        "implication": "Some system read data errors logged in MCA_STATUS_LS or MCA_STATUS_IF may fail to be detected.",
        "workaround": "Do not program MCA::L3::MCA_CTL_MASK_L3[5] or MCA::L3::MCA_CTL_MASK_L3[6] to 1b.",
        "status": "No fix planned",
        "errnum": "1160"
    },
    {
        "title": "Some MCA_MISC0 Bits May Fail to Persist Through Warm Reset",
        "problem": "The following warm-reset persistent bits may incorrectly be cleared during a warm reset: \u2022 MCA_MISC0_DE[43:32], ErrCnt \u2022 MCA_MISC0_DE[48], Ovrflw \u2022 MCA_MISC0_DE[50:49], ThresholdIntType \u2022 MCA_MISC0_EX[43:32], ErrCnt \u2022 MCA_MISC0_EX[48], Ovrflw \u2022 MCA_MISC0_EX[50:49], ThresholdIntType \u2022 MCA_MISC0_IF[43:32], ErrCnt \u2022 MCA_MISC0_IF[48], Ovrflw \u2022 MCA_MISC0_IF[50:49], ThresholdIntType",
        "implication": "A corrected error count in some MCA banks will be lost over a warm reset.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1163"
    },
    {
        "title": "The PCIe\u00ae Link May Accumulate Correctable Errors in Some Gen3 Mode Configurations",
        "problem": "The PCIe\u00ae link may accumulate correctable receiver errors due to spurious entries into recovery or accumulate correctable errors due to NAKs (Negative Acknowledgements) in the following configurations: \u2022 Gen3 mode, Link width x1 \u2022 Gen3 mode, Link width x4 A link that degrades to one of the affected modes from a different mode will accumulate correctable errors as if it was originally configured to operate in the affected mode.",
        "implication": "Unexpected NAKs may occur, and the processor root complex may report correctable errors.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1165"
    },
    {
        "title": "The PCIe\u00ae Link May Accumulate Correctable Errors in Gen4 Link Width x2 Mode",
        "problem": "The PCIe\u00ae link may accumulate correctable receiver errors due to spurious entries into recovery or accumulate correctable errors due to NAKs (Negative Acknowledgements) in Gen4 Link width x2 mode. A link that degrades to the affected mode from a different mode will accumulate correctable errors as if it was originally configured to operate in the affected mode.",
        "implication": "Unexpected NAKs may occur, and the processor root complex may report correctable errors.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1166"
    },
    {
        "title": "PCIe\u00ae Error Masking May Fail to Mask Errors",
        "problem": "If MCA_CTL_MASK_NBIO[PCIE_sideband] is programmed to 0b, then PCIe\u00ae error masking, including Uncorrectable Error Mask and Correctable Error Mask, will not mask errors.",
        "implication": "Masked errors will incorrectly be reported to the system.",
        "workaround": "Program MCA_CTL_MASK_NBIO[PCIE_sideband] to 1b. System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1169"
    },
    {
        "title": "Requester ID May Be Set Incorrectly on Outbound PCIe\u00ae VDMs (Vendor Defined Messages)",
        "problem": "The Requester ID may be set incorrectly on Outbound PCIe\u00ae VDMs (Vendor Defined Messages) if the Type field indicates: \u2022 Broadcast from the Root Complex, \u2022 Routed to the Root Complex, or \u2022 Routed by ID. VDMs will be transmitted correctly within PCIe devices attached to the following groups of processor pins, but not between the groups. \u2022 Group 0: P0_*, G0_*, WAFL_* \u2022 Group 1: P1_*, G1_* \u2022 Group 2: P2_*, G2_* \u2022 Group 3: P3_*, G3_* MCTP (Management Component Transport Protocol) is the only defined and validated usage of PCIe VDMs on AMD platforms.",
        "implication": "System may be unable to route responses of VDM protocols. The receiving device may be unable to determine the source of the request.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1171"
    },
    {
        "title": "The Processor May Hang If it Receives INIT# While Already In the INIT# State",
        "problem": "The processor may hang if it receives INIT# while already in the INIT# state.",
        "implication": "System may hang or reset.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1183"
    },
    {
        "title": "PCIe\u00ae Receive Buffer Location May Be Incorrectly Overwritten",
        "problem": "Under a highly specific and detailed set of internal timing conditions, a PCIe\u00ae receive buffer SRAM location in the host controller may be incorrectly overwritten.",
        "implication": "None with BIOS incorporating AGESA RomePI-SP3_1.0.0.3 or later. Running software prior to AGESA RomePI-SP3_1.0.0.3 may result in unpredictable system behavior and possible logging of uncorrectable parity error(s) in MCA_STATUS_NBIO due to incorrect data in PCIe buffer.",
        "workaround": "BIOS incorporating AGESA RomePI-SP3_1.0.0.3 or later contains a workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1185"
    },
    {
        "title": "xHCI Host May Hang If Full Speed or High Speed USB Hub is Connected",
        "problem": "xHCI Host controller may hang if: \u2022 A high speed or full speed flash device is connected to the host, and \u2022 A high speed or full speed hub is connected to the host, and \u2022 An active device is connected to the hub.",
        "implication": "xHCI Host controller may hang.",
        "workaround": "System software may contain the workaround for this erratum. Program USB0x00C60C[12:9] to 0001b. Program USB1x00C60C[12:9] to 0001b. Program USB0x00C608[6:5] to 00b. Program USB1x00C608[6:5] to 00b.",
        "status": "No fix planned",
        "errnum": "1200"
    },
    {
        "title": "IBS (Instruction Based Sampling) Micro-Op Retire Counters May Be Inaccurate",
        "problem": "Under a highly specific and detailed set of internal timing conditions the processor may experience sampling inaccuracies in the following IBS (Instruction Based Sampling) counters: \u2022 MSRC001_1035[IbsTagToRetCtr] (micro-op tag to retire count) \u2022 MSRC001_1035[IbsCompToRetCtr] (micro-op completion to retire count)",
        "implication": "Software reading the IBS OP Data register may experience inaccuracies.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1212"
    },
    {
        "title": "IBS (Instruction Based Sampling) Counter Valid Value May be Incorrect After Exit From Core C6 (CC6) State",
        "problem": "If a core's IBS feature is enabled and configured to generate an interrupt, including NMI (Non-Maskable Interrupt), and the IBS counter overflows during the entry into the Core C6 (CC6) state, the interrupt may be issued, but an invalid value of the valid bit may be restored when the core exits CC6.",
        "implication": "The operating system may receive interrupts due to an IBS counter event, including NMI, and not observe an valid IBS register. Console messages indicating \"NMI received for unknown reason\" have been observed on Linux systems.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1215"
    },
    {
        "title": "IOMMU May Not Re-Walk Page Tables on a Present/ Permission Fault",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the IOMMU may not re-walk page tables on a present/permission fault.",
        "implication": "An IO device may see an unexpected completer abort.",
        "workaround": "System software may contain the workaround for this erratum. Program IOMMUL2B0x00000150[16] to 1b,and Program IOMMUL2B1x00000150[16] to 1b, and Program IOMMUL2B2x00000150[16] to 1b, and Program IOMMUL2B3x00000150[16] to 1b.",
        "status": "No fix planned",
        "errnum": "1216"
    },
    {
        "title": "EXITINFO1[2] May Be Incorrectly Set When GMET (Guest Mode Execute Trap extension) is Enabled",
        "problem": "EXITINFO1[2] (User/Supervisor bit) may incorrectly be one during a nested page fault if GMET (Guest Mode Execute Trap extension) is enabled.",
        "implication": "Software may not be able to determine whether a fault was a GMET fault or an NX fault based on EXITINFO1.",
        "workaround": "Software must read the relevant VMCB to determine whether a fault was a GMET fault or an NX fault.",
        "status": "No fix planned",
        "errnum": "1218"
    },
    {
        "title": "MCA_STATUS_CS[ErrorCode] May Be Incorrect After Some Machine Check Errors",
        "problem": "For some machine check errors, the MCA_STATUS_CS[ErrorCode] memory transaction type (RRRR) field incorrectly contains the value 0101b (Instruction Fetch) for all transaction types. This erratum affects errors logged with the following MCA_STATUS_CS[ErrorCodeExt]: \u2022 FTI_ILL_REQ \u2022 FTI_ADDR_VIOL \u2022 FTI_SEC_VIOL \u2022 FTI_ILL_RSP \u2022 FTI_RSP_NO_MTCH \u2022 SPF_PRT_ERR \u2022 SDP_RSP_NO_MTCH \u2022 SDP_UNEXP_RETRY \u2022 CNTR_OVFL \u2022 CNTR_UNFL",
        "implication": "None expected. Software is expected to primarily rely on MCA_STATUS_CS[ErrorCodeExt] to identify errors.",
        "workaround": "None. Software should use MCA_STATUS_CS[ErrorCodeExt] to identify errors and ignore MCA_STATUS_CS[ErrorCode] RRRR value for the error types listed above.",
        "status": "No fix planned",
        "errnum": "1225"
    },
    {
        "title": "Guest With AVIC (Advanced Virtual Interrupt Controller) Enabled May Fail to Process IPI (Inter-Processor Interrupt) Until Guest Is Re-Scheduled",
        "problem": "Under a highly specific and detailed set of internal timing conditions, if a guest with AVIC enabled is about to be de-scheduled by the hypervisor, it may fail to process an IPI until after the guest is re-scheduled.",
        "implication": "A guest may not process an IPI until the guest is re-scheduled.",
        "workaround": "None. Do not enable AVIC.",
        "status": "No fix planned",
        "errnum": "1235"
    },
    {
        "title": "IOMMU May Mishandle Fault on Skipped Page Directory Entry Levels",
        "problem": "When Guest Page Tables and Nested Page Tables are enabled, if a nested page table walk skips a PDE (Page Directory Entry) level when the virtual address bits are non-zero, the IOMMU may fail to abort the request, and fail to generate an IO page fault.",
        "implication": "None expected. Properly coded software will program the virtual address bits associated with a skipped page level to all zero.",
        "workaround": "Program the virtual address bits associated with a skipped page level to all zero.",
        "status": "No fix planned",
        "errnum": "1277"
    },
    {
        "title": "Spurious #GP May Occur When Hypervisor Running on Another Hypervisor",
        "problem": "The processor may incorrectly generate a #GP fault if a hypervisor running on a hypervisor attempts to access the following secure memory areas: \u2022 The reserved memory address region starting at FFFD_0000_0000h and extending up to FFFF_FFFF_FFFFh. \u2022 ASEG and TSEG memory regions for SMM (System Management Mode) \u2022 MMIO APIC Space",
        "implication": "Software running a hypervisor on a hypervisor may encounter an unexpected #GP fault.",
        "workaround": "If CPUID bit fn8000_000A EDX[28] = 0b, then: \u2022 Hypervisor software can trap #GP faults that potentially have this issue and ignore #GP faults that were erroneously generated. If CPUID bit fn8000_000A EDX[28] = 1b, then the issue has been fixed and no workaround is necessary.",
        "status": "No fix planned",
        "errnum": "1286"
    },
    {
        "title": "A VDPPS Instruction May Fail to Record a Masked Exception in the MXCSR Register",
        "problem": "A 256-bit VDPPS instruction will fail to record a masked exception in the MXCSR register when: \u2022 An unmasked exception is detected on one 128-bit section in the addition phase of the instruction, and \u2022 A masked exception is detected on the other 128-bit section in the addition phase of the instruction.",
        "implication": "None expected.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1288"
    },
    {
        "title": "GMI (Global Memory Interface) Link May Hang Due to Failure To Retrain After Encountering CRC Errors",
        "problem": "GMI Link may hang due to failure to retrain after encountering correctable CRC errors. As a result, the following system errors may be observed: \u2022 EX Watchdog Timeout (MCA::EX::MCA_STATUS_EX[ErrorCodeExt] = 0h) on one or more cores \u2022 PCIe Completion Timeout (PCIe Uncorrectable Error Status register bit 14 = 1b) \u2022 DF HW_ASSERT error (MCA::PIE::MCA_STATUS_PIE[ErrorCodeExt] = 0h) Any of the above errors may be preceded by one or more occurrences of the following error: \u2022 GMI correctable CRC errors (MCA::PIE::MCA_STATUS_PIE[ErrorCodeExt] = 2h, MCA::PIE::MCA_SYND_PIE[17] = 1b)",
        "implication": "System may hang or reset.",
        "workaround": "System software may contain a workaround for this issue.",
        "status": "No fix planned",
        "errnum": "1290"
    },
    {
        "title": "Certain Performance Counters For Retire Based Events May Overcount",
        "problem": "The processor may experience sampling inaccuracies that cause the following performance counters to overcount retire-based events. \u2022 PMCx0C0 [Retired Instructions] \u2022 PMCx0C1 [Retired Uops] \u2022 PMCx0C2 [Retired Branch Instructions] \u2022 PMCx0C3 [Retired Branch Instructions Mispredicted] \u2022 PMCx0C4 [Retired Taken Branch Instructions] \u2022 PMCx0C5 [Retired Taken Branch Instructions Mispredicted] \u2022 PMCx0C8 [Retired Near Returns] \u2022 PMCx0C9 [Retired Near Returns Mispredicted] \u2022 PMCx0CA [Retired Indirect Branch Instructions Mispredicted] \u2022 PMCx0D1 [Retired Conditional Branch Instructions] \u2022 PMCx1C7 [Retired Mispredicted Branch Instructions due to Direction Mismatch] \u2022 PMCx1D0 [Retired Fused Branch Instructions]",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None Software may enable another counter by setting PMC0x22[4] with a value of 1b. After reading the initial counter, if the second counter (with PMC0x22[4] set to 1b) is read and the count is zero, then the overcounting did not occur.",
        "status": "No fix planned",
        "errnum": "1291"
    },
    {
        "title": "xHCI Controller May Drop Data of an Isochronous TD (Transfer Descriptor) During Isochronous Transfer",
        "problem": "When an Evaluate Context Command modifies the Max Exit Latency value when an Isochronous transfer is in progress, the xHCI controller may drop the data of an Isochronous TD of the endpoint associated with the Device Slot targeted by the Evaluate Context Command. This may result in the xHCI issuing an MSE (Missed Service Error).",
        "implication": "Isochronous Audio or Video transfers may experience momentary data loss within a 750 microsecond timeout window, after which isochronous transfer will resume.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1294"
    },
    {
        "title": "AHCI Controller Ignores COMINIT During HP6: HR_AwaitAlign State",
        "problem": "In HP6: HR_AwaitAlign state, while the AHCI controller is awaiting valid ALIGN patterns from connected SATA device, it will not respond to COMINT issued by the connected SATA device.",
        "implication": "If the attached SATA device sends COMINIT instead of valid ALIGN patterns in HP6:HR_AwaitAlign state, the AHCI controller will time out awaiting valid ALIGN patterns. Consequently the AHCI controller will re- initiate Out-of-band signaling sequence at the next highest supported speed. This may result in the attached SATA device running at the lower speed.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1305"
    },
    {
        "title": "Guests With AVIC (Advanced Virtual Interrupt Controller) Enabled May Not Be Able to Program Interrupt Controller",
        "problem": "When AVIC (Advanced Virtual Interrupt Controller) is enabled, the processor may fail to redirect accesses to the AVIC backing page if the system PA (Physical Address) for APIC_BAR (Advanced Programmable Interrupt Controller Base Address Register) in the nested page table is an MMIO (Memory Mapped IO) address.",
        "implication": "Guests with AVIC enabled may not be able to program the interrupt controller.",
        "workaround": "Ensure that the system PA for APIC_BAR in the nested page table is not an MMIO address.",
        "status": "No fix planned",
        "errnum": "1308"
    },
    {
        "title": "Two Processor System Configured With 3-link xGMI and Preferred IO Mode May Hang or Reset",
        "problem": "A two processor system configured with 3-link xGMI and preferred IO mode may hang or reset.",
        "implication": "System may hang or reset.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1315"
    },
    {
        "title": "Page Remapping Without Invalidation May Cause Missed Detection of Self-Modifying Code",
        "problem": "Under a highly specific and detailed set of internal timing conditions, if a page table entry that has the Accessed bit set has its Page Frame Number (Physical-Page Base Address) updated without first updating the translation to have a permission violation for instruction fetch and then invalidating the table entry (INVLPG or INVLPGB +DVMSYNC), the processor may: \u2022 Execute stale instructions in the presence of self-modifying code or cross-modifying code for an instruction using the old translation.",
        "implication": "Processor may execute stale instructions in the presence of self-modifying code or cross-modifying code.",
        "workaround": "When remapping a page that is used for code fetch, software should update the translation to have a permission violation and invalidate the page table entry prior to remapping.",
        "status": "No fix planned",
        "errnum": "1193"
    },
    {
        "title": "IBS (Instruction Based Sampling) Register State May be Incorrect After Restore From CC6",
        "problem": "If an IBS (Instruction Based Sampling) interrupt is asserted, but the processor begins entry into the CC6 state before the IBS interrupt is processed, then the IBS register state may be incorrect after the restore from CC6.",
        "implication": "Debugger or performance monitoring software that uses IBS functionality may encounter inaccurate data.",
        "workaround": "Software should ignore IBS samples if MSRC001_1031 == 0000_0000_0000_0000h.",
        "status": "No fix planned",
        "errnum": "1197"
    },
    {
        "title": "PCIe Incorrectly Logs TLP Prefix AER (Advanced Error Reporting) Register After Egress Blocking Error",
        "problem": "When a PCIe TLP prefix egress blocking error occurs in an ATS (Address Translation Service) invalidation message or PRG (Page Request Group) response message, a TPH (TLP Processing Hint) prefix will be incorrectly be logged in the TLP Prefix AER (Advanced Error Reporting) register instead of PASID (Process Address Space ID).",
        "implication": "Software reading the TLP Prefix AER register may encounter incorrect information.",
        "workaround": "Ignore Bit 24 of the TLP Prefix AER after a PCIe egress blocking error in an ATS invalidation message or PRG response message.",
        "status": "No fix planned",
        "errnum": "1211"
    },
    {
        "title": "A Hardware Task Switch That Encounters Shadow Stack Errors May Cause a System Hang",
        "problem": "A hardware task switch that encounters a shadow stack error condition may result in a #GP instead of a #TS. A hardware task switch that encounters a fault during shadow stack accesses may result in TR (Task Register) being incorrectly loaded.",
        "implication": "System may hang or reset.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1226"
    },
    {
        "title": "A CPL3 to CPL3 Hardware Task Switch May Result in an Unexpected #CP",
        "problem": "A CPL3 to CPL3 hardware task switch may result in the SSP (Shadow Stack Pointer) being corrupted.",
        "implication": "System may encounter an unexpected #CP.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1227"
    },
    {
        "title": "MCA_STATUS_LS[ExtErrorCode] May Contain Incorrect Code After a Store Queue Address Fatal Parity Error",
        "problem": "Under a highly specific and detailed set of internal timing conditions, an error that should be logged with MCA_STATUS_LS[ExtErrorCode]=11 (store queue address fatal parity error) may be incorrectly logged with MCA_STATUS_LS[ExtErrorCode]=23 (other store data fatal error).",
        "implication": "Diagnostic software may encounter incorrect information in MCA_STATUS_LS[ExtErrorCode] after a fatal error.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1237"
    },
    {
        "title": "MSRC001_1030[IbsIcMiss] May be Incorrect",
        "problem": "The processor may set MSRC001_1030[IbsIcMiss] as an instuction cache miss when the fetch was an instuction cache hit.",
        "implication": "MSRC001_1030[IbsIcMiss] may be incorrect.",
        "workaround": "None. Ignore MSRC001_1030[IbsIcMiss].",
        "status": "No fix planned",
        "errnum": "1238"
    },
    {
        "title": "EXITINFO1[2] May Be Incorrectly Set When Supervisor Shadow Stack Check is Enabled",
        "problem": "EXITINFO1[2] (User/Supervisor bit) may incorrectly be 1b during a nested page fault if Supervisor Shadow Stack Check (Virtual Machine Control Block offset 90h bit 4) is enabled.",
        "implication": "Software may not be able to determine whether a fault was a Supervisor Shadow Stack Check or not based on EXITINFO1[2].",
        "workaround": "Software may examine the following to determine the type of the fault: \u2022 EXITINFO1[37] and EXITINFO1[6] \u2022 CPL (Current Privilege Level) from VMCB (Virtual Machine Control Block) \u2022 Guest instruction bytes from VMCB (WRUSS instruction is a user access regardless of CPL) \u2022 Nested page table",
        "status": "No fix planned",
        "errnum": "1244"
    },
    {
        "title": "MCA_STATUS_LS[Overflow] May Be Spuriously Set on DC_DATA_VICTIM or DC_DATA_LOAD Error",
        "problem": "Under a highly specific and detailed set of internal timing conditions, MCA_STATUS_LS[Overflow] may be spuriously set when a DC_DATA_VICTIM or DC_DATA_LOAD error is logged.",
        "implication": "None",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1257"
    },
    {
        "title": "Processor May Log an Error with Incorrect Address in MCA_ADDR_LS",
        "problem": "Under a highly specific and detailed set of internal timing conditions, when logging an MCA error due to poison consumption (MCA_STATUS_LS[ExtErrorCode]=DC_DATA_LOAD and MCA_STATUS_LS[Poison]=1), the processor may log an incorrect address in MCA_ADDR_LS.",
        "implication": "System software may incorrectly identify which address contains poisoned data.",
        "workaround": "System software should use the deferred error information associated with poison creation to identify the address containing poisoned data.",
        "status": "No fix planned",
        "errnum": "1260"
    },
    {
        "title": "Retired MMX/FP Instruction Counter May Fail to Count MMX Stores",
        "problem": "If PMCx0CB[MmxInstr] is programmed to 1b, the processor may experience sampling inaccuracies that cause the PMCx0CB [Retired MMX/FP Instructions] performance counter to fail to count MMX stores.",
        "implication": "Performance monitoring software may undercount retired MMX/FP instructions.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1266"
    },
    {
        "title": "MSRC000_00E9[IRPerfCount] May Overcount",
        "problem": "The processor may experience sampling inaccuracies that cause MSRC000_00E9[IRPerfCount] to overcount certain instruction fusion cases.",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "If absolute accuracy is required, then use PMCx0C0 instead.",
        "status": "No fix planned",
        "errnum": "1267"
    },
    {
        "title": "Software Using a Non-Canonicalized SSP (Shadow Stack Pointer) May Encounter a #GP Fault on a Different Instruction Than Expected",
        "problem": "The processor may not canonicalize the SSP before saving for far transfers to an inner privilege level (specifically CPL3 to CPL2/1/0) when: \u2022 EFER.LMA=1, or \u2022 The far transfer is a SYSCALL The processor may not fault during a far transfer to an outer privilege level (specifically CPL2/1/0 to CPL3) if the target SSP is non-canonical.",
        "implication": "None expected. Software using a non-canonicalized SSP (Shadow Stack Pointer) may encounter a #GP fault on a different instruction than expected.",
        "workaround": "The operating system or hypervisor may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1275"
    },
    {
        "title": "IOMMU May Fail to Abort Pre-Translated Request With Bits Erroneously Set in Reserved Field",
        "problem": "The IOMMU fails to abort pre-translated request with bits erroneously set in the reserved host PDE[60:52] (Page Directory Entry) or reserved host PTE[58:52] (Page Table Entry) fields when sATS (Secure Address Translation Service) is enabled for the device making the request.",
        "implication": "None expected. Properly coded software will avoid programming reserved bits in the host PDE or host PTE structures.",
        "workaround": "Do not program bits in: \u2022 the reserved host PDE[60:52] (Page Directory Entry) field, or \u2022 the reserved host PTE[58:52] (Page Table Entry) field",
        "status": "No fix planned",
        "errnum": "1276"
    },
    {
        "title": "Some Features Are Not Available When SNP (Secure Nested Paging) Support Is Enabled",
        "problem": "The following features are not available when SNP support is enabled: \u2022 IOMMU Guest Paging (GTSup) Two-level Guest Address Translation \u2022 IOMMU SATS (SATSSup) Secure Address Translation Service \u2022 IOMMU AVIC (GAMSup) Guest Virtual APIC Interrupt Controller \u2022 \u2022",
        "implication": "The features listed above are not available when SNP support is enabled.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1278"
    },
    {
        "title": "PMCx0AA[Source of Op Dispatched From Decoder] Events Will Not Be Counted",
        "problem": "If a core performance monitor counter is programmed to select PMCx0AA[Source of Op Dispatched From Decoder], the counter will not count the selected events.",
        "implication": "Performance monitoring software may undercount \"Source of Op Dispatched From Decoder\" events.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1287"
    },
    {
        "title": "Certain Performance Counters For Retire Based Events May Overcount",
        "problem": "The processor may experience sampling inaccuracies that cause the following performance counters to overcount retire-based events. \u2022 PMCx0C0 [Retired Instructions] \u2022 PMCx0C1 [Retired Uops] \u2022 PMCx0C2 [Retired Branch Instructions] \u2022 PMCx0C3 [Retired Branch Instructions Mispredicted] \u2022 PMCx0C4 [Retired Taken Branch Instructions] \u2022 PMCx0C5 [Retired Taken Branch Instructions Mispredicted] \u2022 PMCx0C8 [Retired Near Returns] \u2022 PMCx0C9 [Retired Near Returns Mispredicted] \u2022 PMCx0CA [Retired Indirect Branch Instructions Mispredicted] \u2022 PMCx0CC [Retired Indirect Branch Instructions] \u2022 PMCx0D1 [Retired Conditional Branch Instructions] \u2022 PMCx1C7 [Retired Mispredicted Branch Instructions due to Direction Mismatch] \u2022 PMCx1D0 [Retired Fused Branch Instructions]",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "To count the non-FP affected PMC events correctly: \u2022 Use Core::X86::Msr::PERF_CTL2 to count the events, and \u2022 Program Core::X86::Msr::PERF_CTL2[43] to 1b, and \u2022 Program Core::X86::Msr::PERF_CTL2[20] to 0b. An alternate workaround that enables the capture of multiple affected PMC events simultaneously is to set the BIOS Setup Option \"IBS hardware workaround.\" This option is not recommended for production systems because system performance may be negatively impacted.",
        "status": "No fix planned",
        "errnum": "1292"
    },
    {
        "title": "Data in IBS_OP_DATA2 and IBS_OP_DATA3 May be Inaccurate",
        "problem": "If either of the following conditions are met: \u2022 Core::X86::Msr::IBS_OP_DATA3[DcMissNoMabAlloc] = 1b, or \u2022 Core::X86::Msr::IBS_OP_DATA3[IbsSwPf] = 1b Then the data in the following registers may be inaccurate: \u2022 Core::X86::Msr::IBS_OP_DATA2 \u2022 Core::X86::Msr::IBS_OP_DATA3[IbsOpDcMissOpenMemReqs] \u2022 Core::X86::Msr::IBS_OP_DATA3[IbsL2Miss]",
        "implication": "Performance monitoring software may encounter incorrect data in IBS_OP_DATA2 or IBS_OP_DATA3.",
        "workaround": "None. Performance monitoring software should ignore the affected registers in samples with IBS_OP_DATA3[DcMissNoMabAlloc] = 1b or IBS_OP_DATA3[IbsSwPf] = 1b.",
        "status": "No fix planned",
        "errnum": "1293"
    },
    {
        "title": "Thread in Pending State From MONITOR or MONITORX May Become Unresponsive When Another Thread Invalidates the Monitored Address Using INVLPGB",
        "problem": "The processor may fail to exit the monitor event pending state entered by a MONITOR or MONITORX instruction under the following conditions: \u2022 An MWAIT or MWAITX instruction is executed while the processor is in the event pending state. \u2022 A different processor or processor thread executes an INVLPGB instruction that invalidates the translation for the address range established by the MONITOR or MONITORX instruction, and \u2022 The processor that executed the INVLPGB then executes a TLBSYNC instruction, before the first processor exits the monitor event pending state. Under the conditions specified above, the first processor may remain in the event pending state until an unmasked interrupt is seen or a write happens to the physical address that belonged to the linear address of the MONITOR/MONITORX instruction when executed. An MWAITX instruction with a timer interval programmed would wake up at the expiration of the timer interval.",
        "implication": "A thread may become unresponsive until the next interrupt.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1295"
    },
    {
        "title": "Processor May Fail to Generate #GP on Incorrectly Programmed Host Save Address When Executing VMRUN",
        "problem": "The processor may fail to generate a #GP fault when: \u2022 A VMRUN instruction is executed, and \u2022 Core::X86::Msr::VM_HSAVE_PA = 8_0000_0000_0000h, and \u2022 Core::X86::Msr::SYS_CFG[SecureNestedPagingEn] = 1b",
        "implication": "None",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1296"
    },
    {
        "title": "Processor May Fail To Take a #DB Exception on a Misaligned Store",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor may fail to take a #DB exception when a store that is misaligned on a 4K address boundary matches a data breakpoint on the portion of the store that is after the 4K boundary crossing.",
        "implication": "Missed data breakpoint.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1297"
    },
    {
        "title": "Processor May Take Spurious #PF or Record Incorrect Error After DC_TAG_LOAD or DC_TAG_STORE Error",
        "problem": "Under a highly detailed and specific set of internal timing conditions, after the processor detects a DC_TAG_LOAD or DC_TAG_STORE error, one of the following may occur: \u2022 The processor may take a spurious #PF (Page Fault Exception) for an address that is not faulting prior to handling the MCA error. \u2022 The processor may record the wrong information in MCA_ADDR_LS and MCA_STATUS_LS[ErrorCodeExt].",
        "implication": "Incorrect error reporting and/or spurious #PF.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1298"
    },
    {
        "title": "Task Switches May Cause Unexpected #CP (Control Protection) Exception",
        "problem": "Under a highly detailed sequence of internal timing conditions, the processor may fail to push CS (Code Segment), LIP (Linear Instruction Pointer), and SSP (Shadow Stack Pointer) onto the shadow stack when executing a CALL FAR instruction if the following conditions are also met: \u2022 Long mode is disabled (EFER.LMA = 0). \u2022 The CALL FAR instruction is executed while processor is running at CPL0. \u2022 The segment-descriptor type referenced by the CALL FAR instruction is an available TSS (task state segment). \u2022 User shadow stack is disabled and supervisor shadow stack is enabled (U_CET[SH_STK_EN] = 0 and S_CET[SH_STK_EN] = 1 ).",
        "implication": "None expected. If task switches are used, unexpected shadow stack mismatch leading to a #CP (control protection) exception may occur.",
        "workaround": "None. Operating systems using the shadow stack features should avoid using task switches.",
        "status": "No fix planned",
        "errnum": "1307"
    },
    {
        "title": "#VC (VMM Communication) Exception May Return Wrong Value in CR2",
        "problem": "Under a highly specific and detailed set of internal timing conditions, a #VC (VMM Communication) exception may return the wrong value in CR2 under the following conditions: \u2022 The exception is taken on an RMPADJUST instruction in a Secure Nested Paging (SNP)-active guest. \u2022 The error code is PAGE_NOT_VALIDATED. \u2022 The RMP (Reverse Map Table) entry accessed by the RMPADJUST instruction is concurrently accessed by a PVALIDATE instruction from the same guest running on a different processor thread.",
        "implication": "The guest may incorrectly indicate an error and/or terminate.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1309"
    },
    {
        "title": "Processor May Generate Spurious #GP(0) Exception on WRMSR Instruction",
        "problem": "The processor will generate a spurious #GP(0) exception on a WRMSR instruction if the following conditions are all met: \u2022 The target of the WRMSR is the SYSCFG register. \u2022 The write changes the value of Secure Nested Paging enable (SYSCFG.SNPEn) from 0 to 1. \u2022 One of the threads that share the physical core has a non-zero value in the VM_HSAVE_PA MSR.",
        "implication": "Unexpected #GP(0) exception during processor boot.",
        "workaround": "When enabling Secure Nested Paging, program VM_HSAVE_PA to 0h on both threads that share a physical core before setting SYSCFG.SNPEn.",
        "status": "No fix planned",
        "errnum": "1321"
    },
    {
        "title": "PMCx0A9 May Undercount Op Queue Empty Events",
        "problem": "If a core performance monitor counter is programmed to select PMCx0A9[Op Queue Empty], the processor may experience sampling inaccuracies that cause some \"Op Queue Empty\" events not to be counted.",
        "implication": "Performance monitoring software may undercount \"Op Queue Empty\" events.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1322"
    },
    {
        "title": "Hypervisor With Encrypted SVM (Secure Virtual Machine) Related Pages May Experience Unpredictable Behavior If Guest Enables LBR (Last Branch Record)",
        "problem": "Under the following conditions, the processor may behave incorrectly: \u2022 SME (Secure Memory Encryption) is enabled, and \u2022 Hypervisor owned pages used for SVM (Secure Virtual Machine) functionality are encrypted, and \u2022 A VMRUN instruction has been executed to enter an SEV-ES (Secure Encrypted Virtualization - Encrypted State) or SEV-SNP (Secure Encrypted Virtualization - Secure Nested Paging) guest, and \u2022 DbgCtl[LBR] (Last Branch Record) was 0 when the hypervisor started the guest with a VMRUN instruction, and \u2022 The guest value of DbgCtl[LBR] was 1 when loaded from the VMSA (Virtual Machine Save Area). The incorrect behavior may be one or more of the following: \u2022 The processor may unexpectedly cause a VMEXIT or may fail to cause a VMEXIT. \u2022 VMCB.GUEST_INSTR_BYTES may have an incorrect value on VMEXIT. \u2022 If the nested page tables are in encrypted memory, nested page table walks may result in incorrect translations. \u2022 If AVIC (Advanced Virtual Interrupt Controller) is enabled and the AVIC backing page is encrypted, AVIC functionality may be incorrect.",
        "implication": "Unpredictable system behavior",
        "workaround": "None. Do not encrypt hypervisor owned pages used for SVM functionality.",
        "status": "No fix planned",
        "errnum": "1327"
    },
    {
        "title": "SEV-SNP (Secure Encrypted Virtualization - Secure Nested Paging) Guests With Last Branch Record Enabled May Experience Incorrect Alternate Injection Behavior",
        "problem": "Under the following conditions, a SEV-SNP (Secure Encrypted Virtualization Secure Nested Paging) guest with Alternate Injection enabled may incorrectly behave as if Alternate Injection is disabled: \u2022 DbgCtl[LBR] (Last Branch Record) was 0 when the hypervisor started the guest with a VMRUN instruction, and \u2022 The guest value of DbgCtl[LBR] was 1 when loaded from the VMSA (Virtual Machine Save Area).",
        "implication": "Incorrect interrupt behavior for guests.",
        "workaround": "None. Do not program DbgCtl[LBR] to 1b in the guest.",
        "status": "No fix planned",
        "errnum": "1328"
    },
    {
        "title": "Hypervisor With Encrypted SVM (Secure Virtual Machine) Related Pages May Experience Unpredictable Behavior If Guest Enables LBR (Last Branch Record)",
        "problem": "Under the following conditions, the processor may behave incorrectly: \u2022 SME (Secure Memory Encryption) is enabled, and \u2022 Hypervisor owned pages used for SVM (Secure Virtual Machine) functionality are encrypted, and \u2022 A VMRUN instruction has been executed to enter an SEV-ES (Secure Encrypted Virtualization - Encrypted State) or SEV-SNP (Secure Encrypted Virtualization - Secure Nested Paging) guest, and \u2022 DbgCtl[LBR] (Last Branch Record) was 0 when the hypervisor started the guest with a VMRUN instruction, and \u2022 The guest value of DbgCtl[LBR] was 1 when loaded from the VMSA (Virtual Machine Save Area). The incorrect behavior may be one or more of the following: \u2022 The processor may unexpectedly cause a VMEXIT or may fail to cause a VMEXIT. \u2022 VMCB.GUEST_INSTR_BYTES may have an incorrect value on VMEXIT. \u2022 If the nested page tables are in encrypted memory, nested page table walks may result in incorrect translations. \u2022 If AVIC (Advanced Virtual Interrupt Controller) is enabled and the AVIC backing page is encrypted, AVIC functionality may be incorrect.",
        "implication": "Unpredictable system behavior",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1329"
    },
    {
        "title": "SEV-SNP (Secure Encrypted Virtualization - Secure Nested Paging) Guests With Last Branch Record Enabled May Experience Incorrect Alternate Injection Behavior",
        "problem": "Under the following conditions, a SEV-SNP (Secure Encrypted Virtualization Secure Nested Paging) guest with Alternate Injection enabled may incorrectly behave as if Alternate Injection is disabled: \u2022 DbgCtl[LBR] (Last Branch Record) was 0 when the hypervisor started the guest with a VMRUN instruction, and \u2022 The guest value of DbgCtl[LBR] was 1 when loaded from the VMSA (Virtual Machine Save Area).",
        "implication": "Incorrect interrupt behavior for guests.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1330"
    },
    {
        "title": "Processor May Fail to Take #VMEXIT(NPF) When SNP- Active (Secure Nested Paging) Guest Writes an Improperly Configured Page",
        "problem": "The processor may fail to take a #VMEXIT(NPF) under the following conditions: \u2022 An SNP-Active guest executes an instruction that performs a memory write or a masked write (VMASKMOV), and \u2022 The page that is accessed by the memory operation is illegally configured to have VMPL (Virtual Machine Privilege Level) write permissions but not VMPL read permissions.",
        "implication": "None expected. Properly coded software will always enable VMPL read permissions if VMPL write permissions are enabled.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1344"
    },
    {
        "title": "RMPUPDATE or PSMASH Instructions May Speculatively Access the Page After End of RMP (Reverse Map Table)",
        "problem": "When executing the RMPUPDATE or PSMASH instructions, the processor may speculatively read from addresses that are in the next 4K page after the end of the RMP even if the memory type of that page does not allow speculative accesses.",
        "implication": "System may hang or reset.",
        "workaround": "Always map a 4K page that allows speculative accesses after the end of the RMP.",
        "status": "No fix planned",
        "errnum": "1345"
    },
    {
        "title": "RMPUDATE May Incorrectly Return FAIL_OVERLAP",
        "problem": "RMPUDATE may fail with FAIL_OVERLAP return code if multiple processors simultaneously execute RMPUPDATE to change the assignment of different pages within a 2MB region.",
        "implication": "A hypervisor may receive an unexpected FAIL_OVERLAP return code.",
        "workaround": "Retry the operation.",
        "status": "No fix planned",
        "errnum": "1346"
    },
    {
        "title": "Instruction Cache L1TLB Page Size Reports Incorrectly",
        "problem": "Core::X86::Msr::IBS_FETCH_CTL[IbsL1TlbPgSz] instruction cache L1TLB page size reports incorrectly. The processor instead reports as follows: \u2022 IbsL1TlbPgSz = 00b: 4KB \u2022 IbsL1TlbPgSz = 01b: 16KB \u2022 IbsL1TlbPgSz = 10b: 2MB \u2022 IbsL1TlbPgSz = 11b: 1GB",
        "implication": "Performance monitoring software may produce unexpected results.",
        "workaround": "Software reading IbsL1TlbPgSz should refer to the table in the description.",
        "status": "No fix planned",
        "errnum": "1347"
    },
    {
        "title": "PMCx1CF May Undercount Operations Tagged by IBS (Instruction Based Sampling)",
        "problem": "If PMCx1CF[IbsTaggedOps] is programmed to 1b, the PMCx1CF [Tagged IBS Ops] performance counter may undercount when sampling thread 1.",
        "implication": "Inaccuracies in performance monitoring software may be experienced.",
        "workaround": "None",
        "status": "No fix planned",
        "errnum": "1348"
    },
    {
        "title": "Write to Shared Core::X86::Msr::CpuWdtCfg From One Thread May Incorrectly Revert to Older Value",
        "problem": "A write to the shared Core::X86::Msr::CpuWdtCfg from one thread may incorrectly be reverted to an older value under the following conditions: \u2022 The CpuWdtCfg write happens while the other thread is in HLT, and \u2022 The CpuWdtCfg write happens between a CC6 state exit and a CC6 state entry, and \u2022 The other thread remained in HLT for the entire time, and \u2022 The next time the other thread wakes up from HLT, it wakes up after the writing thread woke up subsequent to a CC6 state exit.",
        "implication": "Incorrect watchdog timer functionality",
        "workaround": "Program the CpuWdtCfg on one thread while the other thread is not in HLT.",
        "status": "No fix planned",
        "errnum": "1353"
    },
    {
        "title": "Processor May Hang When Switching Between Instruction Cache and Op Cache",
        "problem": "Under a highly specific and detailed set of internal timing conditions, running a program with a code footprint that exceeds 32 KB may cause the processor to hang while switching between code regions that consistently miss the instruction cache and code regions that are contained within the Op Cache.",
        "implication": "System may hang or reset.",
        "workaround": "System software may contain the workaround for this erratum.",
        "status": "No fix planned",
        "errnum": "1361"
    }
]