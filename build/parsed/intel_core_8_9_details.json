{
    "001": {
        "title": "Reported Memory Type May Not Be Used to Access the VMCS and \nReferenced Data Structures",
        "problem": "Bits 53:50 of the IA32_VMX_BASIC MSR report the memory type that the processor \nuses to access the VMCS and data structures referenced by pointers in the VMCS. \nDue to this erratum, a VMX access to the VMCS or referenced data structures will \ninstead use the memory type that the memory-type range registers (MTRRs) specify \nfor the physical address of the access.",
        "implication": "Bits 53:50 of the IA32_VMX_BASIC MSR report that the write-back (WB) memory \ntype will be used, but the processor may use a different memory type.",
        "workaround": "Software should ensure that the VMCS and referenced data structures are located at \nphysical addresses that are mapped to WB memory type by the MTRRs.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "002": {
        "title": "Instruction Fetch May Cause Machine Check if Page Size and Memory Type \nWas Changed Without Invalidation",
        "problem": "This erratum may cause a machine-check error \n(IA32_MCi_STATUS.MCACOD=0150H) on the fetch of an instruction that crosses a 4-\nKByte address boundary. It applies only if; \nThe 4-KByte linear region on which the instruction begins is originally translated \n\u2022 \nusing a 4-KByte page with the WB memory type. \nThe paging structures are later modified so that linear region is translated using \n\u2022 \na large page (2-MByte, 4-MByte, or 1-GByte) with the UC memory type. \nThe instruction fetch occurs after the paging-structure modification but before \n\u2022 \nsoftware invalidates any TLB entries for the linear region.",
        "implication": "Due to this erratum, an unexpected machine check with error code 0150H may occur, \npossibly resulting in a shutdown. Intel has not observed this erratum with any \ncommercially available software.",
        "workaround": "Software should not write to a paging-structure entry in a way that would change, for \nany linear address, both the page size and the memory type. It can instead use the \nfollowing algorithm: first clear the P flag in the relevant paging-structure entry \n(example, PDE); then invalidate any translations for the affected linear addresses; \nand then modify the relevant paging-structure entry to set the P flag and establish \nthe new page size and memory type.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "003": {
        "title": "Execution of VAESIMC or VAESKEYGENASSIST With An Illegal Value for \nVEX.vvvv May Produce a #NM Exception",
        "problem": "The VAESIMC and VAESKEYGENASSIST instructions should produce a #UD (Invalid-\nOpcode) exception if the value of the vvvv field in the VEX prefix is not 1111b. Due to \nthis erratum, if CR0.TS is \u201c1\u201d, the processor may instead produce a #NM (Device-\nNot-Available) exception.",
        "implication": "Due to this erratum, some undefined instruction encodings may produce a #NM \ninstead of a #UD exception.",
        "workaround": "Software should always set the vvvv field of the VEX prefix to 1111b for instances of \nthe VAESIMC and VAESKEYGENASSIST instructions.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "004": {
        "title": "The Corrected Error Count Overflow Bit in IA32_ MC0_STATUS is Not \nUpdated When The UC Bit is Set",
        "problem": "After a uncorrected (UC) error is logged in the IA32_MC0_STATUS MSR (401H), \ncorrected errors will continue to be counted in the lower 14 bits (bits 51:38) of the \nCorrected Error Count. Due to this erratum, the sticky count overflow bit (bit 52) of \nthe Corrected Error Count will not get updated, when the UC bit (bit 61) is set to 1.",
        "implication": "The Corrected Error Count Overflow indication will be lost, if the overflow occurs after \nan uncorrectable error has been logged.",
        "workaround": "None identified",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "005": {
        "title": "VM Exit May Set IA32_EFER.NXE When IA32_MISC_ENABLE Bit 34 is Set to 1",
        "problem": "When \u201cXD Bit Disable\u201d in the IA32_MISC_ENABLE MSR (1A0H) bit 34 is set to 1, it \nshould not be possible to enable the \u201cexecute disable\u201d feature by setting \nIA32_EFER.NXE. Due to this erratum, a VM exit that occurs with the 1-setting of the \n\u201cload IA32_EFER\u201d VM-exit control may set IA32_EFER.NXE even, if \nIA32_MISC_ENABLE bit 34 is set to 1. This erratum can occur only, if \nIA32_MISC_ENABLE bit 34 was set by guest software in VMX non-root operation.",
        "implication": "Software in VMX root operation may execute with the \u201cexecute disable\u201d feature \nenabled despite the fact that the feature should be disabled by the \nIA32_MISC_ENABLE MSR. Intel has not observed this erratum with any commercially \navailable software.",
        "workaround": "A virtual-machine monitor should not allow guest software to write to the \nIA32_MISC_ENABLE MSR",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "006": {
        "title": "SMRAM State-Save Area Above the 4GB Boundary May Cause Unpredictable \nSystem Behavior",
        "problem": "If BIOS uses the RSM instruction to load the SMBASE register with a value that would \ncause any part of the SMRAM state-save area to have an address above 4-GBytes, \nsubsequent transitions into and out of system-management mode (SMM) might save \nand restore processor state from incorrect addresses.",
        "implication": "This erratum may cause unpredictable system behavior. Intel has not observed this \nerratum with any commercially available system.",
        "workaround": "Ensure that the SMRAM state-save area is located entirely below the 4 GB address \nboundary.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "007": {
        "title": "Pending x87 FPU Exceptions (#MF) May be Signaled Earlier Than Expected",
        "problem": "x87 instructions that trigger #MF normally service interrupts before the #MF. Due to \nthis erratum, if an instruction that triggers #MF is executing, when an Enhanced \nIntel\u00ae SpeedStep\u00ae Technology transitions, an Intel\u00ae Turbo Boost Technology \ntransitions, or a Thermal Monitor events occurs, the #MF may be taken before \npending interrupts are serviced.",
        "implication": "Software may observe #MF being signaled before pending interrupts are serviced.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "008": {
        "title": "Incorrect FROM_IP Value For an RTM Abort in BTM or BTS May be Observed",
        "problem": "During Restricted Transactional Memory (RTM) operation, when branch tracing is \nenabled using Branch Trace Message (BTM) or Branch Trace Store (BTS), the \nincorrect EIP value (From_IP pointer) may be observed for an RTM abort.",
        "implication": "Due to this erratum, the From_IP pointer may be the same as that of the \nimmediately preceding taken branch.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "009": {
        "title": "DR6 Register May Contain an Incorrect Value When a MOV to SS or POP SS \nInstruction is Followed by an XBEGIN Instruction",
        "problem": "If XBEGIN is executed immediately after an execution of MOV to SS or POP SS, a \ntransactional abort occurs and the logical processor restarts execution from the \nfallback instruction address. If execution of the instruction at that address causes a \ndebug exception, bits [3:0] of the DR6 register may contain an incorrect value.",
        "implication": "When the instruction at the fallback instruction address causes a debug exception, \nDR6 may report a breakpoint that was not triggered by that instruction, or it may fail \nto report a breakpoint that was triggered by the instruction.",
        "workaround": "Avoid following a MOV SS or POP SS instruction immediately with an XBEGIN instruction.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "010": {
        "title": "Opcode Bytes F3 0F BC May Execute As TZCNT Even When TZCNT Not \nEnumerated by CPUID",
        "problem": "If CPUID.(EAX=07H, ECX=0):EBX.BMI1 (bit 3) is 1 then opcode bytes F3 0F BC \nshould be interpreted as TZCNT otherwise they will be interpreted as REP BSF. Due to \nthis erratum, opcode bytes F3 0F BC may execute as TZCNT even if \nCPUID.(EAX=07H, ECX=0):EBX.BMI1 (bit 3) is 0.",
        "implication": "Software that expects REP prefix before a BSF instruction to be ignored may not \noperate correctly, since there are cases in which BSF and TZCNT differ with regard to \nthe flags that are set and how the destination operand is established.",
        "workaround": "Software should use the opcode bytes F3 0F BC only if CPUID.(EAX=07H, \nECX=0):EBX.BMI1 (bit 3) is 1 and only if the functionality of TZCNT (and not BSF) is \ndesired.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "011": {
        "title": "#GP on Segment Selector Descriptor that Straddles Canonical Boundary May \nNot Provide Correct Exception Error Code",
        "problem": "During a General Protection Exception (#GP), the processor pushes an error code on \nto the exception handler\u2019s stack. If the segment selector descriptor straddles the \ncanonical boundary, the error code pushed onto the stack may be incorrect.",
        "implication": "An incorrect error code may be pushed onto the stack. Intel has not observed this \nerratum with any commercially available software.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "012": {
        "title": "The SMSW Instruction May Execute Within an Enclave",
        "problem": "The SMSW instruction is illegal within an Software Guard Extensions (SGX) enclave, \nand an attempt to execute it within an enclave should result in a #UD (invalid-opcode \nexception). Due to this erratum, the instruction executes normally within an enclave \nand does not cause a #UD.",
        "implication": "The SMSW instruction provides access to CR0 bits 15:0 and will provide that \ninformation inside an enclave. These bits include NE, ET, TS, EM, MP and PE.",
        "workaround": "None identified. If SMSW execution inside an enclave is unacceptable, system \nsoftware should not enable SGX.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "013": {
        "title": "WRMSR to IA32_BIOS_UPDT_TRIG Concurrent With an SMX SENTER/SEXIT \nMay Result in a System Hang",
        "problem": "Performing WRMSR to IA32_BIOS_UPDT_TRIG (MSR 79H) on a logical processor \nwhile another logical processor is executing an Safer Mode Extensions (SMX) \nSENTER/SEXIT operation (GETSEC[SENTER] or GETSEC[SEXIT] instruction) may \ncause the processor to hang.",
        "implication": "When this erratum occurs, the system will hang. Intel has not observed this erratum \nwith any commercially available system.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "014": {
        "title": "Intel\u00ae PT TIP.PGD May Not Have Target IP Payload",
        "problem": "When Intel\u00ae Processor Trace (Intel\u00ae PT) is enabled and a direct unconditional branch \nclears IA32_RTIT_STATUS.FilterEn (MSR 571H, bit 0), due to this erratum, the \nresulting Target IP Packet, Packet Generation Disable (TIP.PGD) may not have an IP \npayload with the target IP.",
        "implication": "It may not be possible to tell which instruction in the flow caused the TIP.PGD using \nonly the information in trace packets when this erratum occurs.",
        "workaround": "The Intel PT trace decoder can compare direct unconditional branch targets in the \nsource with the FilterEn address range(s) to determine which branch cleared FilterEn.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "015": {
        "title": "Operand-Size Override Prefix Causes 64-bit Operand Form of MOVBE \nInstruction to Cause a #UD",
        "problem": "Execution of a 64 bit operand MOVBE instruction with an operand-size override \ninstruction prefix (66H) may incorrectly cause an invalid-opcode exception (#UD).",
        "implication": "A MOVBE instruction with both REX.W=1 and a 66H prefix will unexpectedly cause a \n#UD (invalid-opcode exception). Intel has not observed this erratum with any \ncommercially available software.",
        "workaround": "Do not use a 66H instruction prefix with a 64-bit operand MOVBE instruction.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "016": {
        "title": "Execution of FXSAVE or FXRSTOR With the VEX Prefix May Produce a #NM \nException",
        "problem": "Attempt to use FXSAVE or FXRSTOR with a VEX prefix should produce a #UD \n(Invalid-Opcode) exception. If either the TS or EM flag bits in CR0 are set, a #NM \n(device-not-available) exception will be raised instead of #UD exception.",
        "implication": "Due to this erratum a #NM exception may be signaled instead of a #UD exception on \nan FXSAVE or an FXRSTOR with a VEX prefix.",
        "workaround": "Software should not use FXSAVE or FXRSTOR with the VEX prefix.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "017": {
        "title": "WRMSR May Not Clear The Sticky Count Overflow Bit in The \nIA32_MCi_STATUS MSRs\u2019 Corrected Error Count Field",
        "problem": "The sticky count overflow bit is the most significant bit (bit 52) of the Corrected Error \nCount Field (bits[52:38]) in IA32_MCi_STATUS MSRs.  Once set, the sticky count \noverflow bit may not be cleared by a WRMSR instruction. When this occurs, that bit \ncan only be cleared by power-on reset.",
        "implication": "Software that uses the Corrected Error Count field and expects to be able to clear the \nsticky count overflow bit may misinterpret the number of corrected errors when the \nsticky count overflow bit is set. This erratum does not affect threshold-based \nCorrected Machine Check Error Interrupt (CMCI) signaling.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "018": {
        "title": "PEBS Eventing IP Field May be Incorrect After Not-Taken Branch",
        "problem": "When a Precise-Event-Based-Sampling (PEBS) record is logged immediately after a \nnot-taken conditional branch (Jcc instruction), the Eventing IP field should contain \nthe address of the first byte of the Jcc instruction. Due to this erratum, it may instead \ncontain the address of the instruction preceding the Jcc instruction.",
        "implication": "Performance monitoring software using PEBS may incorrectly attribute PEBS events \nthat occur on a Jcc to the preceding instruction.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "019": {
        "title": "Debug Exceptions May Be Lost or Misreported Following WRMSR to \nIA32_BIOS_UPDT_TRIG",
        "problem": "If the WRMSR instruction writes to the IA32_BIOS_UPDT_TRIG MSR (79H) \nimmediately after an execution of MOV SS or POP SS that generated a debug \nexception, the processor may fail to deliver the debug exception or, if it does, the \nDR6 register contents may not correctly reflect the causes of the debug exception.",
        "implication": "Debugging software may fail to operate properly if a debug exception is lost or does \nnot report complete information.",
        "workaround": "Software should avoid using WRMSR instruction immediately after executing MOV SS \nor POP SS",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "020": {
        "title": "Complex Interactions With Internal Graphics May Impact Processor \nResponsiveness",
        "problem": "Under complex conditions associated with the use of internal graphics, the processor \nmay exceed the MAX_LAT CSR values (PCI configuration space, offset 03FH, \nbits[7:0]).",
        "implication": "When this erratum occurs, the processor responsiveness is affected. Intel has not \nobserved this erratum with any commercially available software.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "021": {
        "title": "Intel\u00ae Processor Trace PSB+ Packets May Contain Unexpected Packets",
        "problem": "Some Intel Processor Trace packets should be issued only between Target IP \nPacket.Packet Generation Enable (TIP.PGE) and Target IP Packet.Packet Generation \nDisable (TIP.PGD) packets. Due to this erratum, when a TIP.PGE packet is generated \nit may be preceded by a Packet Stream Boundary (PSB+) that incorrectly includes \nFlow Update Packet (FUP) and MODE.Exec packets.",
        "implication": "Due to this erratum, FUP and MODE.Exec may be generated unexpectedly.",
        "workaround": "Decoders should ignore FUP and MODE.Exec packets that are not between TIP.PGE \nand TIP.PGD packets.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "023": {
        "title": "VM Entry That Clears TraceEn May Generate a FUP",
        "problem": "If VM entry clears Intel\u00ae Processor Trace (Intel\u00ae PT) IA32_RTIT_CTL.TraceEn (MSR \n570H, bit 0) while PacketEn is 1 then a Flow Update Packet (FUP) will precede the \nTarget IP Packet, Packet Generation Disable (TIP.PGD). VM entry can clear TraceEn if \nthe VM-entry MSR-load area includes an entry for the IA32_RTIT_CTL MSR.",
        "implication": "When this erratum occurs, an unexpected FUP may be generated that creates the \nappearance of an asynchronous event taking place immediately before or during the \nVM entry.",
        "workaround": "The Intel\u00ae PT trace decoder may opt to ignore any FUP whose IP matches that of a \nVM entry instruction.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "024": {
        "title": "Performance Monitor Event For Outstanding Offcore Requests And Snoop \nRequests May be Incorrect",
        "problem": "The performance monitor event OFFCORE_REQUESTS_OUTSTANDING (Event 60H, \nany Umask Value) should count the number of offcore outstanding transactions each \ncycle. Due to this erratum, the counts may be higher or lower than expected.",
        "implication": "The performance monitor event OFFCORE_REQUESTS_OUTSTANDING may reflect an \nincorrect count.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "025": {
        "title": "ENCLU[EGETKEY] Ignores KEYREQUEST.MISCMASK",
        "problem": "The Intel\u00ae Software Guard Extensions (Intel\u00ae SGX) ENCLU[EGETKEY] instruction \nignores the MISCMASK field in KEYREQUEST structure when computing a provisioning \nkey, a provisioning seal key, or a seal key.",
        "implication": "ENCLU[EGETKEY] will return the same key in response to two requests that differ \nonly in the value of KEYREQUEST.MISCMASK.  Intel has not observed this erratum \nwith any commercially available software.",
        "workaround": "When executing the ENCLU[EGETKEY] instruction, software should ensure the bits set \nin KEYREQUEST.MISCMASK are a subset of the bits set in the current SECS\u2019s \nMISCSELECT field.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "026": {
        "title": "POPCNT Instruction May Take Longer to Execute Than Expected",
        "problem": "POPCNT instruction execution with a 32 or 64 bit operand may be delayed until \nprevious non-dependent instructions have executed.",
        "implication": "Software using the POPCNT instruction may experience lower performance than \nexpected.",
        "workaround": "None identified",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "027": {
        "title": "ENCLU[EREPORT] May Cause a #GP When TARGETINFO.MISCSELECT is Non-\nZero",
        "problem": "The Intel\u00ae Software Guard extensions (Intel\u00ae SGX) ENCLU[EREPORT] instruction may \ncause a general protection fault (#GP) if any bit is set in TARGETINFO structure\u2019s \nMISCSELECT field.",
        "implication": "This erratum may cause unexpected general-protection exceptions inside enclaves.",
        "workaround": "When executing the ENCLU[EREPORT] instruction, software should ensure the bits set \nin TARGETINFO.MISCSELECT are a subset of the bits set in the current SECS\u2019s \nMISCSELECT field.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "028": {
        "title": "A VMX Transition Attempting to Load a Non-Existent MSR May Result in a \nShutdown",
        "problem": "A VMX transition may result in a shutdown (without generating a machine-check \nevent) if a non-existent MSR is included in the associated MSR-load area. When such \na shutdown occurs, a machine check error will be logged with \nIA32_MCi_STATUS.MCACOD (bits [15:0]) of 406H, but the processor does not issue \nthe special shutdown cycle. A hardware reset must be used to restart the processor.",
        "implication": "Due to this erratum, the hypervisor may experience an unexpected shutdown.",
        "workaround": "Software should not configure VMX transitions to load non-existent MSRs.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "029": {
        "title": "Transitions Out of 64-bit Mode May Lead to an Incorrect FDP And FIP",
        "problem": "A transition from 64-bit mode to compatibility or legacy modes may result in cause a \nsubsequent x87 FPU state save to zeroing bits [63:32] of the FDP (x87 FPU Data \nPointer Offset) and the FIP (x87 FPU Instruction Pointer Offset).",
        "implication": "Leaving 64-bit mode may result in incorrect FDP and FIP values when x87 FPU state \nis saved.",
        "workaround": "None identified. 64-bit software should save x87 FPU state before leaving 64-bit \nmode if it needs to access the FDP and/or FIP values.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "030": {
        "title": "Intel\u00ae PT FUP May be Dropped After OVF",
        "problem": "Some Intel\u00ae Processor Trace (Intel\u00ae PT) Overflow (OVF) packets may not be followed \nby a Flow Update Packet (FUP) or Target IP Packet, Packet Generation Enable \n(TIP.PGE).",
        "implication": "When this erratum occurs, an unexpected packet sequence is generated.",
        "workaround": "When it encounters an OVF without a following FUP or TIP.PGE, the Intel\u00ae PT trace \ndecoder should scan for the next TIP, TIP.PGE, or PSB+ to resume operation.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "031": {
        "title": "ENCLS[ECREATE] Causes #GP if Enclave Base Address is Not Canonical",
        "problem": "The ENCLS[ECREATE] instruction uses an SGX enclave control structure (SECS) \nreferenced by the SRCPAGE pointer in the PAGEINFO structure, which is referenced \nby the RBX register. Due to this erratum, the instruction causes a general-protection \nfault (#GP) if the SECS attributes indicate that the enclave should operate in 64-bit \nmode and the enclave base linear address in the SECS is not canonical.",
        "implication": "System software will incur a general-protection fault if it mistakenly programs the \nSECS with a non-canonical address. Intel has not observed this erratum with any \ncommercially available software.",
        "workaround": "System software should always specify a canonical address as the base address of \nthe 64-bit mode enclave.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "033": {
        "title": "Processor DDR VREF Signals May Briefly Exceed JEDEC Specifications When Entering \nS3 State",
        "problem": "Voltage glitch of up to 200 mV on the VREF signal lasting for about 1 ms may be \nobserved when entering System S3 state. This violates the JEDEC DDR specifications.",
        "implication": "Intel has not observed this erratum to impact the operation of any commercially \navailable system.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "034": {
        "title": "DR6.B0-B3 May Not Report All Breakpoints Matched When a MOV/POP SS is \nFollowed by a Store or an MMX Instruction",
        "problem": "Normally, data breakpoints matches that occur on a MOV SS, r/m or POP SS will not \ncause a debug exception immediately after MOV/POP SS but will be delayed until the \ninstruction boundary following the next instruction is reached. After the debug \nexception occurs, DR6.B0-B3 bits will contain information about data breakpoints \nmatched during the MOV/POP SS as well as breakpoints detected by the following \ninstruction. Due to this erratum, DR6.B0-B3 bits may not contain information about \ndata breakpoints matched during the MOV/POP SS when the following instruction is \neither an MMX instruction that uses a memory addressing mode with an index or a \nstore instruction.",
        "implication": "When this erratum occurs, DR6 may not contain information about all breakpoints \nmatched. This erratum will not be observed under the recommended usage of the \nMOV SS, r/m or POP SS instructions (i.e., following them only with an instruction that \nwrites (E/R) SP).",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "035": {
        "title": "ENCLS[EINIT] Instruction May Unexpectedly #GP",
        "problem": "When using Intel\u00ae Software Guard Extensions (Intel\u00ae SGX), the ENCLS[EINIT] \ninstruction will incorrectly cause a general protection fault (#GP) if the MISCSELECT \nfield of the SIGSTRUCT structure is not zero.",
        "implication": "This erratum may cause an unexpected #GP, but only if software has set bits in the \nMISCSELECT field in SIGSTRUCT structure that do not correspond to extended \nfeatures that can be written to the MISC region of the State Save Area (SSA). Intel \nhas not observed this erratum with any commercially available software.",
        "workaround": "When executing the ENCLS[EINIT] instruction, software should only set bits in the \nMISCSELECT field in the SIGSTRUCT structure that are enumerated as 1 by \nCPUID.(EAX=12H,ECX=0):EBX (the bit vector of extended features that can be \nwritten to the MISC region of the SSA).",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "036": {
        "title": "Intel\u00ae PT OVF Packet May be Lost if Immediately Preceding a TraceStop",
        "problem": "If an Intel\u00ae Processor Trace (Intel\u00ae PT) internal buffer overflow occurs immediately \nbefore software executes a taken branch or event that enters an Intel\u00ae PT TraceStop \nregion, the Overflow (OVF) packet may be lost.",
        "implication": "The trace decoder will not recognize the OVF packet, nor any subsequent packets \n(Example, TraceStop) that were lost due to overflow.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "037": {
        "title": "WRMSR to IA32_BIOS_UPDT_TRIG May be Counted as Multiple Instructions",
        "problem": "When software loads a microcode update by writing to MSR IA32_BIOS_UPDT_TRIG \n(79H) on multiple logical processors in parallel, a logical processor may, due to this \nerratum, count the WRMSR instruction as multiple instruction-retired events.",
        "implication": "Performance monitoring with the instruction-retired event may over count by up to \nfour extra events per instance of WRMSR which targets the IA32_BIOS_UPDT_TRIG \nregister.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "038": {
        "title": "Branch Instructions May Initialize MPX Bound Registers Incorrectly",
        "problem": "Depending on the current Intel\u00ae Memory Protection Extensions (Intel\u00ae MPX) \nconfiguration, execution of certain branch instructions (near CALL, near RET, near \nJMP, and Jcc instructions) without a BND prefix (F2H) initialize the MPX bound \nregisters. Due to this erratum, execution of such a branch instruction on a user-mode \npage may not use the MPX configuration register appropriate to the current privilege \nlevel (BNDCFGU for CPL 3 or BNDCFGS otherwise) for determining whether to \ninitialize the bound registers; it may thus initialize the bound registers when it should \nnot, or fail to initialize them when it should.",
        "implication": "After a branch instruction on a user-mode page has executed, a bound-range (#BR) \nexception may occur when it should not have or a #BR may not occur when one \nshould have.",
        "workaround": "If supervisor software is not expected to execute instructions on user-mode pages, \nsoftware can avoid this erratum by setting CR4.SMEP[bit 20] to enable supervisor-\nmode execution prevention (SMEP). If SMEP is not available or if supervisor software \nis expected to execute instructions on user-mode pages, no workaround is identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "039": {
        "title": "Writing a Non-Canonical Value to an LBR MSR Does Not Signal a #GP When \nIntel\u00ae PT is Enabled",
        "problem": "If Intel\u00ae Processor Trace (Intel\u00ae PT) is enabled, WRMSR will not cause a general-\nprotection exception (#GP) on an attempt to write a non-canonical value to any of \nthe following MSRs:   \nMSR_LASTBRANCH_{0 - 31}_FROM_IP (680H \u2013 69FH) \n\u2022 \nMSR_LASTBRANCH__{0 - 31}_TO_IP (6C0H \u2013 6DFH) \n\u2022 \nMSR_LASTBRANCH_FROM_IP (1DBH) \n\u2022 \nMSR_LASTBRANCH_TO_IP (1DCH) \n\u2022 \nMSR_LASTINT_FROM_IP (1DDH) \n\u2022 \nMSR_LASTINT_TO_IP (1DEH) \n\u2022 \nInstead the same behavior will occur as if a canonical value had been written. \nSpecifically, the WRMSR will be dropped and the MSR value will not be changed.",
        "implication": "Due to this erratum, an expected #GP may not be signaled.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "040": {
        "title": "Processor May Run Intel\u00ae AVX Code Much Slower Than Expected",
        "problem": "After a C6 state exit, the execution rate of AVX instructions may be reduced.",
        "implication": "Applications using AVX instructions may run slower than expected.",
        "workaround": "It is possible for the BIOS to contain a workaround",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "041": {
        "title": "Intel\u00ae PT Buffer Overflow May Result in Incorrect Packets",
        "problem": "Under complex micro-architectural conditions, an Intel\u00ae Processor Trace (Intel\u00ae PT) \nOverflow (OVF) packet may be issued after the first byte of a multi-byte Cycle Count \n(CYC) packet, instead of any remaining bytes of the CYC.",
        "implication": "When this erratum occurs, the splicing of the CYC and OVF packets may prevent the \nIntel\u00ae PT decoder from recognizing the overflow. The Intel\u00ae PT decoder may then \nencounter subsequent packets that are not consistent with expected behavior.",
        "workaround": "None Identified. The decoder may be able to recognize that this erratum has \noccurred when a two-byte CYC packet is followed by a single byte CYC, where the \nlatter 2 bytes are 0xf302, and where the CYC packets are followed by a Flow Update Packet (FUP) and a Packet Stream Boundary+ (PSB+). It should then treat the two CYC packets as indicating an overflow.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "042": {
        "title": "Last Level Cache Performance Monitoring Events May be Inaccurate",
        "problem": "The performance monitoring events LONGEST_LAT_CACHE.REFERENCE (Event 2EH; \nUmask 4FH) and LONGEST_LAT_CACHE.MISS (Event 2EH; Umask 41H) count \nrequests that reference or miss in the last level cache. However, due to this erratum, \nthe count may be incorrect.",
        "implication": "LONGEST_LAT_CACHE events may be incorrect.",
        "workaround": "None identified. Software may use the following OFFCORE_REQUESTS model-specific \nsub events that provide related performance monitoring data: \nDEMAND_DATA_RD, DEMAND_CODE_RD, DEMAND_RFO, ALL_DATA_RD, \nL3_MISS_DEMAND_DATA_RD, ALL_REQUESTS.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "043": {
        "title": "#GP Occurs Rather Than #DB on Code Page Split Inside an Intel\u00ae SGX \nEnclave",
        "problem": "When executing within an Intel\u00ae Software Guard Extensions (Intel\u00ae SGX) enclave, a \ngeneral-protection exception (#GP) may be delivered instead of a debug exception \n(#DB) when an instruction breakpoint is detected. This occurs when the instruction to \nbe executed spans two pages, the second of which has an entry in the enclave page \ncache map (EPCM) that is not valid.",
        "implication": "Debugging software may not be invoked when an instruction breakpoint is detected.",
        "workaround": "Software should ensure that all pages containing enclave instructions have valid \nEPCM entries.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "044": {
        "title": "Execution of VAESENCLAST Instruction May Produce a #NM Exception \nInstead of a #UD Exception",
        "problem": "Execution of VAESENCLAST with VEX.L= 1 should signal a #UD (Invalid Opcode) \nexception, however, due to the erratum, a #NM (Device Not Available) exception \nmay be signaled instead.",
        "implication": "As a result of this erratum, an operating system may restore AVX and other state \nunnecessarily.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "045": {
        "title": "Intel\u00ae SGX Enclave Accesses to the APIC-Access Page May Cause APIC-\nAccess VM Exits",
        "problem": "In VMX non-root operation, Intel\u00ae Software Guard Extensions (Intel\u00ae SGX) enclave \naccesses to the APIC-access page may cause APIC-access VM exits instead of page \nfaults.",
        "implication": "A virtual-machine monitor (VMM) may receive a VM exit due to an access that should \nhave caused a page fault, which would be handled by the guest operating system \n(OS).",
        "workaround": "A VMM avoids this erratum if it does not map any part of the Enclave Page Cache \n(EPC) to the guest\u2019s APIC-access address; an operating system avoids this erratum if \nit does not attempt indirect enclave accesses to the APIC.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "046": {
        "title": "CR3 Filtering Does Not Compare Bits [11:5] of CR3 and \nIA32_RTIT_CR3_MATCH in PAE Paging Mode",
        "problem": "In PAE paging mode, the CR3[11:5] are used to locate the page-directory-pointer \ntable. Due to this erratum, those bits of CR3 are not compared to \nIA32_RTIT_CR3_MATCH (MSR 572H) when IA32_RTIT_CTL.CR3Filter (MSR 570H, \nbit 7) is set.",
        "implication": "If multiple page-directory-pointer tables are co-located within a 4 KB region, CR3 \nfiltering will not be able to distinguish between them so additional processes may \nbe traced.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "047": {
        "title": "x87 FDP Value May be Saved Incorrectly",
        "problem": "Execution of the FSAVE, FNSAVE, FSTENV, or FNSTENV instructions in real-address \nmode or virtual-8086 mode may save an incorrect value for the x87 FDP (FPU data \npointer). This erratum does not apply if the last non-control x87 instruction had an \nunmasked exception.",
        "implication": "Software operating in real-address mode or virtual-8086 mode that depends on the \nFDP value for non-control x87 instructions without unmasked exceptions may not \noperate properly.",
        "workaround": "None identified. Software should use the FDP value saved by the listed instructions \nonly when the most recent non-control x87 instruction incurred an unmasked \nexception.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "048": {
        "title": "PECI Frequency Limited to 1 MHz",
        "problem": "The Platform Environmental Control Interface (PECI) 3.1 specification\u2019s operating \nfrequency range is 0.2 MHz to 2 MHz. Due to this erratum, PECI may be unreliable \nwhen operated above 1 MHz.",
        "implication": "Platforms attempting to run PECI above 1 MHz may not behave as expected.",
        "workaround": "None identified. Platforms should limit PECI operating frequency to 1 MHz.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "049": {
        "title": "Processor Graphics IOMMU Unit May Not Mask DMA Remapping Faults",
        "problem": "Intel\u00ae Virtualization Technology for Directed I/O specification specifies setting the \nFault Processing Disable (FPD) field in the context (or extended-context) entry of \nIOMMU to mask recording of qualified DMA remapping faults for DMA requests \nprocessed through that context entry. Due to this erratum, the IOMMU unit for \nProcessor Graphics device may record DMA remapping faults from Processor Graphics \ndevice (Bus: 0; Device: 2; Function: 0) even when the FPD field is set to 1.",
        "implication": "Software may continue to observe DMA remapping faults recorded in the IOMMU \nFault Recording Register even after setting the FPD field.",
        "workaround": "None identified. Software may mask the fault reporting event by setting the Interrupt \nMask (IM) field in the IOMMU Fault Event Control register (Offset 038H in \nGFXVTBAR).",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "050": {
        "title": "Intel\u00ae PT CYCThresh Value of 13 is Not Supported",
        "problem": "Intel\u00ae Processor Trace (Intel\u00ae PT) Cycle Count (CYC) threshold is configured through \nCYCThresh field in bits [22:19] of IA32_RTIT_CTL MSR (570H). A value of 13 is \nadvertised as supported by CPUID (leaf 14H, sub-lead 1H). Due to this erratum, if \nCYCThresh is set to 13, then the CYC threshold will be 0 cycles instead of 4096 (213-1) \ncycles.",
        "implication": "CYC packets may be issued in higher rate than expected if threshold value of 13 is used",
        "workaround": "None identified. Software should not use value of 13 for CYC threshold.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "051": {
        "title": "Enabling VMX-Preemption Timer Blocks HDC Operation",
        "problem": "Hardware Duty Cycling (HDC) will not put the physical package into the forced idle \nstate while any logical processor is in VMX non-root operation and the \u201cactivate VMX-\npreemption timer\u201d VM-execution control is 1.",
        "implication": "HDC will not provide the desired power reduction when the VMX-preemption timer is \nactive in VMX non-root operation.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "052": {
        "title": "Integrated Audio Codec May Not be Detected",
        "problem": "Integrated Audio Codec may lose power when Low-Power Single Pipe (LPSP) mode is \nenabled for an embedded DisplayPort (eDP*) or DP/HDMI ports. Platforms with Intel\u00ae \nSmart Sound Technology (Intel\u00ae SST) enabled are not affected.",
        "implication": "The Audio Bus driver may attempt to do enumeration of Codecs when eDP or \nDP/HDMI port enters LPSP mode, due to this erratum, the Integrated Audio Codec \nwill not be detected and audio maybe be lost.",
        "workaround": "Intel\u00ae Graphics Driver 15.40.11.4312 or later will prevent the Integrated Audio Codec \nfrom losing power when LPSP mode is enabled.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "053": {
        "title": "Display Flickering May be Observed with Specific eDP Panels",
        "problem": "The processor may incorrectly configure transmitter buffer characteristics if the \nassociated eDP panel requests VESA equalization preset 3, 5, 6, or 8.",
        "implication": "Display flickering or display loss maybe observed.",
        "workaround": "Intel\u00ae Graphics Driver version 15.40.12.4326 or later contains a workaround for this \nerratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "054": {
        "title": "Incorrect Branch Predicted Bit in BTS/BTM Branch Records",
        "problem": "Branch Trace Store (BTS) and Branch Trace Message (BTM) send branch records to \nthe Debug Store management area and system bus respectively. The Branch \nPredicted bit (bit 4 of eighth byte in BTS/BTM records) should report whether the \nmost recent branch was predicted correctly. Due to this erratum, the Branch \nPredicted bit may be incorrect.",
        "implication": "BTS and BTM cannot be used to determine the accuracy of branch prediction.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "055": {
        "title": "MACHINE_CLEARS.MEMORY_ORDERING Performance Monitoring Event May \nUndercount",
        "problem": "The performance monitoring event MACHINE_CLEARS.MEMORY_ORDERING (Event \nC3H; Umask 02H) counts the number of machine clears caused by memory ordering \nconflicts. However due to this erratum, this event may undercount for \nVGATHER*/VPGATHER* instructions of four or more elements.",
        "implication": "MACHINE_CLEARS.MEMORY_ORDERING performance monitoring event may \nundercount.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "056": {
        "title": "CTR_FRZ May Not Freeze Some Counters",
        "problem": "IA32_PERF_GLOBAL_STATUS.CTR_FRZ (MSR 38EH, bit 59) is set when either  \nIA32_DEBUGCTL.FREEZE_PERFMON_ON_PMI (MSR 1D9H, bit 12) is set and a \n\u2022 \nPMI is triggered, or  \nSoftware sets bit 59 of IA32_PERF_GLOBAL_STATUS_SET (MSR 391H). When \n\u2022 \nset, CTR_FRZ should stop all core performance monitoring counters from \ncounting. However, due to this erratum, IA32_PMC4-7 (MSR C5-C8H) may not \nstop counting. IA32_PMC4-7 are only available when a processor core is not \nshared by two logical processors.",
        "implication": "General performance monitoring counters 4-7 may not freeze when \nIA32_PERF_GLOBAL_STATUS.CTR_FRZ is set.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "057": {
        "title": "Instructions And Branches Retired Performance Monitoring Events May \nOvercount",
        "problem": "The performance monitoring events INST_RETIRED (Event C0H; any Umask value) \nand BR_INST_RETIRED (Event C4H; any Umask value) count instructions retired and \nbranches retired, respectively. However, due to this erratum, these events may \novercount in certain conditions when: \nExecuting VMASKMOV* instructions with at least one masked vector \n\u2022 \nelement \nExecuting REP MOVS or REP STOS with Fast Strings enabled \n\u2022 \n(IA32_MISC_ENABLES MSR (1A0H), bit 0 set). \nAn MPX #BR exception occurred on BNDLDX/BNDSTX instructions and \n\u2022 \nthe BR_INST_RETIRED (Event C4H; Umask is 00H or 04H) is used.",
        "implication": "INST_RETIRED and BR_INST_RETIRED performance monitoring events may \novercount.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "058": {
        "title": "Some OFFCORE_RESPONSE Performance Monitoring Events May Overcount",
        "problem": "The performance monitoring events OFFCORE_RESPONSE (Events B7H and BBH) \nshould count off-core responses matching the request-response configuration \nspecified in MSR_OFFCORE_RSP_0 and MSR_OFFCORE_RSP_1 (1A6H and 1A7H, \nrespectively) for core-originated requests. However, due to this erratum, DMND_RFO \n(bit 1), DMND_IFETCH (bit 2) and OTHER (bit 15) request types may overcount.",
        "implication": "Some OFFCORE_RESPONSE events may overcount.",
        "workaround": "None identified. Software may use the following model-specific events that provide \nrelated performance monitoring data: OFFCORE_REQUESTS (all sub-events), \nL2_TRANS.L2_WB and L2_RQSTS.PF_MISS.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "059": {
        "title": "Instructions Fetch #GP After RSM During Intel\u00ae PT May Push Incorrect \nRFLAGS Value on Stack",
        "problem": "If Intel\u00ae Processor Trace (Intel\u00ae PT) is enabled, a General Protection Fault (#GP) \ncaused by the instruction fetch immediately following execution of an RSM instruction \nmay push an incorrect value for RFLAGS onto the stack.",
        "implication": "Software that relies on RFLAGS value pushed on the stack under the conditions \ndescribed may not work properly.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "060": {
        "title": "Access to SGX EPC Page in BLOCKED State is Not Reported as an SGX-\nInduced Page Fault",
        "problem": "If a page fault results from attempting to access a page in the Intel\u00ae Software Guard \nExtensions (Intel\u00ae SGX) Enclave Page Cache (EPC) that is in the BLOCKED state, the \nprocessor does not set bit 15 of the error code and thus fails to indicate that the page \nfault was SGX-induced.",
        "implication": "Due to this erratum, software may not recognize these page faults as being SGX-\ninduced.",
        "workaround": "Before using the EBLOCK instruction to marking a page as BLOCKED, software should \nuse paging to mark the page not present.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "061": {
        "title": "MTF VM Exit on XBEGIN Instruction May Save State Incorrectly",
        "problem": "Execution of an XBEGIN instruction while the monitor trap flag VM-execution control \nis 1 will be immediately followed by an MTF VM exit. If advanced debugging of RTM \ntransactional regions has been enabled, the VM exit will erroneously save as \ninstruction pointer the address of the XBEGIN instruction instead of the fallback \ninstruction address specified by the XBEGIN instruction. In addition, it will \nerroneously set bit 16 of the pending-debug-exceptions field in the VMCS indicating \nthat a debug exception or a breakpoint exception occurred.",
        "implication": "Software using the monitor trap flag to debug or trace transactional regions may not \noperate properly. Intel has not observed this erratum with any commercially available \nsoftware.",
        "workaround": "None identified",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "062": {
        "title": "Performance Monitoring Counters May Undercount When Using CPL Filtering",
        "problem": "Performance Monitoring counters configured to count only OS or only USR events by \nsetting exactly one of bits 16 or 17 in IA32_PERFEVTSELx MSRs (186H-18DH) may \nnot count for a brief period during the transition to a new CPL.",
        "implication": "A measurement of ring transitions (using the edge-detect bit 18 in \nIA32_PERFEVTSELx) may undercount, such as CPL_CYCLES.RING0_TRANS (Event \n5CH, Umask 01H). Additionally, the sum of an OS-only event and a USR-only event \nmay not exactly equal an event counting both OS and USR. Intel has not observed \nany other software-visible impact",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "063": {
        "title": "Certain Non-Canonical IA32_BNDCFGS Values Will Not Cause VM-Entry \nFailures",
        "problem": "If the VM-entry controls Load IA32_BNDCFGS field (bit 16) is 1, VM-entry should fail \nwhen the value of the guest IA32_BNDCFGS field in the VMCS is not canonical (that \nis, when bits 63:47 are not identical). Due to this erratum, VM-entry does not fail if \nbits 63:48 are identical but differ from bit 47. In this case, VM-entry loads the \nIA32_BNDCFGS MSR with a value in which bits 63:48 are identical to the value of bit \n47 in the VMCS field.",
        "implication": "If the value of the guest IA32_BNDCFGS field in the VMCS is not canonical, VM-entry \nmay load the IA32_BNDCFGS MSR with a value different from that of the VMCS field.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "064": {
        "title": "PEBS EventingIP Field May Be Incorrect Under Certain Conditions",
        "problem": "The EventingIP field in the Processor Event-Based Sampling (PEBS) record reports \nthe address of the instruction that triggered the PEBS event. Under certain complex \nmicroarchitectural conditions, the EventingIP field may be incorrect.",
        "implication": "When this erratum occurs, performance monitoring software may not attribute the \nPEBS events to the correct instruction.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "065": {
        "title": "HWP\u2019s Guaranteed_Performance Updated Only on Configurable TDP \nChanges",
        "problem": "According to Hardware P-states (HWP) specification, the Guaranteed_Performance \nfield (bits[15:8]) in the IA32_HWP_CAPABILITIES MSR (771H) should be updated as \na result of changes in the configuration of TDP, Running Average Power Limit (RAPL), \nand other platform tuning options that may have dynamic effects on the actual \nguaranteed performance support level. Due to this erratum, the processor will update the Guaranteed_Performance field only as a result of configurable TDP dynamic \nchanges.",
        "implication": "Software may read a stale value of the Guaranteed _Performance field.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "066": {
        "title": "RF May be Incorrectly Set in The EFLAGS That is Saved on a Fault in PEBS or \nBTS",
        "problem": "After a fault due to a failed Processor Event Based Sampling (PEBS) or Branch Trace \nStore (BTS) address translation, the resume flag (RF) may be incorrectly set in the \nEFLAGS image that is saved.",
        "implication": "When this erratum occurs, a code breakpoint on the instruction following the return \nfrom handling the fault will not be detected. This erratum only happens when the \nuser does not prevent faults on PEBS or BTS.",
        "workaround": "Software should always prevent faults on PEBS or BTS.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "067": {
        "title": "Intel\u00ae PT ToPA PMI Does Not Freeze Performance Monitoring Counters",
        "problem": "Due to this erratum, if IA32_DEBUGCTL.FREEZE_PERFMON_ON_PMI (MSR 1D9H, bit \n12) is set to 1 when Intel\u00ae Processor Trace (Intel\u00ae PT) triggers a Table of Physical \nAddresses (ToPA) PerfMon Interrupt (PMI), performance monitoring counters are not \nfrozen as expected.",
        "implication": "Performance monitoring counters will continue to count for events that occur during \nPMI handler execution.",
        "workaround": "PMI handler software can programmatically stop performance monitoring counters \nupon entry.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "068": {
        "title": "HWP\u2019s Maximum_Performance Value is Reset to 0xFF",
        "problem": "According to Hardware P-states (HWP) specification, the reset value of the \nMaximum_Performance field (bits [15:8]) in IA32_HWP_REQUEST MSR (774h) should \nbe set to the value of IA32_HWP_CAPABILITIES MSR (771H) Highest_Performance \nfield (bits[7:0]) after reset. Due to this erratum, the reset value of \nMaximum_Performance is always set to 0xFF.",
        "implication": "Software may refer an unexpected value in Maximum Performance field. Hardware \nclipping will prevent invalid performance states.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "069": {
        "title": "HWP\u2019s Guaranteed_Performance and Relevant Status/Interrupt May be \nUpdated More Than Once Per Second",
        "problem": "According to Hardware P-states (HWP) specification, the Guaranteed_Performance \nfield (bits[15:8]) in the IA32_HWP_CAPABILITIES MSR (771H) and the \nGuaranteed_Performance_Change (bit 0) bit in IA32_HWP_STATUS MSR (777H) \nshould not be changed more than once per second nor should the thermal interrupt \nassociated with the change to these fields be signaled more than once per second. \nDue to this erratum, the processor may change these fields and generate the \nassociated interrupt more than once per second",
        "implication": "HWP interrupt rate due to Guaranteed_Performance field change can be higher than \nspecified",
        "workaround": "Clearing the Guaranteed_Performance_Change status bit no more than once per \nsecond will ensure that interrupts are not generated at too fast a rate",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "070": {
        "title": "Some Memory Performance Monitoring Events May Produce Incorrect \nResults When Filtering on Either OS or USR Modes",
        "problem": "The memory at-retirement performance monitoring events (listed below) may \nproduce incorrect results when a performance counter is configured in OS-only or \nUSR-only modes (bits 17 or 16 in IA32_PERFEVTSELx MSR). Counters with both OS \nand USR bits set are not affected by this erratum. \nThe list of affected memory at-retirement events is as follows: \nMEM_INST_RETIRED.STLB_MISS_LOADS event D0H, umask 11H \nMEM_INST_RETIRED.STLB_MISS_STORES event D0H, umask 12H \nMEM_INST_RETIRED.LOCK_LOADS event D0H, umask 21H \nMEM_INST_RETIRED.SPLIT_LOADS event D0H, umask 41H \nMEM_INST_RETIRED.SPLIT_STORES event D0H, umask 42H \nMEM_LOAD_RETIRED.L2_HIT event D1H, umask 02H \nMEM_LOAD_RETIRED.L3_HIT event D1H, umask 04H \nMEM_LOAD_RETIRED.L4_HIT event D1H, umask 80H \nMEM_LOAD_RETIRED.L1_MISS event D1H, umask 08H \nMEM_LOAD_RETIRED.L2_MISS event D1H, umask 10H \nMEM_LOAD_RETIRED.L3_MISS event D1H, umask 20H \nMEM_LOAD_RETIRED.FB_HIT event D1H, umask 40H \nMEM_LOAD_L3_HIT_RETIRED.XSNP_MISS event D2H, umask 01H \nMEM_LOAD_L3_HIT_RETIRED.XSNP_HIT event D2H, umask 02H \nMEM_LOAD_L3_HIT_RETIRED.XSNP_HITM event D2H, umask 04H \nMEM_LOAD_L3_HIT_RETIRED.XSNP_NONE event D2H, umask 08H",
        "implication": "The listed performance monitoring events may produce incorrect results including \nPEBS records generated at an incorrect point",
        "workaround": "None identified",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "071": {
        "title": "HWP May Generate Thermal Interrupt While Not Enabled",
        "problem": "Due to this erratum, the conditions for Hardware P-states (HWP) to generate a \nthermal interrupt on a logical processor may generate thermal interrupts on both \nlogical processors of that core.",
        "implication": "If two logical processors of a core have different configurations of HWP (example, \nonly enabled on one), an unexpected thermal interrupt may occur on one logical \nprocessor due to the HWP settings of the other logical processor.",
        "workaround": "Software should configure HWP consistently on all logical processors of a core.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "072": {
        "title": "Camera Device Does Not Issue an MSI When INTx is Enabled",
        "problem": "When both Message Signaled Interrupts (MSI) and legacy INTx are enabled by the \ncamera device, INTx is asserted rather than issuing the MSI, in violation of the PCI \nLocal Bus Specification.",
        "implication": "Due to this erratum, camera device interrupts can be lost leading to device failure.",
        "workaround": "The camera device must disable legacy INTx by setting bit 10 of PCICMD (Bus 0; \nDevice 5; Function 0; Offset 04H) before MSI is enabled",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "073": {
        "title": "Attempts to Retrain a PCIe* Link May be Ignored",
        "problem": "A PCIe link should retrain when Retrain Link (bit 5) in the Link Control register (Bus \n0; Device 1; Functions 0,1,2; Offset 0xB0) is set. Due to this erratum, if the link is in \nthe L1 state, it may ignore the retrain request",
        "implication": "The PCIe link may not behave as expected.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "074": {
        "title": "PCIe* Port Does Not Support DLL Link Activity Reporting",
        "problem": "The PCIe Base specification requires Data Link Layer (DLL) Link Activity Reporting \nwhen 8 GT/s link speed is supported. Due to this erratum, link activity reporting is \nnot supported",
        "implication": "Due to this erratum, PCIe port does not support DLL Link Activity Reporting when 8 \nGT/s is supported.",
        "workaround": "None identified",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "075": {
        "title": "BNDLDX And BNDSTX May Not Signal #GP on Non-Canonical Bound \nDirectory Access",
        "problem": "BNDLDX and BNDSTX instructions access the bound\u2019s directory and table to load or \nstore bounds. These accesses should signal general protection exception (#GP) when \nthe address is not canonical (i.e. bits 48 to 63 are not the sign extension of bit 47). \nDue to this erratum, #GP may not be generated by the processor when a non-\ncanonical address is used by BNDLDX or BNDSTX for their bound directory memory \naccess.",
        "implication": "Intel has not observed this erratum with any commercially available software.",
        "workaround": "Software should use canonical addresses for bound directory accesses.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "076": {
        "title": "RING_PERF_LIMIT_REASONS May be Incorrect",
        "problem": "Under certain conditions, RING_PERF_LIMIT_REASONS (MSR 6B1H) may incorrectly \nassert the OTHER status bit (bit 8) as well as the OTHER log bit (bit 24).",
        "implication": "When this erratum occurs, software using this register will incorrectly report clipping \nbecause of the OTHER reason.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "077": {
        "title": "Performance Monitoring Load Latency Events May Be Inaccurate For Gather \nInstructions",
        "problem": "The performance monitoring events MEM_TRANS_RETIRED.LOAD_LATENCY_* (Event \nCDH; UMask 01H; any latency) count load instructions whose latency exceed a \npredefined threshold, where the loads are randomly selected using the load latency \nfacility (an extension of PEBS). However due to this erratum, these events may count \nincorrectly for VGATHER*/VPGATHER* instructions.",
        "implication": "The Load Latency Performance Monitoring events may be inaccurate for Gather \ninstructions.",
        "workaround": "None identified",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "079": {
        "title": "Some Bits in MSR_MISC_PWR_MGMT May be Updated on Writing Illegal \nValues to This MSR",
        "problem": "Attempts to write illegal values to MSR_MISC_PWR_MGMT (MSR 0x1AA) result in \nGeneral Protection Fault (#GP) and should not change the MSR value. Due to this \nerratum, some bits in the MSR may be updated on writing an illegal value.",
        "implication": "Certain fields may be updated with allowed values when writing illegal values to \nMSR_MISC_PWR_MGMT. Such writes will always result in #GP as expected.",
        "workaround": "None identified. Software should not attempt to write illegal values to this MSR.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "080": {
        "title": "Violations of Intel\u00ae Software Guard Extensions (Intel\u00ae SGX) Access-Control \nRequirements Produce #GP Instead of #PF",
        "problem": "Intel\u00ae Software Guard Extensions (Intel\u00ae SGX) define new access-control \nrequirements on memory accesses. A violation of any of these requirements causes a \npage fault (#PF) that sets bit 15 (SGX) in the page-fault error code. Due to this \nerratum, these violations instead cause general-protection exceptions (#GP).",
        "implication": "Software resuming from system sleep states S3 or S4 and relying on receiving a page \nfault from the above enclave accesses may not operate properly.",
        "workaround": "Software can monitor #GP faults to detect that an enclave has been destroyed and \nneeds to be rebuilt after resuming from S3 or S4",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "081": {
        "title": "IA32_RTIT_CR3_MATCH MSR Bits[11:5] Are Treated As Reserved",
        "problem": "Due to this erratum, bits[11:5] in IA32_RTIT_CR3_MATCH (MSR 572H) are reserved; \nan MSR write that attempts to set that field to a non-zero value will result in a #GP \nfault.",
        "implication": "The inability to write the identified bit field  does not affect the functioning of Intel\u00ae \nProcessor Trace (Intel\u00ae PT) operation because, as described in erratum SKL061, the \nbit field that is the subject of this erratum is not used during Intel PT CR3 filtering.",
        "workaround": "Ensure that bits 11:5 of the value written to IA32_RTIT_CR3_MATCH are zero, \nincluding cases where the selected page-directory-pointer-table base address has \nnon-zero bits in this range.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "082": {
        "title": "The Intel PT CR3 Filter is Not Re-evaluated on VM Entry",
        "problem": "On a VMRESUME or VMLAUNCH with both TraceEn[0] and CR3Filter[7] in \nIA32_RTIT_CTL (MSR 0570H) set to 1 both before the VM Entry and after, the new \nvalue of CR3 is not compared with IA32_RTIT_CR3_MATCH (MSR 0572H).",
        "implication": "The Intel\u00ae Processor Trace (Intel\u00ae PT) CR3 filtering mechanism may continue to \ngenerate packets despite a mismatching CR3 value, or may fail to generate packets \ndespite a matching CR3, as a result of an incorrect value of \nIA32_RTIT_STATUS.ContextEn[1] (MSR 0571H) that results from the failure to re-\nevaluate the CR3 match on VM entry.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "083": {
        "title": "Display Slowness May be Observed Under Certain Display Commands \nScenario",
        "problem": "Back to back access to the VGA register ports (I/O addresses 0x3C2, 0x3CE, 0x3CF) \nwill experience higher than expected latency.",
        "implication": "Due to this erratum, the processor may redraw the slowly when in VGA mode.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "084": {
        "title": "CPUID TLB Associativity Information is Inaccurate",
        "problem": "CPUID leaf 2 (EAX=02H) TLB information inaccurately reports that the shared 2nd-\nLevel TLB is 6-way set associative (value C3H), although it is 12-way set associative. \nOther information reported by CPUID leaf 2 is accurate.",
        "implication": "Software that uses CPUID shared 2nd-level TLB associativity information for value \nC3H may operate incorrectly. Intel has not observed this erratum to impact the \noperation of any commercially available software",
        "workaround": "None identified. Software should ignore the shared 2nd-Level TLB associativity \ninformation reported by CPUID for the affected processors.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "085": {
        "title": "Using Different Vendors For 2400 MHz DDR4 UDIMMs May Cause \nCorrectable Errors or a System Hang",
        "problem": "When using 2400 MHz DDR4 UDIMMs from different vendors or mixing single rank \nand dual rank DIMMs within the same channel, a higher rate of correctable errors \nmay occur or the system may hang.",
        "implication": "Due to this erratum, reported correctable error counts may increase or the system \nmay hang.",
        "workaround": "None identified. Use a single vendor and do not mix single rank and dual rank for \n2400 MHz UDIMMs.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "086": {
        "title": "Two DIMMs Per Channel 2133MHz DDR4 SODIMM Daisy-Chain Systems With \nDifferent Vendors May Hang",
        "problem": "On a single memory channel with 2133 MHz DDR4 SODIMMs, mixing different \nvendors or mixing single rank and dual rank DIMMs may lead to a higher rate of \ncorrectable error to system hangs.",
        "implication": "Due to this erratum, reported correctable error counts may increase or system may \nhang.",
        "workaround": "Use a single vendor for and do not mix single rank and dual rank 2133 MHz DDR4 \nSODIMM.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "087": {
        "title": "Unpredictable System Behavior May Occur in DDR4 Multi-Rank System",
        "problem": "Due to incorrect configuration of DDR4 ODT by BIOS, it is possible for a multi-rank \nsystem to violate Section 4.27 of the DDR4 JEDEC specification revision JESED79-4A.",
        "implication": "Due to this erratum, complex microarchitectural conditions may result in \nunpredictable system behavior.",
        "workaround": "A BIOS workaround has been identified. Refer to Silicon Initialization version 2.1.0 or \nlater and release notes.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "088": {
        "title": "Processor May Hang on Complex Sequence of Conditions",
        "problem": "A complex set of architectural and micro-architectural conditions may lead to a \nprocessor hang with an internal timeout error (MCACOD 0400H) logged into \nIA32_MC3_STATUS (MSR 040DH, bits [15:0]). When both logical processors in a core \nare active, this erratum will not occur in one logical processor unless there is no \ninterrupt for more than 10 seconds to the other logical processor.",
        "implication": "This erratum may result in a processor hang.  Intel has not observed this erratum \nwith any commercially available software.",
        "workaround": "None Identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "089": {
        "title": "Potential Partial Trace Data Loss in Intel\u00ae Trace Hub ODLA When Storing to \nMemory",
        "problem": "When Intel\u00ae Trace Hub\u2019s On-Die Logic Analyzer (ODLA) is configured to trace to \nmemory, under complex microarchitectural conditions, the trace may lose a \ntimestamp.",
        "implication": "Some ODLA trace data may be lost. This erratum does not affect other trace data \nsources. Typically, lost trace data will be displayed as \u201cOVERFLOW.\u201d Subsequent \ntimestamps will allow the trace decoder to resume tracing. Intel has not observed \nthis erratum in commercially available software.",
        "workaround": "None identified. For a particular workload, changing the memory buffer size or \ndisabling deep compression may eliminate the microarchitectural condition that \ncauses the erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "090": {
        "title": "Using Different Vendors For 2666 MHz DDR4 UDIMMs May Cause \nCorrectable Errors or a System Hang",
        "problem": "When using 2666 MHz DDR4 UDIMMs from different vendors or mixing single rank \nand dual rank DIMMs, within the same channel, a higher rate of correctable errors \nmay occur or the system may hang.",
        "implication": "Due to this erratum, reported correctable error counts may increase or the system \nmay hang.",
        "workaround": "None identified. Use a single vendor and do not mix single rank and dual rank for 2666 MHz UDIMMs.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "091": {
        "title": "Spurious Corrected Errors May be Reported",
        "problem": "Due to this erratum, spurious corrected errors may be logged in the \nIA32_MC0_STATUS MSR (401H) register with the valid field (bit 63) set, the \nuncorrected error field bit (bit 61) not set, a Model Specific Error Code (bits [31:16]) \nof 0x0001, and an MCA Error Code (bits [15:0]) of 0x0005. If CMCI is enabled, these \nspurious corrected errors also signal interrupts.",
        "implication": "When this erratum occurs, software may encounter an unusually high rate of \nreported corrected errors. As it is not possible to distinguish between spurious and \nnon-spurious errors, this erratum may interfere with reporting non-spurious corrected \nerrors.",
        "workaround": "None Identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "092": {
        "title": "Reads From IA32_SGXLEPUBKEYHASH  MSRs Return Values in Incorrect \nOrder",
        "problem": "The IA32_SGXLEPUBKEYHASH [0,1,2,3] (8CH, 8DH, 8EH, 8FH) MSRs allow software \nto select an alternative SGX Launch Enclave provider signing key. Each of 4 MSRs is \nused to specify a 64-bit part of the 256 bit SGX Launch Enclave signing key hash, \nwhere the lower 32 bits of each 64-bit component are to be provided in the EAX \nregister, and the higher 32 bits of each 64-bit component are to be provided in the \nEDX register. Due to this erratum, reads from IA32_SGXLEPUBKEYHASH MSRs will \nreturn the lower 32 bits of the 64-bit component in the EDX register, and the higher \n32 bits of the 64-bit component in the EAX register.",
        "implication": "Software may incorrectly identify the currently active SGX Launch enclave provider \non the platform.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "093": {
        "title": "Masked Bytes in a Vector Masked Store Instructions May Cause Write Back \nof a Cache Line",
        "problem": "Vector masked store instructions to write-back (WB) memory-type that cross cache \nlines may lead to CPU writing back cached data even for cache lines where all of the \nbytes are masked.",
        "implication": "The processor may generate writes of un-modified data.  This can affect MMIO \n(Memory Mapped IO) or non-coherent agents in the following ways: \n1.\nFor MMIO range that is mapped as WB memory type, this erratum may lead to\nMachine Check Exception (MCE) due to writing back data into the MMIO space.\nThis applies only to cross page vector masked stores where one of the pages is in\nMMIO range. 2.\nIf the CPU cached data is stale, for example in the case of memory written\ndirectly by a non-coherent agent (agent that uses non-coherent writes), this\nerratum may lead to writing back stale cached data even if these bytes are\nmasked.",
        "workaround": "Platforms should not map MMIO memory space or non-coherent device memory \nspace as WB memory. If WB is used for MMIO range, software or VMM should not \nmap such MMIO page adjacent to a regular WB page (adjacent on the linear address \nspace, before or after the IO page). Memory that may be written by non-coherent \nagents should be separated by at least 64 bytes from regular memory used for other \npurposes (on the linear address space).",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "094": {
        "title": "MOVNTDQA From WC Memory May Pass Earlier MFENCE instructions",
        "problem": "An execution of (V)MOVNTDQA (streaming load instruction) that loads from WC \n(write combining) memory may appear to pass an earlier MFENCE instruction.",
        "implication": "Serialization of the (V)MOVNTDQA with earlier MFENCE may not be enforced.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "095": {
        "title": "MOVNTDQA From WC Memory May Pass Earlier Locked Instructions",
        "problem": "An execution of (V)MOVNTDQA (streaming load instruction) that loads from write \ncombining (WC) memory may appear to pass an earlier locked instruction to a \ndifferent cache line",
        "implication": "Software that expects a lock to fence subsequent (V)MOVNTDQA instructions may not \noperate properly.",
        "workaround": "Software should not rely on a locked instruction to fence subsequent executions of \nMOVNTDQA.  Software should insert an MFENCE instruction if it needs to preserve \norder between streaming loads and other memory operations.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "096": {
        "title": "PEBS Record After a WRMSR to IA32_BIOS_UPDT_TRIG May be Incorrect",
        "problem": "A PEBS record generated by a WRMSR to IA32_BIOS_UPDT_TRIG MSR (79H) may \nhave an incorrect value in the Eventing EIP field if an instruction prefix was used on \nthe WRMSR.",
        "implication": "The Eventing EIP field of the generated PEBS record may be incorrect. Intel has not \nobserved this erratum with any commercially available software.",
        "workaround": "Instruction prefixes have no architecturally-defined function for the WRMSR \ninstruction; instruction prefixes should not be used with the WRMSR instruction.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "097": {
        "title": "Processor May Incorrectly Assert PROCHOT During PkgC10",
        "problem": "If the PROCHOT# pin is configured as an output-only signal, PROCHOT# may \nincorrectly be asserted during PkgC10.",
        "implication": "When this erratum occurs, PROCHOT# may be incorrectly asserted.  This can lead to \nthe system fan unnecessarily turning on during PkgC10 or other unexpected platform \nbehaviors.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "098": {
        "title": "Writing Non-Zero Values to Read Only Fields in IA32_THERM_STATUS MSR \nMay Cause #GP",
        "problem": "IA32_THERM_STATUS MSR (19CH) includes read-only (RO) fields as well as writable \nfields. Writing a non-zero value to any of the read-only fields may cause a #GP.",
        "implication": "Due to this erratum, software that reads the IA32_THERM_STATUS MSR, modifies \nsome of the writable fields, and attempts to write the MSR back may #GP.",
        "workaround": "Software should clear all read-only fields before writing to this MSR.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "099": {
        "title": "Precise Performance Monitoring May Generate Redundant PEBS Records.",
        "problem": "Processor Event Based Sampling (PEBS) may generate redundant records for a \ncounter overflow when used to profile cycles. This may occur when a precise \nperformance monitoring event is configured on a general counter while setting the \nInvert and Counter Mask fields in IA32_PERFEVTSELx MSRs (186H - 18DH), and the \ncounter is reloaded with a value smaller than 1000 (through the PEBS-counter-reset \nfield of the DS Buffer Management Area).",
        "implication": "PEBS may generate multiple redundant records, when used to profile cycles in certain \nconditions.",
        "workaround": "It is recommended for software to forbid the use of the Invert bit in \nIA32_PERFEVTSELx MSRs or restrict PEBS-counter-reset value to a value of at least \n1000",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "100": {
        "title": "Load Latency Performance Monitoring Facility May Stop Counting",
        "problem": "The performance monitoring events MEM_TRANS_RETIRED.LOAD_LATENCY_* (Event \nCDH; UMask 01H; any latency) count load instructions whose latency exceed a \npredefined threshold, where the loads are randomly selected using the Load Latency \nfacility (PEBS extension). However due to this erratum, load latency facility may stop \ncounting load instructions when Intel\u00ae HyperThreading Technology is enabled.",
        "implication": "Counters programmed with the affected events stop incrementing and do not \ngenerate PEBS records.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "101": {
        "title": "SGX ENCLS[EINIT] May Not Signal an Error For an Incorrectly Formatted \nSIGSTRUCT Input",
        "problem": "The ENCLS[EINIT] instruction leaf may not signal an error on a specific combination \nof SIGSTRUCT values even though the signature does not fully comply with RSA \nsignature specifications.",
        "implication": "When this erratum occurs, ENCLS[EINIT] instruction leaf may pass the checks \nalthough the SIGSTUCT signature does not fully comply with RSA signature \nspecifications.  This erratum does not compromise the security of SGX and does not \nimpact normal usage of SGX.",
        "workaround": "None identified. Software is not expected to be impacted by this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "102": {
        "title": "Branch Instruction Address May be Incorrectly Reported on TSX Abort When \nUsing MPX",
        "problem": "When using Intel\u00ae Memory Protection Extensions (MPX), an Intel\u00ae Transactional \nSynchronization Extensions (TSX) transaction abort will occur in case of legacy \nbranch (that causes bounds registers INIT) when at least one MPX bounds register \nwas in a NON-INIT state. On such an abort, the branch Instruction address should be \nreported in the FROM_IP field in the Last Branch Records (LBR), Branch Trace Store \n(BTS) and Branch Trace Message (BTM) as well as in the Flow Update Packets (FUP) \nsource IP address for Processor Trace (PT). Due to this erratum, the FROM_IP field in \nLBR/BTS/BTM, as well as the Flow Update Packets (FUP) source IP address that \ncorrespond to the TSX abort, may point to the preceding instruction.",
        "implication": "Software that relies on the accuracy of the FROM_IP field/FUP source IP address and \nuses TSX may operate incorrectly when MPX is used.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "103": {
        "title": "Setting Performance Monitoring IA32_PERF_GLOBAL_STATUS_SET MSR Bit \n63 May Not #GP",
        "problem": "Bit 63 of IA32_PERF_GLOBAL_STATUS_SET MSR (391H) is reserved. Due to this \nerratum, setting the bit will not result in General Protection Fault (#GP).",
        "implication": "Software that attempts to set bit 63 of IA32_PERF_GLOBAL_STATUS_SET MSR does \nnot generate #GP.  There are no other system implications to this behavior.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "104": {
        "title": "Hitting a Code Breakpoint Inside a SGX Debug Enclave May Cause The \nProcessor to Hang",
        "problem": "Under complex microarchitecture conditions, the processor may hang when hitting \ncode breakpoint inside Intel\u00ae Software Guard Extensions (Intel\u00ae SGX) debug enclave. \nThis may happen only after opt-out entry into Intel\u00ae SGX debug enclave and when \nthe execution would set the accessed bit (A-bit) in any level of the paging or \nextended page table (EPT) structures used to map the code page, and when both \nlogical processors on the same physical core are active.",
        "implication": "Due to this erratum, the processor may hang while debugging an SGX debug enclave.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "105": {
        "title": "Performance Monitoring ASCI Status Bit May be Inaccurate",
        "problem": "The Anti Side-Channel Interference (ASCI) field in IA32_PERF_GLOBAL_STATUS \n(MSR 38EH, bit 60) should be set when the count in any of the configured \nperformance counters (i.e. IA32_PMCx or IA32_FIXED_CTRx) was altered due to \ndirect or indirect operation of Intel\u00ae SGX. Due to this erratum, the ASCI bit may not \nbe set properly when IA32_FIXED_CTR0 is used.",
        "implication": "Software that relies on the value of the ASCI bit in IA32_PERF_GLOBAL_STATUS for \nits operation may not operate correctly when IA32_FIXED_CTR0 is used.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "106": {
        "title": "Processor May Hang When Executing Code In an HLE Transaction Region",
        "problem": "Under certain conditions, if the processor acquires an Hardware Lock Elision (HLE) \nlock via the XACQUIRE instruction in the Host Physical Address range between \n40000000H and 403FFFFFH, it may hang with an internal timeout error (MCACOD \n0400H) logged into IA32_MCi_STATUS.",
        "implication": "Due to this erratum, the processor may hang after acquiring a lock via XACQUIRE.",
        "workaround": "BIOS can reserve the host physical address ranges of 40000000H and 403FFFFFH \n(Example, map it as UC/MMIO). Alternatively, the Virtual Machine Monitor (VMM) can \nreserve that address range so no guest can use it. In non-virtualized systems, the OS \ncan reserve that memory space.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "107": {
        "title": "The Processor May Fail to Boot During DDR4 Memory Training",
        "problem": "The BIOS may fail to properly configure the required DQ/DQS timing parameters for \ncertain DDR4 DIMMs with large length deltas between byte lanes (long fly-by \ntopology).",
        "implication": "An incorrect timing parameter value may cause DDR to mis-sample incoming data \nduring write operations, leading to memory training failures and subsequent system \nboot hangs. Board designs with DDR4 DIMMs short delta lengths between byte lanes \n(short fly-by topology) are not impacted.",
        "workaround": "-S/H with CNP NDA Workaround: A BIOS workaround has been identified. Refer to\nBIOS Package 118.19 or later and release notes.\n-S with KBP NDA Workaround: A BIOS workaround has been identified. Refer to BIOS\nPackage 138.2 or later and release notes.\nPublic Workaround: A BIOS code change has been identified and may be \nimplemented as a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "108": {
        "title": "Intel\u00ae PT CYC Packets Can be Dropped When Immediately Preceding PSB",
        "problem": "Due to a rare microarchitectural condition, generation of an Intel\u00ae Processor Trace \n(Intel\u00ae PT) Packet Stream Boundary (PSB) packet can cause a single Cycle Count \n(CYC) packet, possibly along with an associated Mini Time Counter (MTC) packet, to \nbe dropped.",
        "implication": "An Intel\u00ae PT decoder that is using CYCs to track time or frequency will get an \nimproper value due to the lost CYC packet.",
        "workaround": "If an Intel\u00ae PT decoder is using CYCs and MTCs to track frequency, and either the \nfirst MTC following a PSB shows that an MTC was dropped, or the CYC value appears \nto be 4095 cycles short of what is expected, the CYC value associated with that MTC \nshould not be used.  The decoder should wait for the next MTC before measuring \nfrequency again.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "109": {
        "title": "Intel\u00ae PT VM-entry Indication Depends on The Incorrect VMCS Control Field",
        "problem": "An Intel\u00ae Processor Trace Paging Information Packet (PIP), which includes indication \nof entry into non-root operation, will be generated on VM-entry as long as the \n\u201cConceal VMX in Intel\u00ae PT\u201d field (bit 19) in Secondary Execution Control register \n(IA32_VMX_PROCBASED_CTLS2, MSR 048BH) is clear.  This diverges from expected \nbehavior, since this PIP should instead be generated only with a zero value of the \n\u201cConceal VMX entries from Intel\u00ae PT\u201d field (Bit 17) in the Entry Control register \n(IA32_VMX_ENTRY_CTLS MSR 0484H).",
        "implication": "An Intel\u00ae PT trace may incorrectly expose entry to non-root operation.",
        "workaround": "A virtual machine monitor (VMM) should always set both the \u201cConceal VMX entries \nfrom Intel\u00ae PT\u201d field in the Entry Control register and the \u201cConceal VMX in Intel\u00ae PT\u201d \nin the Secondary Execution Control register to the same value.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "110": {
        "title": "eDRAM May Generate Errors or Other Unexpected System Behavior",
        "problem": "VCCSA eDRAM voltage level is incorrectly configured to a lower-than-intended Vmin \nvalue.",
        "implication": "Due to this erratum, the eDRAM may generate correctable or uncorrectable errors or \nmay otherwise exhibit unexpected system behavior.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "111": {
        "title": "Performance Monitor Event For Outstanding Offcore Requests May be \nIncorrect",
        "problem": "The performance monitor event OFFCORE_REQUESTS_OUTSTANDING (Event 60H, \nany Umask Value) should count the number of offcore outstanding transactions each \ncycle. Due to this erratum, the counts may be higher or lower than expected.",
        "implication": "The performance monitor event OFFCORE_REQUESTS_OUTSTANDING may reflect an \nincorrect count.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "112": {
        "title": "Certain DDR4 Memory Configurations May Cause Unpredictable System \nBehavior",
        "problem": "When using SODIMM or UDIMM in DDR4 2N CMD timing mode, the processor may \nincorrectly de-emphasize the first CMD bit transmitted.",
        "implication": "When this erratum occurs, memory commands may not complete, potentially leading \nto system hang or unpredictable system behavior.",
        "workaround": "A BIOS code change has been identified and may be implemented as a workaround \nfor this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "113": {
        "title": "VCVTPS2PH To Memory May Update MXCSR in The Case of a Fault on The \nStore",
        "problem": "Execution of the VCVTPS2PH instruction with a memory destination may update the \nMXCSR exceptions flags (bits [5:0]) if the store to memory causes a fault (Example, \n#PF) or VM exit. The value written to the MXCSR exceptions flags are what would \nhave been written if there were no fault.",
        "implication": "Software may find exceptions flags set in MXCSR, although the instruction has not \nsuccessfully completed due to a fault on the memory operation. Intel has not \nobserved this erratum to affect any commercially available software.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "114": {
        "title": "Intel\u00ae PT May Drop All Packets After an Internal Buffer Overflow",
        "problem": "Due to a rare microarchitectural condition, an Intel\u00ae Processor Trace (Intel\u00ae PT) Table \nof Physical Addresses (ToPA) entry transition can cause an internal buffer overflow \nthat may result in all trace packets, including the Overflow (OVF) packet, being \ndropped.",
        "implication": "When this erratum occurs, all trace data will be lost until either PT is disabled and re-\nenabled via IA32_RTIT_CTL.TraceEn [bit 0] (MSR 0570H) or the processor enters and \nexits a C6 or deeper C state.",
        "workaround": "None identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "115": {
        "title": "Intel\u00ae PT ToPA Tables Read From Non-Cacheable Memory During An Intel\u00ae \nTSX Transaction May Lead To Processor Hang",
        "problem": "If an Intel\u00ae PT (Processor Trace) ToPA (Table of Physical Addresses) table is placed in \nUC (Uncacheable) or USWC (Uncacheable Speculative Write Combining) memory, and \na ToPA output region is filled during an Intel\u00ae TSX (Transaction Synchronization) \ntransaction, the resulting ToPA table read may cause a processor hang.",
        "implication": "Placing Intel\u00ae PT ToPA tables in non-cacheable memory when Intel\u00ae TSX is in use \nmay lead to a processor hang.",
        "workaround": "None identified.  Intel\u00ae PT ToPA tables should be located in WB memory if Intel\u00ae TSX \nis in use.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "116": {
        "title": "Performing an XACQUIRE To An Intel\u00ae PT ToPA Table May Lead To Processor \nHang",
        "problem": "If an XACQUIRE lock is performed to the address of an Intel\u00ae PT (Processor Trace) \nToPA (Table of Physical Addresses) table, and that table is later read by the CPU \nduring the HLE (Hardware Lock Elision) transaction, the processor may hang.",
        "implication": "Accessing ToPA tables with XACQUIRE may result in a processor hang.",
        "workaround": "None identified.  Software should not access ToPA tables using XACQUIRE.  An OS or \nhypervisor may wish to ensure all application or guest writes to ToPA tables to take \npage faults or EPT violations.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "117": {
        "title": "ZMM/YMM Registers May Contain Incorrect Values",
        "problem": "Under complex micro architectural conditions values stored in ZMM and YMM \nregisters may be incorrect.",
        "implication": "Due to this erratum, YMM and ZMM registers may contain an incorrect corrupted \nvalue. Intel has not observed this erratum with any commercially available software.",
        "workaround": "It is possible for BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "118": {
        "title": "Data Breakpoint May Not be Detected On A REP MOVS",
        "problem": "A REP MOVS instruction that causes an exception or a VM exit may not detect a data \nbreakpoint that occurred on an earlier memory access of that REP MOVS instruction.",
        "implication": "A debugger may miss a data read/write access if it is done by a REP MOVS \ninstruction.",
        "workaround": "Software that relies on data breakpoint for correct execution should disable fast-\nstrings (bit 0 in IA32_MISC_ENABLE MSR).",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "119": {
        "title": "Intel\u00ae PT CYC Packets Can be Dropped When Immediately Preceding PSB",
        "problem": "Due to a rare micro architectural condition, generation of an Intel\u00ae PT (Processor \nTrace) PSB (Packet Stream Boundary) packet can cause a single CYC (Cycle Count) \npacket, possibly along with an associated MTC (Mini Time Counter) packet, to be \ndropped.",
        "implication": "An Intel\u00ae PT decoder that is using CYCs to track time or frequency gets an improper \nvalue due to the lost CYC packet.",
        "workaround": "If an Intel\u00ae PT decoder is using CYCs and MTCs to track frequency, and either the \nfirst MTC following a PSB shows that an MTC was dropped, or the CYC value appears \nto be 4095 cycles short of what is expected, the CYC value associated with that MTC \nshould not be used.  The decoder should wait for the next MTC before measuring \nfrequency again.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "120": {
        "title": "Last Level Cache/ Ring Maximum Frequency May Be Reported Incorrectly",
        "problem": "LLC (Last Level Cache) /Ring frequency limit register MSR 0x620 \n(UNCORE_RATIO_LIMIT) is incorrectly set to a higher frequency",
        "implication": "Due to this erratum, software may report incorrect ring maximum frequency.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "121": {
        "title": "The Processor May Hang Or Exhibit Display Flickering",
        "problem": "When the processor is paired with a PCH that does not support PECI over eSPI, the \nprocessor may hang or exhibit display flickering.",
        "implication": "Due to this erratum, the processor hangs or exhibits a display flickering.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "122": {
        "title": "When Virtualization Exceptions Are Enabled, EPT Violations May Generate \nErroneous Virtualization Exceptions",
        "problem": "An access to a GPA (guest-physical address) may cause an EPT-violation VM \nexit. When the \u201cEPT-violation #VE\u201d VM-execution control is 1, an EPT violation may \ncause a #VE (virtualization exception) instead of a VM exit. Due to this erratum, an \nEPT violation may erroneously cause a #VE when the \u201csuppress #VE\u201d bit is set in the \nEPT paging-structure entry used to map the GPA being accessed. This erratum does \nnot apply when the \u201cEPT-violation #VE\u201d VM-execution control is 0 or when delivering \nan event through the IDT. This erratum applies only when the GPA in CR3 is used to \naccess the root of the guest paging-structure hierarchy (or, with PAE paging, when \nthe GPA in a PDPTE is used to access a page directory).",
        "implication": "When using PAE paging mode, an EPT violation that should cause a VMexit in the \nVMM may instead cause a VE# in the guest. In other paging modes, in addition \nto delivery of the erroneous #VE, the #VE may itself cause an EPT violation, but this \nEPT violation is correctly delivered to the VMM.",
        "workaround": "A VMM may support an interface that guest software can invoke with the VMCALL \ninstruction when it detects an erroneous #VE.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "123": {
        "title": "System May Hang With Multiple Pending Posted Writes When Using Direct \nMMIO Write Access Model",
        "problem": "Under complex conditions, if a device fails to consume at least 8 posted writes within \n5us and its device driver uses a Direct MMIO write access software model and \nEnhanced Intel\u00ae SpeedStep\u00ae Technology is enabled, the system may hang with an \ninternal timer error machine check with error code IA32_MCi_STATUS[15:0] = \n0x0400",
        "implication": "Due to this erratum, the system may hang. Intel has only observed this erratum to \noccur with a direct MMIO write access model.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "124": {
        "title": "Using Intel\u00ae TSX Instructions May Lead To Unpredictable System Behavior",
        "problem": "Under complex micro architectural conditions, software using Intel\u00ae TSX \n(Transactional Synchronization Extensions) may result in unpredictable system \nbehavior.  Intel has only seen this under synthetic testing conditions. Intel is not \naware of any commercially available software exhibiting this behavior.",
        "implication": "Due to this erratum, unpredictable system behavior may occur.",
        "workaround": "It is possible for BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "125": {
        "title": "Intel\u00ae PT Trace May Drop Second Byte Of CYC Packet",
        "problem": "Due to a rare micro architectural condition, the second byte of a 2-byte CYC (Cycle \nCount) packet may be dropped without an OVF (Overflow) packet.",
        "implication": "A trace decoder may signal a decode error due to the lost trace byte.",
        "workaround": "None identified. A mitigation is available for this erratum. If a decoder encounters a \nmulti-byte CYC packet where the second byte has bit 0 (Ext) set to 1, it should \nassume that 4095 cycles have passed since the prior CYC packet, and it should \nignore the first byte of the CYC and treat the second byte as the start of a new \npacket.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "126": {
        "title": "Unexpected Uncorrected Machine Check Errors May Be Reported",
        "problem": "In rare micro-architectural conditions, the processor may report unexpected machine \ncheck errors. When this erratum occurs, IA32_MC0_STATUS (MSR 401H) has the \nvalid bit set (bit 63), the uncorrected error bit set (bit 61), a model specific error \ncode of 03H (bits [31:16]) and an MCA error code of 05H (bits [15:0]).",
        "implication": "Due to this erratum, software may observe unexpected machine check exceptions.",
        "workaround": "None Identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "127": {
        "title": "Intel\u00ae PT PSB+ Packets May Be Omitted On A C6 Transition",
        "problem": "An Intel\u00ae PT (Processor Trace) PSB+ (Packet Stream Boundary+) set of packets may \nnot be generated as expected when IA32_RTIT_STATUS.PacketByteCnt[48:32] (MSR \n0x571) reaches the PSB threshold and a logical processor C6 entry occurs within the \nfollowing one KByte of trace output.",
        "implication": "After a logical processor enters C6, Intel\u00ae PT output may be missing PSB+ sets of \npackets.",
        "workaround": "None Identified.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "128": {
        "title": "Intel\u00ae PT PacketEn Change On C-state Wake May Not Generate A TIP Packet",
        "problem": "A TIP.PGE (Target IP, Packet Generation Enabled) or TIP.PGD (Target IP, Packet \nGeneration Disabled) packet may not be generated if Intel\u00ae PT (Processor Trace) \nPacketEn changes after IA32_RTIT_STATUS.FilterEn (MSR 571H, bit 0) is re-\nevaluated on wakeup from C6 or deeper sleep state.",
        "implication": "When code enters or exits an IP filter region without a taken branch, tracing may \nbegin or cease without proper indication in the trace output. This may affect trace \ndecoder behavior.",
        "workaround": "None identified. A trace decoder needs to skip ahead to the next TIP or FUP packet to \ndetermine the current IP.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "129": {
        "title": "Processor May Hang During PKG-C8/C9/C10 Exit",
        "problem": "Due to marginal voltage configuration of internal restore SRAM, the processor may \nhang.",
        "implication": "When this erratum occurs, the processor May Hang. Intel\u00ae has only observed this \nerratum in synthetic test conditions.",
        "workaround": "None identified. A trace decoder needs to skip ahead to the next TIP or FUP packet to \ndetermine the current IP.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "130": {
        "title": "Graphics VTd Hardware May Cache Invalid Entries",
        "problem": "The processor\u2019s graphics IOMMU (I/O Memory Management Unit) may cache invalid \nVTd context entries. This violates the VTd specification for HW Caching Mode where \nhardware implementations of this architecture must not cache invalid entries.",
        "implication": "Due to this erratum, unpredictable system behavior and/or a system hang may \noccur.",
        "workaround": "Software should flush the Gfx VTd context cache after any update of context table \nentries",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "131": {
        "title": "Processor May Hang at High Temperature With A High-Throughput Graphics \nWorkload",
        "problem": "In systems that support Single Core Turbo frequencies up to 4.7 GHz, the Ring \nfrequency may operate at 4.4GHz.  In this condition, if the processor is operating \nwith a high-throughput graphics workload and the processor is operating near \nmaximum junction temperature, the processor may hang.",
        "implication": "Due to this erratum the processor may hang. Intel\u00ae has only observed this erratum \nunder synthetic test conditions.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "132": {
        "title": "Queued Invalidation Is Prevented When VTd Is Disabled",
        "problem": "While both the DMA-Remapping and Interrupt-Remapping capabilities are disabled in \nthe Default VTd Engine, then Queued Invalidation is incorrectly disabled.",
        "implication": "Due to this erratum, unexpected system behavior may occur.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "133": {
        "title": "Executing Some Instructions May Cause Unpredictable Behavior",
        "problem": "Under complex micro-architectural conditions, executing an X87, AVX, or integer \ndivide instruction may result in unpredictable system behavior.",
        "implication": "When this erratum occurs, the system may behave unpredictably. Intel has not \nobserved this erratum with any commercially available software.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "134": {
        "title": "Processor May Behave Unpredictably On Complex Sequence Of Conditions \nWhich Involve Branches That Cross 64 Byte Boundaries",
        "problem": "Under complex micro-architectural conditions involving branch instructions bytes that \nspan multiple 64 byte boundaries (cross cache line), unpredictable system behavior \nmay occur.",
        "implication": "When this erratum occurs, the system may behave unpredictably.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "135": {
        "title": "A PMI That Freezes LBRs Can Cause A Duplicate Entry In TOS",
        "problem": "If a PMI (Performance Monitor Interrupt) is taken while LBRs (Last Branch Records) \nare enabled and IA32_DEBUGCTL.FREEZE_LBRS_ON_PMI[bit 11]=1 (MSR 01D9H), a \ntaken branch that performs an LBR update near the time of the PMI may instead \nrecord a duplicate of the prior entry into the TOS (Top of Stack) entry.",
        "implication": "Software may unexpectedly observe the appearance of back-to-back execution of the \nsame branch.",
        "workaround": "In general, software can ignore the TOS entry if it matches the TOS-1 entry.  Note \nthat certain code sequences with no intervening taken branches can legitimately \ninsert a valid duplicate LBR record in the TOS entry.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "136": {
        "title": "Unexpected Page Faults In Guest Virtualization Environment",
        "problem": "Under complex micro-architectural conditions, a virtualized guest could observe \nunpredictable system behavior.",
        "implication": "When this erratum occurs, systems operating in a virtualization environment may \nexhibit unexpected page faults (double faults) leading to guest OS shutdown.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    },
    "137": {
        "title": "SGX Key Confidentiality May Be Compromised",
        "problem": "Under complex micro-architectural conditions, it may be possible for the value of SGX \nkeys to be inferred using speculative execution side channel methods.",
        "implication": "If exposed, such keys could allow an attacker to access SGX enclave data. Processors \nthat do not support Hyper-Threading are not affected by this issue.",
        "workaround": "It is possible for the BIOS to contain a workaround for this erratum.",
        "status": "For the steppings affected, refer the Summary Table of Changes."
    }
}