{
    "57": {
        "title": "Some Data Cache Tag Eviction Errors Are Reported As Snoop Errors",
        "problem": "In some cases, the machine check error code on a data cache (DC) tag array parity error erroneously classifies an eviction error as a snoop error. The common cases of cache line replacements and external probes are classified correctly (as eviction and snoop respectively). The erroneous cases occur when a tag error is detected during a DC eviction that was generated by a hardware prefetch, a cache line state change operation, or a number of other internal microarchitectural events. In such cases, the error code logged in the DC Machine Check Status register (MC0_STATUS, MSR0000_0401) erroneously indicates a snoop error.",
        "implication": "Internally detected DC tag errors may be reported to software as having been detected by snoops. Depending upon machine check software architecture, the system response to such errors may be broader than necessary.",
        "workaround": "None required.",
        "status": "No"
    },
    "60": {
        "title": "Single Machine Check Error May Report Overflow",
        "problem": "A single parity error encountered in the data cache tag array may incorrectly report the detection of multiple errors, as indicated by the overflow bit of the DC Machine Check Status register (bit 62 of MSR0000_0401).",
        "implication": "System software may be informed of a machine check overflow when only a single error was actually encountered.",
        "workaround": "None required.",
        "status": "No"
    },
    "77": {
        "title": "Long Mode CALLF or JMPF May Fail To Signal GP When Callgate Descriptor is Beyond GDT/LDT Limit",
        "problem": "If the target selector of a far call or far jump (CALLF or JMPF) instruction references a 16-byte long mode system descriptor where any of the last 8 bytes are beyond the GDT or LDT limit, the processor fails to report a General Protection fault.",
        "implication": "None expected, since the operating system typically aligns the GDT/LDT limit such that all descriptors are legal. However, in the case of erroneous operating system software, the above described GP fault will not be signaled, resulting in unpredictable system failure.",
        "workaround": "None required, it is anticipated that long mode operating system software will ensure the GDT and LDT limits are set high enough to cover the larger (16-byte) long mode system descriptors.",
        "status": "No"
    },
    "230": {
        "title": "Misaligned I/O Reads That Span CFCh Incorrectly Generate a Downstream I/O Request",
        "problem": "When configuration space is enabled, IOCF8[31] is 1b, an I/O read to address CFCh should result in a configuration request to the address specified in register IOCF8. However, when a misaligned downstream double word I/O read spans address CFCh the northbridge (NB) correctly sends an I/O read requests to CF8h with appropriate byte enables to the device attached to the I/O link, but incorrectly sends an I/O read request to CFCh instead of the configuration request.",
        "implication": "None expected.",
        "workaround": "Software should not issue misaligned read requests to I/O addresses that span address CFCh.",
        "status": "No"
    },
    "250": {
        "title": "I/O Reads That Span 3BBh May Be Positively Decoded When They Should Not Be Positively Decoded",
        "problem": "The northbridge enables positive decode within the first 64 KB of I/O space mapped by the I/O base/limit registers (D18F1xC0 and D18F1xC4) for the legacy VGA registers when D18F1xC0[4] (VE) is 1b and D18F1xF4[0] (VE) is 0b, i.e. accesses in which address bits[9:0] range from 3B0h to 3BBh or 3C0h to 3DFh and address bits[24:16] are all 0. However, if an I/O read spans address 3BBh, the northbridge will positively decode the entire access including the addresses outside the legacy VGA register space (i.e. 3B[C:E]h).",
        "implication": "A downstream request to I/O addresses 3B[C:E]h may not properly set the Compat bit. This may result in the packet not being forwarded to the compatibility bus.",
        "workaround": "None required.",
        "status": "No"
    },
    "297": {
        "title": "Single Machine Check Error May Report Overflow",
        "problem": "A single tag snoop parity error encountered in the instruction cache tag array may incorrectly report the detection of multiple errors, as indicated by the overflow bit of the IC Machine Check Status register (MSR0000_0405[62]).",
        "implication": "System software may be informed of a machine check overflow when only a single error was actually encountered.",
        "workaround": "None required.",
        "status": "No"
    },
    "343": {
        "title": "Eviction May Occur When Using L2 Cache as General Storage During Boot",
        "problem": "When system software is using the L2 cache as general storage before memory initialization, the processor may determine during speculative execution that data destined for the instruction cache is dirty. The processor will then evict these cache lines, resulting in lost data.",
        "implication": "System software using L2 cache as general storage before memory initialization may experience unpredictable system behavior.",
        "workaround": "System software should set MSRC001_102A[35] to 1b prior to using L2 cache as general storage during boot. System software should clear MSRC001_102A[35] to 0b after the L2 cache is no longer used as general storage.",
        "status": "No"
    },
    "361": {
        "title": "Breakpoint Due to an Instruction That Has an Interrupt Shadow May Be Lost",
        "problem": "A #DB exception occurring in guest mode may be discarded under the following conditions: \u2022 A trap-type #DB exception is generated in guest mode during execution of an instruction with an interrupt shadow, and \u2022 The instruction that generated the exception is immediately followed by an instruction resulting in #VMEXIT.",
        "implication": "None expected under normal conditions. Debug exceptions may not be received for programs running under a hypervisor.",
        "workaround": "None.",
        "status": "No"
    },
    "366": {
        "title": "Improper DIMM On-Die Termination Signaling May Occur",
        "problem": "Certain memory configurations may cause improper DIMM on-die termination (ODT) signaling when the AMD recommended settings for DCT ODT Control (D18F2x[1,0]F4_x180 and D18F2x[1,0]F4_x182) are not used. The AMD recommended values for D18F2x[1,0]F4_x180 and D18F2x[1,0]F4_x182 are provided in the BIOS and Kernel Developer\u2019s Guide (BKDG) for AMD Family 12h Processors, order# 41131.",
        "implication": "Unreliable DRAM signaling.",
        "workaround": "D18F2x[1,0]F4_x180 and D18F2x[1,0]F4_x182 should remain at the AMD recommended values.",
        "status": "No"
    },
    "418": {
        "title": "Host Mapping of Physical Page Zero May Cause Incorrect Translation",
        "problem": "The processor may use an incorrect cached copy of translation tables during an SVM nested page translation when the host is in legacy Physical Address Extension (PAE) mode and the guest address translation tables reside in physical page zero.",
        "implication": "Unpredictable system behavior. This condition has not been observed in any commercially available software.",
        "workaround": "Hypervisor software should not use physical addresses 0 through 4095 for guest pages.",
        "status": "No"
    },
    "430": {
        "title": "Processor May Not Recognize A20M# Change During CC6",
        "problem": "A processor core that is in Core C6 (CC6) state at the time that A20 Mask (A20M#) changes state may continue to operate using the previous A20M# value after CC6 exit.",
        "implication": "None expected. Since no multi-core operating system uses A20M#, state changes during CC6 state are not expected.",
        "workaround": "None required.",
        "status": "No"
    },
    "432": {
        "title": "DEV Error May Be Erroneously Logged After a Warm Reset",
        "problem": "An uncorrectable DMA Exclusion Vector (DEV) table walk error may erroneously be logged if a warm reset is initiated while a DEV table walk is in progress.",
        "implication": "A false uncorrectable error may be reported to system software.",
        "workaround": "None required.",
        "status": "No"
    },
    "441": {
        "title": "Move from Stack Pointer to Debug or Control Register May Result in Incorrect Value",
        "problem": "A move from the stack pointer to a debug register or a control register may store a value that does not include one or more updates based on completed pushes, pops, near calls or returns. This erratum does not occur if the instruction encoding uses the standard encoding of ModRM[7:6]=11b to indicate a register-to-register move.",
        "implication": "None expected based on the ModRM[7:6] normally being 11b.",
        "workaround": "Always encode ModRM[7:6]=11b when performing a move into a debug or control register.",
        "status": "No"
    },
    "465": {
        "title": "First MRS Command After DRAM Initialization May Time-out",
        "problem": "The first DIMM Mode Register Set (MRS) command after DRAM Initialization Register[EnDramInit] (D18F2x[1,0]7C[31]) is set may take up to 2.5 ms to complete.",
        "implication": "BIOS time-out may occur resulting in a boot failure.",
        "workaround": "BIOS must use a time-out value greater than 2.5 ms for the MRS command sequence.",
        "status": "No"
    },
    "470": {
        "title": "Warm Reset May Cause System Hang",
        "problem": "The processor may hang if a warm reset occurs while a register access to any of the PCI Express\u00ae controllers' internal registers is in progress. The processor may perform register accesses for internal management purposes that are transparent to software.",
        "implication": "System hang.",
        "workaround": "System BIOS should set D0F0xE4_x013[2:0]_8063 bits 4, 5, 12, 13 and 14 to 1b. This must be done early in the BIOS boot sequence to minimize the possibility of a hang due to a warm reset during the boot sequence. During a link reconfigure operation, system BIOS must perform the following steps: 1. Clear D0F0xE4_x013[2:0]_8063 bits 4, 5, 12, 13 and 14 to 0b. 2. Perform the link reconfigure operation. 3. Set D0F0xE4_x013[2:0]_8063 bits 4, 5, 12, 13 and 14 to 1b.",
        "status": "No"
    },
    "474": {
        "title": "Memory Clear Feature May Use Non-Zero Pattern",
        "problem": "During a memory clear function (DRAM Controller Select Low Register[MemClrInit], D18F2x110[3]), the processor may not use zeros as the write pattern.",
        "implication": "Memory is not cleared to zeros. This may lead to boot failure if BIOS assumes that unused memory is cleared.",
        "workaround": "Before performing the memory clear function, BIOS should use the continuous pattern generator to perform a cache line write of zeros, followed by a read of the cache line. Consult the read and write pattern generation algorithms in the BIOS and Kernel Developer\u2019s Guide (BKDG) for AMD Family 12h Processors, order# 41131.",
        "status": "No"
    },
    "541": {
        "title": "IBS Registers May Be Unpredictable After CC6 State",
        "problem": "The following Instruction-Based Sampling (IBS) registers may be unpredictable after the processor core exits the core C6 (CC6) state: \u2022 Read-only bits MSRC001_1030 IBS Fetch Control Register \u2022 MSRC001_1031 IBS Fetch Linear Address Register \u2022 MSRC001_1032 IBS Fetch Physical Address Register \u2022 MSRC001_1034 IBS Op Logical Address Register \u2022 MSRC001_1035 IBS Op Data Register \u2022 MSRC001_1036 IBS Op Data 2 Register \u2022 MSRC001_1037 IBS Op Data 3 Register \u2022 MSRC001_1038 IBS DC Linear Address Register \u2022 MSRC001_1039 IBS DC Physical Address Register \u2022 MSRC001_103B IBS Branch Target Address Register When IBS is not enabled at the time that the processor core enters CC6 state, the erratum conditions do not apply.",
        "implication": "In cases where the performance monitoring software fetches the IBS sampled data and the processor core has entered the CC6 state since this sample, the performance monitoring software may observe unpredictable values and may generate inaccurate results. The performance monitoring software would normally consume the sampled IBS data before a CC6 entry occurs, resulting in no observed effect under normal conditions.",
        "workaround": "Performance monitoring software should avoid entering ACPI sleep states (C1/HALT or C2) prior to accessing the IBS registers.",
        "status": "No"
    },
    "564": {
        "title": "Processor May Fail to Set Auto-Halt Restart in SMM Save State",
        "problem": "The processor core may not set the auto-halt restart flag (offset FEC9h of the SMM save state area) when a HLT instruction causes the processor core to enter the core C6 (CC6) state and is then interrupted by an SMI. After the SMM code executes the RSM instruction, the processor core does not re-enter the HLT or CC6 state due to this incorrect auto-halt restart flag.",
        "implication": "The processor may continue execution after the HLT instruction, resulting in unpredictable system behavior. The operating system is not required to have a valid instruction after a HLT instruction when rFLAGS.IF = 1.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No"
    },
    "565": {
        "title": "Processor Cores Observe Separate IBS Control Registers",
        "problem": "The processor implements the IBS Control Register as multiple registers, one per processor core. A read of this register using either MSRC001_103A or D18F3x1CC from one processor core may not observe a write to D18F3x1CC that has been performed by another processor core.",
        "implication": "Performance monitoring software using Instruction-Based Sampling (IBS) may incorrectly detect that no Local Vector Table (LVT) has been assigned to the IBS interrupt.",
        "workaround": "BIOS should write D18F3x1CC to the same value using all enabled processor cores. System software is not expected to modify the BIOS value, although in the event that system software writes D18F3x1CC, it must also write D18F3x1CC using all processor cores.",
        "status": "No"
    },
    "573": {
        "title": "Processor May Incorrectly Update Instruction Pointer After FSINCOS Instruction",
        "problem": "After execution of an FSINCOS instruction, the processor core may incorrectly update the instruction pointer (rIP) and execute incorrect instructions or may hang.",
        "implication": "Unpredictable system behavior after execution of an FSINCOS instruction.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No"
    },
    "596": {
        "title": "Northbridge Clock Gating May Lead to Invalid Prefetched Data",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the northbridge may gate the clock (NCLK) to the In-Flight Queue (IFQ) while a DRAM prefetch caused by a CPU fetch is still outstanding. This may result in the prefetch buffer being marked valid but with unpredictable data. IFQ clock gating is performed only when no cores are in C0 state.",
        "implication": "Unpredictable system behavior. This has not been observed with any commercially available software.",
        "workaround": "BIOS should not set Clock Power/Timing Control 2 Register[NbClockGateEn] (D18F3xDC[30]) and leave this bit at its reset value of 0b.",
        "status": "No"
    },
    "662": {
        "title": "Processor May Hang While Performing Voltage Transitions Overlapping with C-state Requests",
        "problem": "A processor may hang while performing overlapping voltage transitions and C-state requests. The hang may result when one of the following conditions occurs: \u2022 The processor performs a core performance boost (CPB) transition that requires a voltage transi- tion just prior to a core entering C1 state (HLT instruction or I/O C-state based). Prior to this volt- age transition completing, the processor core transitions from C1 to C0 state and another C-state is requested by software. This new C-state flushes the processor caches and performs core C6 (CC6) clock gating. \u2022 The processor performs a hardware thermal control (HTC) transition that requires a voltage tran- sition just prior to a core entering C1 state (HLT instruction or I/O C-state based). Prior to this voltage transition completing, the processor core recognizes a second HTC transition and the pro- cessor core transitions from C1 to C0 state and another C-state is requested by software. This new C-state flushes the processor caches and performs core C6 (CC6) clock gating. The hang is possible only if the initial voltage transition has not completed by the time the CC6 clock gating occurs.",
        "implication": "Processor core hang",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No"
    },
    "665": {
        "title": "Integer Divide Instruction May Cause Unpredictable Behavior",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor core may abort a speculative DIV or IDIV integer divide instruction (due to the speculative execution being redirected, for example due to a mispredicted branch) but may hang or prematurely complete the first instruction of the non-speculative path.",
        "implication": "Unpredictable system behavior, usually resulting in a system hang.",
        "workaround": "BIOS should set MSRC001_1029[31]. This workaround alters the DIV/IDIV instruction latency specified in the Software Optimization Guide for AMD Family 10h and 12h Processors, order# 40546. With this workaround applied, the DIV/IDIV latency for AMD Family 12h Processors are similar to the DIV/IDIV latency for AMD Family 10h Processors.",
        "status": "No"
    },
    "670": {
        "title": "Segment Load May Cause System Hang or Fault After State Change",
        "problem": "Under a highly specific and detailed set of conditions, a segment load instruction may cause a failure in one of the following instructions later in the instruction stream: \u2022 BTC mem, imm8 \u2022 BTC mem, reg \u2022 BTR mem, imm8 \u2022 BTR mem, reg \u2022 BTS mem, imm8 \u2022 BTS mem, reg \u2022 RCL mem, cl \u2022 RCL mem, imm \u2022 RCR mem, cl \u2022 RCR mem, imm \u2022 SHLD mem, reg, imm \u2022 SHLD mem, reg, cl \u2022 SHRD mem, reg, imm \u2022 SHRD mem, reg, cl \u2022 XCHG mem, reg (uses an implicit LOCK prefix) \u2022 XCHG reg, mem (uses an implicit LOCK prefix) \u2022 Any instruction with an explicit LOCK prefix in the instruction opcode.",
        "implication": "For affected instructions that have an implicit or explicit LOCK prefix, a system hang occurs. For affected instructions that do not have an implicit or explicit LOCK prefix, the processor may present a #PF exception after some of the instruction effects have been applied to the processor state. No system effect is observed unless the operating system\u2019s page fault handler has some dependency on this interim processor state, which is not the case in any known operating system software. The interim state does not impact program behavior if the operating system resolves the #PF and resumes the instruction. However, this interim state may be observed by a debugger or if the operating system changes the #PF to a program error (for example, a segmentation fault).",
        "workaround": "System software should set MSRC001_1020[8] = 1b. \u2020 This workaround ensures that instructions with an implicit or explicit LOCK prefix do not cause a system hang due to this erratum. However, instructions may still present a #PF after altering architectural state.",
        "status": "No"
    },
    "686": {
        "title": "Processor Does Not Implement MSRC001_0055",
        "problem": "The processor does not properly allow writes to MSRC001_0055 (Interrupt Pending Register). A write to MSRC001_0055 is ignored and a read to the register returns zero.",
        "implication": "BIOS is unable to program this register.",
        "workaround": "Contact your AMD representative for a BIOS workaround.",
        "status": "No"
    },
    "700": {
        "title": "LAR and LSL Instructions Do Not Check Invalid Long Mode Descriptor Types",
        "problem": "The architecture specifies that the processor checks for invalid descriptor types when a Load Access Rights Byte (LAR) instruction or a Load Segment Limit (LSL) instruction is executed in long mode. An invalid descriptor type should cause the processor to clear the zero flag (ZF) and complete the instruction without modifying the destination register. However, the processor does not perform this check and loads the attribute (LAR) or segment limit (LSL) as if the descriptor type was valid. The invalid descriptor types for LAR are 1 (available 16-bit TSS), 3 (busy 16-bit TSS), 4 (16-bit call gate) or 5 (task gate). The invalid descriptor types for a LSL instruction are types 1 (available 16-bit TSS) or 3 (busy 16-bit TSS).",
        "implication": "None expected, since the operating system code would typically only provide legal descriptors. However, in the case of erroneous software, the above described check would not be performed, resulting in unpredictable system failure. AMD has not observed this erratum with any commercially- available software.",
        "workaround": "None required, it is anticipated that long mode operating system code ensures that the descriptor type is legal when executing LAR and LSL instructions.",
        "status": "No"
    },
    "710": {
        "title": "AD631XOJZ43GX Incorrectly Reports a Maximum Rate of DDR3-1600",
        "problem": "OPN AD631XOJZ43GX (65W FM1 AMD Athlon\u2122 II X4 631X Quad-Core Processor) may incorrectly report a maximum DDR transfer rate of 1600 MT/s. The actual maximum transfer rate of this OPN should be 1866 MT/s. Northbridge Capabilities Register[DdrMaxRate], D18F3xE8[7:5] may be equal to 001b, indicating DDR3-1600. The correct value should be 000b.",
        "implication": "The BIOS may incorrectly limit the DDR rate with DDR3-1866 DIMMs to 1600 MT/s.",
        "workaround": "No workaround is necessary with DDR3-1600 (or lower) DIMMs, on a FS1 motherboard, or on a FM1 motherboard that has two DIMM slots per channel. System developers with an FM1 motherboard that has only one DIMM slot per channel and that use this OPN with DDR3-1866 DIMMs may require a workaround. To implement a workaround, platform BIOS replaces the actual reported value in the Northbridge Capabilities Register[DdrMaxRate] field (D18F3xE8[7:5]) with 000b if the above affected processor type (OPN) is detected. The affected OPN can be uniquely identified if all of the following characteristics are true: \u2022 CPUID Fn0000_0001_EAX = 00300F10h (LN-B0) \u2022 CPUID Fn8000_0001_EBX BrandId Identifier[PkgType, bits 31:28] = 0010b (FM1) \u2022 D18F3xA0[27:16] = 02Ah",
        "status": "Yes"
    },
    "711": {
        "title": "Processor May Hang During PCIe\u00ae Initialization",
        "problem": "The processor may hang during BIOS boot on a downstream transaction to a PCIe\u00ae interface.",
        "implication": "System hang during BIOS boot.",
        "workaround": "Contact your AMD representative for a BIOS workaround.",
        "status": "No"
    },
    "721": {
        "title": "Processor May Incorrectly Update Stack Pointer",
        "problem": "Under a highly specific and detailed set of internal timing conditions, the processor may incorrectly update the stack pointer after a long series of push and/or near-call instructions, or a long series of pop and/or near-return instructions. The processor must be in 64-bit mode for this erratum to occur.",
        "implication": "The stack pointer value jumps by a value of approximately 1024, either in the positive or negative direction. This incorrect stack pointer causes unpredictable program or system behavior, usually observed as a program exception or crash (for example, a #GP or #UD).",
        "workaround": "System software may set MSRC001_1029[0] = 1b.",
        "status": "No"
    },
    "725": {
        "title": "Incorrect APIC Remote Read Behavior",
        "problem": "The processor may provide incorrect APIC register data on an APIC remote register read. A remote read is performed using Interrupt Command Register Low[MsgType] of 011b (APIC300[10:8]). The processor may, but does not always, provide an error indication in the remote read status field (APIC300[17:16]). This erratum does not impact the use of remote APIC reads by BIOS during early power-on-self-test (POST) when the remote read is performed for addresses APIC300-APIC3F0.",
        "implication": "None expected, as it is anticipated that no software other than BIOS uses remote APIC reads.",
        "workaround": "Software should not use remote APIC reads.",
        "status": "No"
    }
}