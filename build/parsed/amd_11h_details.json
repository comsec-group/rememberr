{
    "57": {
        "title": "Some Data Cache Tag Eviction Errors Are Reported As Snoop Errors",
        "problem": "In some cases, the machine check error code on a data cache (DC) tag array parity error erroneously classifies an eviction error as a snoop error. The common cases of cache line replacements and external probes are classified correctly (as eviction and snoop respectively). The erroneous cases occur when a tag error is detected during a DC eviction that was generated by a hardware prefetch, a cache line state change operation, or a number of other internal microarchitectural events. In such cases, the error code logged in the DC Machine Check Status register (MC0_STATUS, MSR401) erroneously indicates a snoop error.",
        "implication": "Internally detected DC tag errors may be reported to software as having been detected by snoops. Depending upon machine check software architecture, the system response to such errors may be broader than necessary.",
        "workaround": "None required.",
        "status": "No"
    },
    "60": {
        "title": "Single Machine Check Error May Report Overflow",
        "problem": "A single parity error encountered in the data cache tag array may incorrectly report the detection of multiple errors, as indicated by the overflow bit of the DC Machine Check Status register (bit 62 of MSR401).",
        "implication": "System software may be informed of a machine check overflow when only a single error was actually encountered.",
        "workaround": "Do not rely on the state of the OVER bit in the DC Machine Check Status register.",
        "status": "No"
    },
    "77": {
        "title": "Long Mode CALLF or JMPF May Fail To Signal GP When Callgate Descriptor is Beyond GDT/LDT Limit",
        "problem": "If the target selector of a far call or far jump (CALLF or JMPF) instruction references a 16-byte long mode system descriptor where any of the last 8 bytes are beyond the GDT or LDT limit, the processor fails to report a General Protection fault.",
        "implication": "None expected, since the operating system typically aligns the GDT/LDT limit such that all descriptors are legal. However, in the case of erroneous operating system code, the above described GP fault will not be signaled, resulting in unpredictable system failure.",
        "workaround": "None required, it is anticipated that long mode operating system code will ensure the GDT and LDT limits are set high enough to cover the larger (16-byte) long mode system descriptors.",
        "status": "No"
    },
    "122": {
        "title": "TLB Flush Filter May Cause Coherency Problem in Multicore Systems",
        "problem": "Under highly specific internal timing conditions in system configurations that include more than one processor core, coherency problems may arise between the page tables in memory and the translations stored in the on-chip TLBs. This can result in the possible use of stale translations even after software has performed a TLB flush.",
        "implication": "Unpredictable system failure. This scenario has only been observed in a highly randomized synthetic stress test.",
        "workaround": "In multicore systems, disable the TLB flush filter by setting HWCR.FFDIS (bit 6 of MSRC001_0015).",
        "status": "No"
    },
    "144": {
        "title": "CLFLUSH to Shadow RAM Address Will Not Invalidate",
        "problem": "WrDram and RdDram bits in extended MTRR type registers are used to copy BIOS ROM to corresponding DRAM and then execute out of DRAM. When these are configured to direct writes to ROM (WrMem =0b) and reads to DRAM (RdMem =01b), the CLFLUSH instruction will not invalidate shadow RAM addresses in the cache.",
        "implication": "CLFLUSH instruction will be ineffective for shadow RAM space.",
        "workaround": "Use the WBINVD instruction instead of CLFLUSH in shadow RAM space.",
        "status": "No"
    },
    "171": {
        "title": "Instruction Break Point On VMRUN Instruction Leads To Unpredictable System Behavior",
        "problem": "VMRUN can be interrupted using a hardware instruction breakpoint using one of the debug registers, DR[0-3]. When the debug handler executes IRET, the processor is expected to execute the VMRUN instruction. However, in the failing case, the processor incorrectly re-enters the breakpoint handler with mixed guest and host state. This in turn causes erroneous execution and leads to unpredictable system behavior.",
        "implication": "Hypervisor developers will not be able to use hardware instruction break point on VMRUN instruction.",
        "workaround": "Set the breakpoint on the instruction prior to VMRUN, then single step through VMRUN.",
        "status": "No"
    },
    "230": {
        "title": "Misaligned I/O Reads That Span CFCh Incorrectly Generate a Downstream I/O Request",
        "problem": "When configuration space is enabled, IOCF8[31] is 1b, an I/O read to address CFCh should result in a configuration request to the address specified in register IOCF8. However, when a misaligned downstream double word I/O read spans address CFCh the northbridge (NB) correctly sends an I/O read requests to CF8h with appropriate byte enables to the device attached to the I/O link, but incorrectly sends an I/O read request to CFCh instead of the configuration request.",
        "implication": "None expected.",
        "workaround": "Software should not issue misaligned read requests to I/O addresses that span address CFCh.",
        "status": "No"
    },
    "250": {
        "title": "I/O Reads That Span 3BBh May Be Positively Decoded When They Should Not Be Positively Decoded",
        "problem": "The northbridge enables positive decode within the first 64K of I/O space mapped by the I/O base/ limit registers (F1xC0/C4) for the legacy VGA registers when F1xC0[4] (VE) is 1b and F1xF4[0] (VE) is 0b, i.e. accesses in which address bits[9:0] range from 3B0h to 3BBh or 3C0h to 3DFh and address bits[24:16] are all 0. However, if an I/O read spans address 3BBh, the northbridge will positive decode the entire access including the addresses outside the legacy VGA register space (i.e. 3B[C:E]h).",
        "implication": "A downstream request to I/O addresses 3B[C:E]h may not properly set the Compat bit. This may result in the packet not being forwarded to the compatibility bus.",
        "workaround": "None required.",
        "status": "No"
    },
    "251": {
        "title": "Northbridge Flow Control Credits May Be Lost Due to Watchdog Time Out",
        "problem": "A peer to peer or CPU transaction that times out in the northbridge due to a Watchdog time out may result in lost flow control credits. In addition, a master abort is not sent for peer to peer transactions that time out in the northbridge due to a Watchdog time out.",
        "implication": "The system may hang.",
        "workaround": "None. The watchdog time out is correctly reported as a MCA exception.",
        "status": "No"
    },
    "272": {
        "title": "Logged Sync Error Results in Error Overflow Being Set",
        "problem": "When a sync error is logged in MC4_STATUS (MSR411), an error overflow is always indicated by MC4_STATUS[Over] (MSR411[62]) being set to 1b.",
        "implication": "None.",
        "workaround": "None required.",
        "status": "No"
    },
    "288": {
        "title": "Write To A F4x184 Register May Access Incorrect Array Register",
        "problem": "The contents of the Link Phy Offset Register (F4x180) may be used at the time of the write into the Link Phy Data Port register (F4x184) to determine which set of registers is being accessed. Since the software does not write F4x180 until after F4x184 when performing an array write operation, this may result in the array write not occurring or going to an unpredictable array register.",
        "implication": "Unpredictable results may occur.",
        "workaround": "The registers accessed by F4x184_x[N:0] can be split into four spaces 1. Direct map registers (When DirectMapEn is 1b) 2. Link FIFO Read Pointer Optimization Registers (offsets CFh and DFh) 3. BIST registers (offsets 100h to 144h) 4. Phy registers (offset E0h) Before performing a write to a F4x184_x[N:0] array register, when the value (i.e. from a previous access) in LinkPhyOffset or DirectMapEn maps to a different space (as defined above), software should first perform a read operation to the intended array register. No workaround is necessary when performing an array read access or when no space switch is involved.",
        "status": "No"
    },
    "297": {
        "title": "Single Machine Check Error May Report Overflow",
        "problem": "A single tag snoop parity error encountered in the instruction cache tag array may incorrectly report the detection of multiple errors, as indicated by the overflow bit of the IC Machine Check Status register (MSR405[62]).",
        "implication": "System software may be informed of a machine check overflow when only a single error was actually encountered.",
        "workaround": "None required.",
        "status": "No"
    },
    "305": {
        "title": "Northbridge Will Not Raise an MCA Exception Unless Status Bits Are Cleared",
        "problem": "A machine check (MCA) exception is not raised if the Northbridge detects an overflow condition. An overflow condition exists if there is already an enabled uncorrectable machine check exception in the Northbridge MCA status register at the time that a second uncorrectable error is detected.",
        "implication": "The system will not enter the shutdown state if another uncorrectable error occurs prior to the MCA handler clearing the Northbridge MCA status register.",
        "workaround": "None.",
        "status": "No"
    },
    "307": {
        "title": "Reset Occurring Near a Dynamic Link Frequency Change May Cause System Failures",
        "problem": "System failure can occur if reset is asserted while an LDTSTOP disconnect is in process for a Centralized Dynamic Link Frequency (CDLF) change and the HyperTransport\u2122 link is operating at a speed of 1000 MHz or lower (Gen1).",
        "implication": "The system may fail to reset.",
        "workaround": "CDLF should not be used in conjunction with Gen1 frequency speeds.",
        "status": "No"
    },
    "311": {
        "title": "Certain Clock Divisors May Result in Unpredictable System Behavior",
        "problem": "The processor may violate internal timing requirements at certain core clock divisors. This may occur if software modifies the CpuFid in the P-state registers (MSRC001_00[6B:64][5:0]) or when core clocks are ramped due to P-state transitions in response to writes to the P-state Control register (MSRC001_0062), HTC, or Halt instruction execution.",
        "implication": "Unpredictable system behavior.",
        "workaround": "Contact your AMD representative for information on a BIOS update. In addition, software should not modify the P-state registers (MSRC001_00[6B:64]), or the HtcPstateLimit (F3x64[30:28]), from their reset values.",
        "status": "No"
    },
    "312": {
        "title": "CVTSD2SS and CVTPD2PS Instructions May Not Round to Zero",
        "problem": "The Convert Scalar Double-Precision Floating Point to Scalar Single-Precision Floating Point (CVTSD2SS) and Convert Packed Double-Precision Floating Point to Packed Single-Precision Floating Point (CVTPD2PS) instructions do not round to zero when the Flush to Zero and Underflow Mask bits (MXCSR bits 15 and 11) are set to 1b and the double-precision operand is less than the smallest single-precision normal number.",
        "implication": "The conversion result will yield the smallest single-precision normalized number rather than zero. It is not expected that this will result in any anomalous software behavior since enabling flush to zero provides less precise results.",
        "workaround": "None.",
        "status": "No"
    },
    "316": {
        "title": "Incorrect CpuDid May Be Applied During ACPI States",
        "problem": "The processor may use an incorrect core clock divisor if it enters or exits the HTC-active state in a narrow window of time after it has applied the CpuDid for an ACPI power state transition. Under these conditions, the CpuDid from the current P-state as indicated by CurPstate (MSRC001_0063[2:0]) is used rather than the CpuDid from the ACPI power state.",
        "implication": "Unpredictable system behavior may result if an alternate voltage (altvid) is enabled for the ACPI power state, for example in C1E, and the CpuDid applied is less than that specified for the ACPI power state.",
        "workaround": "Contact your AMD representative for information on a BIOS update.",
        "status": "No"
    },
    "332": {
        "title": "Alternative Voltage Is Not Supported",
        "problem": "The processor may function improperly when the alternative voltage (altvid) is applied.",
        "implication": "Unpredictable system behavior.",
        "workaround": "System software should not enable the alternative voltage through the Power Management Control Low Register[PMM1[CpuAltVidEn]] (F3x80[12]) or Power Management Control Low Register[PMM3[CpuAltVidEn]] (F3x80[28]). In addition, system software should not enable the alternative voltage through the LMM Configuration Register[LmmCpuAltVidEn] (F4x174_x[0F:00][17]) when using centralized link management.",
        "status": "No"
    },
    "339": {
        "title": "APIC Timer Rollover May Be Delayed",
        "problem": "The APIC timer does not immediately rollover when it transitions to zero and Timer Local Vector Table Entry[Mode] (APIC320[17]) is configured to run in periodic mode. In addition, when Timer Local Vector Table Entry[Mask] (APIC320[16]) is configured to generate an interrupt, the interrupt is also delayed whether configured for periodic or one-shot mode. The per rollover error that may be observed is between 85 and 210 ns.",
        "implication": "None expected. The standard use of the APIC timer and the level of accuracy required does not make the error significant.",
        "workaround": "None required.",
        "status": "No"
    },
    "342": {
        "title": "SMIs That Are Not Intercepted May Disable Interrupts",
        "problem": "During a resume from SMM that is due to an unintercepted SMI from a SVM guest context, the processor core does not restore the correct effective interrupt flag (IF) if the guest VMCB V_INTR_MASKING bit (offset 060h bit 24) is 1b. Under these circumstances, the effective interrupt flag may be zero. SMIs are not intercepted if VMCB offset 00Ch bit 2 is 0b or HWCR[SmmLock] (MSRC001_0015[0]) is 1b.",
        "implication": "The guest context may run with interrupts disabled until the next guest intercept. The hypervisor may not be able to regain control and the system may hang.",
        "workaround": "None. BIOS should not set HWCR[SmmLock] (MSRC001_0015[0]) and hypervisors should intercept SMIs.",
        "status": "No"
    }
}